--[[

	DynaCode
	Inspired by JavaFX.

	This is the framework developed by Harry Felton for use in all modern HexCode programs.

	Copyright (c) 2015 Harry Felton, HexCode and all other contributors

	Current To-Do (* = doing now):
	- New buffer.

	Drawing System:
	- First, create a stage canvas. This will contain the background of the stage. This is done by redirecting the term to the stags redirect and changing the redirect target to the stageCanvas.
	- Then, merge this buffer with the term buffer, ignoring any white space.
	- Merge this with the main program buffer. Before merging every line is set to default (not defined, not edited). Then, on definition these will be changed appropriately 

]]

local termX, termY = term.getSize()
local oTerm = term.current()
local oError = _G.error

local function restore()
	term.redirect( oTerm )
end

--_G.error = function( err, level ) restore() term.setBackgroundColor(colors.black) oError( err, level ) end

local write = oTerm.write
_G.error = function( msg, level )
	term.setBackgroundColor( colors.black )
	if not level or level < 3 then level = 3 else level = level + 1 end
	oTerm.setTextColor( colors.white )
	oTerm.setBackgroundColor( colors.black )
	oError( msg, level )
end

local apiCfg = {
	keepUpToDate = true, -- Check for updates the first time a program is created using this version of the API. (.createProgram())
	updatePath = "DynaCode", -- Where is the API installed
	updateUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/DynaCode", -- Path to download. This is set to my repository on GitHub.
	versionUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/version", -- Path to version file. This is set to my repository on GitHub.
	versionPath = "DynaCodeVersion", -- Leave as is if you like, or change to a file (ideally in the same directory as DynaCode)
	output = true, -- print information to the screen during update check
	resetScreenPost = true, -- clear the screen after update check (recommended because the text color will be changed)
	clearDelay = 1
}

local updateChecked = false

local function clear()
	term.setBackgroundColor( colors.black )
	term.clear()
	term.setCursorPos(1, 1)
end

local function uPrint( color, ... )
	term.setTextColor( color or colors.white )
	if apiCfg.output then
		print( ... )
	end
	term.setTextColor( colors.white )
end

function getUpdateOutputSetting()
	return apiCfg.output
end

function setUpdateOutputSetting( v )
	apiCfg.output = v
end

function getUpdatePathSetting()
	return apiCfg.updatePath
end

function setUpdatePathSetting( v )
	apiCfg.updatePath = v
end

function getUpdateVersionSetting()
	return apiCfg.versionPath
end

function setUpdateVersionSetting( v )
	apiCfg.versionPath = v
end

function getUpdateResetPostSetting()
	return apiCfg.resetScreenPost
end

function setUpdateResetPostSetting( v )
	apiCfg.resetScreenPost = v
end

function setUpdateAutoSetting( v )
	apiCfg.keepUpToDate = v
end

function getUpdateAutoSetting()
	return apiCfg.keepUpToDate
end

function setUpdateDelaySetting( v )
	apiCfg.clearDelay = v
end

function getUpdateDelaySetting()
	return apiCfg.clearDelay
end

function getVersionData( silent )
	if not http then
		if silent then error("getVersionData: Cannot check for updates. ComputerCraft HTTP API is disabled.") else return false, "HTTP Disabled" end
	end
	for i = 1, 3 do
		uPrint( false, "Fetching version information. Attempt "..i.." of 3")
		local response = http.get( apiCfg.versionUrl )
		if response then
			local rData = textutils.unserialize( response.readAll() )
			if not rData then
				if not silent then
					error("getVersionData: Remote Version Data Invalid")
				else
					return false, "getVersionData: Remote Version Data Invalid"
				end
			end
			local update = false
			local localData
			local h = fs.open( apiCfg.versionPath, "r" )
			if h then
				localData = textutils.unserialize( h.readAll() )
				if not localData then
					h.close()
					fs.delete( apiCfg.versionPath )
					os.reboot()
				end
				h.close()
				if localData.version ~= rData.version or localData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
			else
				update = true
			end
			if update then uPrint(colors.orange, "DynaCode 3 is out-of-date") else uPrint( colors.lime, "DynaCode 3 is up-to-date") end
			if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
			if update then
				return update, rData, localData or true
			else
				return update, rData, localData --Returns true if update required and also returns the remote and local version data for manual checks.
			end
		end
	end
	uPrint(colors.red, "Could not fetch version file.")
	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
	return false, "Could not fetch version file"
end

function installVersionData( rData, silent )
	if not http then
		if not silent then error("installVersionData: Cannot fetch updates. ComputerCraft HTTP API is disabled.") else return false, "HTTP Disabled" end
	end
	-- @rData is the remoteDataFile.
	-- Open local file and compare
	if not rData or type( rData ) ~= "table" then if not silent then error("installVersionData: Expected table, got ".. type( rData )) else return false, "Invalid Version Data" end end
	local h = fs.open( apiCfg.versionPath, "r" )
	local update = false
	local lData
	if not h then update = true else
		lData = textutils.unserialize( h.readAll() )
		h.close()
		if not lData then
			fs.delete( api.versionPath ) --file corrupted, remove it
			os.reboot()
		end
		if lData.version ~= rData.version or lData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
	end

	if update then
		-- fetch update, install and change version file to new remote one passed in installVersionData()
		for i = 1, 3 do
			uPrint(false, "Fetching update files. Attempt ", i, " of 3")
			local response = http.get( apiCfg.updateUrl )
			if response then
				local h = fs.open( apiCfg.updatePath, "w" )
				h.write( response.readAll() )
				h.close()
				h = fs.open( apiCfg.versionPath, "w" )
				h.write( textutils.serialize( rData ) )
				h.close()
				uPrint(colors.lime, "Install complete, rebooting in one second")
				if not silent then
					sleep(1)
					os.reboot()
				else return true end
			end
		end
		uPrint(colors.red, "Could not fetch update data")
	end

	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
end

local function getVersion()
	local h = fs.open( apiCfg.versionPath, "r" )
	if not h then
		return { version = "Unknown", build = "Unknown" }
	end
	local cnt = h.readAll()
	h.close()
	if cnt then
		return textutils.unserialize( cnt )
	else
		return { version = "Unknown", build = "Unknown" }
	end
end

local function checkAndProceed()
	local go, data = getVersionData()
	if go and data then
		installVersionData( data )
	end
end

local function attemptInstall()
	local old = apiCfg.output
	apiCfg.output = false
	print("Missing Files! Attempting to fetch")

	local function printError( err )
		print("DynaCode is missing files, while trying to fetch them we encountered a problem: "..tostring( err ))
		sleep(5)
		return false
	end

	local go, data, confirm = getVersionData( true )
	if go and data and confirm then
		local success, err = installVersionData( data, true )
		if success then
			print("Finished fetching required files")
			sleep(1)
			os.reboot()
		else
			printError( err )
		end
	elseif not go and not confirm then
		printError( data )
	else
		print("No files are required")
	end
end

local h = fs.open( apiCfg.versionPath, "r" )
if h then
	local r = h.readAll()
	h.close()
	if not r then
		attemptInstall()
	elseif r then
		r = textutils.unserialize( r )
		if not r then
			attemptInstall()
		elseif r then
			_G._DYNACODE = r
		end
	end
else
	attemptInstall()
end
--[[
local function copy( tbl )
	if type( tbl ) == "table" then
		-- loop through table, copying keys
		local copy = {}
		for key, value in ipairs(tbl) do
			copy[key] = value
		end
		return copy
	else
		return tbl
	end
end]]

local function copy(obj)
  if type(obj) ~= 'table' then return obj end
  local res = {}
  for k, v in pairs(obj) do res[copy(k)] = copy(v) end
  return res
end

local function validateRequirements( needed, provided, silent, prefix, suffix )

	if type( needed ) ~= "table" or type( provided ) ~= "table" or ( type( silent ) ~= "nil" and type( silent ) ~= "boolean" ) or ( type( prefix ) ~= "nil" and type( prefix ) ~= "string" ) or ( type( suffix ) ~= "nil" and type( suffix ) ~= "string" ) then
		error("validateRequirements: Expected: table, table, boolean(optional), string(optional), string(optional), got: "..type( needed )..", "..type( provided )..", "..type(silent)..", "..type(prefix)..", "..type(suffix), 3)
	end

	-- Loop @provided, then check @needed for the key-value pair found in @provided. If its in their simply remove it.

	local result = copy( needed )

	local function compile( prefix, suffix )
		local msg = prefix or ""
		for k, v in ipairs(result) do
			msg = msg.."- "..tostring(v)
			if k < #result then msg = msg .. "\n" end
		end
		if suffix then msg = msg .. "\n " .. suffix end
		return msg
	end

	for opt in pairs( provided ) do
		for key, req in ipairs( result ) do
			if req == opt then
				table.remove( result, key )
			end
		end
	end

	-- If the length of result is > 0, then not all requirements have been met.

	if #result > 0 then
		if silent then
			return false, compile( prefix or "", suffix or "")
		else
			error( compile( prefix or "", suffix or "" ), 3)
		end
	else
		return true
	end
end

function createProgram( options )
	validateRequirements({ "name" }, options, false, "Missing requirements to initialize program:\n", "\nPlease define the above settings when creating your program instance")
	if not updateChecked and apiCfg.keepUpToDate then
		-- check for updates now
		checkAndProceed()
		updateChecked = true
	end

	local termX, termY = term.getSize()

	local defaults = { backgroundColor = colors.black, debug = true, debugWait = 0.5, debugPauseOnException = true, catchErrors = true, customErrorCB = false, restartTimer = 10 }

	local objects = { -- program registry
		scenes = {}, -- not drawn, just here to be accessed.
		stages = {}, -- drawn
		dialogs = {}, -- drawn last. Not zbased.
		buffer = {}
	}
	local programQueue = {}

	local filters = {
		{
			name = "NORMAL",
			tbl = {
				["white"] = colors.white,
				["orange"] = colors.orange,
				["magenta"] = colors.magenta,
				["lightBlue"] = colors.lightBlue,
				["yellow"] = colors.yellow,
				["lime"] = colors.lime,
				["pink"] = colors.pink,
				["gray"] = colors.gray,
				["lightGray"] = colors.lightGray,
				["cyan"] = colors.cyan,
				["purple"] = colors.purple,
				["blue"] = colors.blue,
				["brown"] = colors.brown,
				["green"] = colors.green,
				["red"] = colors.red,
				["black"] = colors.black
			}
		},
		{
			name = "_UNFOCUSED",
			tbl = {
				["white"] = colors.lightGray,
				["orange"] = colors.lightGray,
				["magenta"] = colors.lightGray,
				["lightBlue"] = colors.lightGray,
				["yellow"] = colors.gray,
				["lime"] = colors.lightGray,
				["pink"] = colors.lightGray,
				["gray"] = colors.gray,
				["lightGray"] = colors.lightGray,
				["cyan"] = colors.lightGray,
				["purple"] = colors.lightGray,
				["blue"] = colors.lightGray,
				["brown"] = colors.lightGray,
				["green"] = colors.lightGray,
				["red"] = colors.lightGray,
				["black"] = colors.gray
			}
		}
	}

	local clone = {}
	local program = {}
	setmetatable( options, {__index=defaults})
	setmetatable( program, {__index = options})

	local function log( msg, mode )
		if program.loggingReady and program.logging then
			local prefix = "Info"
			if mode == "w" then prefix = "Warn" elseif mode == "e" then prefix = "ERROR" end
			clone.file.append( program.loggingPath, "["..os.clock().."] ["..prefix.."] "..msg.."\n")
		end
		if program.debug then
			if mode == "w" or mode == "e" then term.setTextColor( colors.red ) end
			term.setBackgroundColor( colors.black )
			print( "DEBUG OUTPUT: "..tostring( msg ) )
			term.setTextColor( colors.white )
			if program.debugWait and ( mode == "i" or not mode ) then sleep( program.debugWait ) end
			if program.debugPauseOnException then
				if mode == "w" then
					print("Warning Caught - Press any key to continue")
					os.pullEventRaw("key")
				elseif mode == "e" then
					print("Exception Caught - Press any key to continue")
					os.pullEventRaw("key")
				end
			end
		end
	end

	local function filterGet( name )
		if not name then error("filterGet: Expected string to fetch filter") end
		for k, v in ipairs( filters ) do
			if v.name == name then return v end
		end
		return false
	end

	local function filterRemove( name )
		if not name then error("filterRemove: Expected string to remove filter") end
		for k, v in ipairs( filters ) do
			if v.name == name then
				table.remove( k, filters )
			end
		end
	end

	local function filterAdd( name, tbl )
		if not name or not tbl then
			error("filterAdd: Expected argument of type string and table")
		end
		table.insert( filters, {
			name = name,
			tbl = tbl or {}
		})
	end

	local function getColorFromFilter( filter, cl )
		if not filter or not cl then
			error("getColorFromFilter: Expected filter string and color string to fetch color from filter.", 3)
		end
		local r = filterGet( filter )
		local c
		if not r then
			log("getColorFromFilter: Filter not found in program instance: "..tostring(filter)..". Returning API color by default", "e")
			r = colors
			c = r[cl]
		else
			c = r.tbl[cl]
		end
		if not c then
			log("getColorFromFilter: Cannot find color ("..tostring(cl)..") in filter, returning WHITE", "w")
			return colors.white
		else
			return c
		end
	end

	function clone.setLoggingPath( v )
		program.loggingPath = v
	end
	function clone.getLoggingPath()
		return program.loggingPath
	end

	function clone.setLoggingEnabled( v )
		program.logging = v
	end
	function clone.getLoggingEnabled()
		return program.logging
	end

	function clone.logToFile( content, mode )
		log( content, mode )
	end

	function clone.initializeLogFile()
		if not program.logging or not program.loggingPath then
			error("Set logging and logging path before initializing", 2)
		end
		local h = fs.open( program.loggingPath, "w" )
		local ver = getVersion()
		if h then
			h.write("--@@@==== DynaCode Logging - Instance: "..program.name.." - ( Version: ".. ver.version .. " - Build: " .. ver.build .." ) ====@@@--\n")
			h.close()
			program.loggingReady = true
		end
	end

	local function registryFetch( nm )

		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					return v
				end
			end
		end
		return false
	end

	local function registryRemove( nm )
		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					table.remove( objects.stages, k )
				end
			end
		end
	end

	local function addBufferRequestToQueue( sStage, tBuffer, xStart, yStart, xEnd, yEnd )
		table.insert( programQueue, { stage = sStage, yStart = yStart, xStart = xStart, xEnd = xEnd, yEnd = yEnd } )
	end

	local function removeBufferRequestFromQueue( sStage )
		for key, request in ipairs( programQueue ) do
			if request.stage == sStage then table.remove( programQueue, key ) end
		end
	end

	local function createBuffer()
		for y = 1, termY do
			objects.buffer[y] = {}
			for x = 1, termX do
				objects.buffer[y][x] = { defined = false, char = " ", textColor = colors.white , backgroundColor = program.backgroundColor }
			end
		end
		log("Program buffer created")
	end
	createBuffer()

	local function processBufferQueue() -- doesn't clear queue. If a stage is removed from the queue the program can be redrawn to remove the stages from the screen.
		-- Merge all the requests together
		local merged, requests = {}, {}
		for y = 1, termY do
			merged[y] = {}
			for x = 1, termX do
				merged[y][x] = { defined = false, char = " ", textColor = colors.white, backgroundColor = colors.black }
			end
			-- create the Y template so the below function can index the merged table
		end
		requests = copy( programQueue )
		table.sort(requests, function( aX, bX )
			local a = registryFetch(aX.stage)
			local b = registryFetch(bX.stage)
			if not a then error(aX.stage.." must be built before running the queue") elseif not b then error(bX.stage.." must be built before running the queue") else
				return a.getBufferLevel() > b.getBufferLevel()
			end
		end)

		for key, r in ipairs( requests ) do
			local stage, buffer = registryFetch( r.stage ), false
			if stage then
				buffer = stage.getMerge()
			end
			-- get x, y, height and width.
			local sX, sY = stage.getPos()
			if buffer and type( buffer ) == "table" then
				for y = r.yStart, r.yEnd do
					for x = r.xStart, r.xEnd do
						merged[ y + sY - 1 ][ x + sX - 1 ] = buffer[y][x] -- get the stages new buffer each time.
						merged[ y + sY - 1 ][ x + sX - 1 ].defined = true
					end
				end
			end
		end
		return merged
	end

	local function drawMerge( tMerged )
		-- compare each entry in here to the old buffer. Only redraw if changed.
		-- Draw the table passed (should be size of entire terminal)

		local oBuffer = copy( objects.buffer )
		local otc, obg = colors.white, colors.white
		for y = 1, termY do
			for x = 1, termX do
				local redraw = false
				if oBuffer[y][x].defined and not tMerged[y][x].defined then
					-- a pixel is no longer in use, clear it back to default.
					redraw = true
				end
				if tMerged[y][x].char ~= oBuffer[y][x].char or tMerged[y][x].textColor ~= oBuffer[y][x].textColor or tMerged[y][x].backgroundColor ~= oBuffer[y][x].backgroundColor then
					term.setCursorPos( x, y )
					if otc ~= tMerged[y][x].textColor then term.setTextColor( tMerged[y][x].textColor ) otc = tMerged[y][x].textColor end --only change if required.
					if obg ~= tMerged[y][x].backgroundColor then term.setBackgroundColor( tMerged[y][x].backgroundColor ) obg = tMerged[y][x].backgroundColor end
					term.write( tMerged[y][x].char )
					oBuffer[y][x] = tMerged[y][x]
				end
			end
		end
		objects.buffer = oBuffer
	end

	local function drawAll()
		drawMerge( processBufferQueue() )
	end

	local function reorderBufferLevels( sTop )

		local stages = copy( objects.stages )
		local start = 1
		for key, stage in pairs( stages ) do
			if stage.getName() == sTop then stage:setBufferLevel(1) start = 2 end
		end
		table.sort(stages, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)

		for key, stage in ipairs( stages ) do
			if stage.getName() ~= sTop then
				stage:setBufferLevel(start)
				start = start + 1
			end
		end
		drawMerge( processBufferQueue() )

	end

	local function getHighestLevel( nX, nY )
		local stages = copy( objects.stages )
		table.sort(stages, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)

		for i = #stages, 1, -1 do
			local sX, sY = stages[i].getPos()
			if stages[i].getBorderless() then offset = 0 else offset = 1 end
			if nX >= sX and nX <= sX + stages[i].getWidth() and nY >= sY and nY <= sY + stages[i].getHeight() - offset then
				return stages[i]
			end
		end
	end

	function clone.setDebug( v )
		program.debug = v
	end

	function clone.setDebugSleep( v ) program.debugWait = v end

	function clone.setDebugPauseOnException( v ) program.debugPauseOnException = v end

	function clone.createStage( cfg )
		local stageDefaults = {
			bufferLevel = 1,
			active = false,
			x = 2,
			y = 2,
			width = 12,
			height = 5,
			backgroundColor = "white",
			lastClickX = 2,
			lastClickY = 2,
			closeButton = true,
			closeButtonColor = "red",
			closeButtonTextColor = "white",
			topBarColor = "gray",
			topBarDisabledColor = "lightGray",
			filter = "NORMAL",
			moveable = true,
			fullscreen = false,
			eventWhitelist = {},
			eventBlacklist = {}
		} -- manual settings will override these
		local window, windowBuffer, new, settings, cache, cacheDefaults, stageCanvas = {}, {}, {}, {}, {}, { needsRedraw = false }, {}
		setmetatable( stageDefaults, {__index = defaults})
		setmetatable( cfg, {__index = stageDefaults} )
		setmetatable( settings, {__index=cfg} )
		setmetatable( cache, {__index=cacheDefaults})

		local bufferDefaults = {
			cursorBlink = false, 
			backgroundColor = settings.backgroundColor, 
			textColor = colors.white, 
			cX = 1, 
			cY = 1
		}
		setmetatable( windowBuffer, {__index=bufferDefaults})
		setmetatable( stageCanvas, {__index=bufferDefaults})


		local function registryUpdate( self )
			for k, v in ipairs( objects.stages ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.stages, k )
					end
				end
			end

			table.insert( objects.stages, self )
		end

		local function getColor( cl )
			local filter
			if settings.active then
				filter = filterGet( settings.filter )
			else
				filter = filterGet( "_UNFOCUSED" )
			end
			if not filter then
				log("Cannot find filter: "..tostring(settings.filter).." for stage: "..settings.name, w)
			else
				local c = filter.tbl[cl]
				if c then
					return c
				end
			end
			return colors[cl] or cl or colors.white
		end

		-- create the terminal
		local canvas = {}
		for functionName, functionObject in pairs( term.native() ) do
			canvas[functionName] = functionObject
		end

		function canvas.write( text )
			if stageCanvas.cX < 1 or 
				stageCanvas.cX > 1 + settings.width or 
				stageCanvas.cY < 1 or 
				stageCanvas.cY > settings.height then
				return ""
			end
			oTerm.setCursorPos( stageCanvas.cX + settings.x - 1, stageCanvas.cY + settings.y + 1 )
			for charIndex = 1, text:len() do
				if not stageCanvas[stageCanvas.cY] then error("Yaxis does not extend upto "..stageCanvas.cY) end
				if not stageCanvas[stageCanvas.cY][stageCanvas.cX] then error("Xaxis does not extend upto "..stageCanvas.cX) end
				stageCanvas[stageCanvas.cY][stageCanvas.cX].char = text:sub(charIndex, charIndex)
				stageCanvas[stageCanvas.cY][stageCanvas.cX].textColor = getColor( stageCanvas.textColor )
				stageCanvas[stageCanvas.cY][stageCanvas.cX].backgroundColor = getColor( stageCanvas.backgroundColor )
				stageCanvas.cX = stageCanvas.cX + 1
				if stageCanvas.cX > settings.width then
					break
				end
	        end
			--return oTerm.write(text)
		end

		function canvas.setTextColor( color )
			stageCanvas.textColor = color
		end

		function canvas.setBackgroundColor( color, name )
			stageCanvas.backgroundColor = color
		end

		function canvas.setCursorPos( nX, nY )
			stageCanvas.cX, stageCanvas.cY = nX, nY
			oTerm.setCursorPos( nX, nY )
		end

		local function draw()
			term.redirect( canvas )
			local oX, oY = term.getCursorPos()
			local emptyString = (" "):rep(settings.width)

			local startY, endY = 1, settings.height

			term.setBackgroundColor( getColor( settings.backgroundColor ) )
			term.setTextColor( getColor( settings.textColor ) )
			local bg, tc = true, true
			for y = startY, endY do
				-- if not borderless and top Y, draw topBar.
				if y == startY and not settings.borderless then
					term.setBackgroundColor( getColor( settings.topBarColor ) )
					bg = false
				else
					if not bg then
						term.setBackgroundColor( getColor( settings.backgroundColor ) )
						bg = true
					end
					if not tc then term.setTextColor( getColor( settings.textColor ) ) tc = true end
				end
				term.setCursorPos(1, y)
				term.write(emptyString) -- actually draw the empty lines to make sure the pixels are recognized as this stages.
				if y == startY and settings.title then
					-- draw title
					local str, offset = settings.title, (function() if settings.closeButton then return 1 else return 0 end end)()
					if #settings.title >= settings.width - offset then
						-- title too big
						local overflow = #settings.title - ( settings.width - offset )
						if overflow == 0 then
							-- replace last char with "."
							str = settings.title:sub(1, #settings.title-1-offset) .. "."
						else
							str = settings.title:sub(1, #settings.title-overflow-1-offset) .. ("."):rep(overflow+1)
						end
					end
					term.setCursorPos( 1, 1 )
					term.write( str )
				end
				-- draw main window
				-- if y is start and closeButton, draw button
				if y == startY and settings.closeButton then
					term.setBackgroundColor( getColorFromFilter( settings.filter, settings.closeButtonColor) )
					term.setTextColor( getColorFromFilter( settings.filter, settings.closeButtonTextColor) )
					term.setCursorPos( settings.width , 1 )
					term.write("X")
					bg, tc = false, false
				end
			end
			term.setCursorPos( oX, oY )
			term.setBackgroundColor( program.backgroundColor )
			term.redirect( oTerm )
		end

		local function close()
			registryRemove( settings.name )
			removeBufferRequestFromQueue( settings.name )
			drawAll()
		end

		local function focus()
			-- set all other stages to active = false.
			settings.active = true
			reorderBufferLevels( settings.name )
		end

		local function blur()
			-- set all other stages to active = false.
			settings.active = false
		end

		-- Terminal Integration and coroutines
		local runningProgram, pgPath, redirect = false, false, {}
		setmetatable( new, {__index=redirect}) -- allows redirect methods to be used like <stage>.[termMethod](...)
		function new.getRunningProgram() return runningProgram end
		function new.getTerm() return redirect end

		local function updateCursorBlink()
			oTerm.setCursorBlink( windowBuffer.cursorBlink )
		end

		local function updateCursorPos()
			local offset = ( function() if settings.borderless then return 1 else return 0 end end)()
			oTerm.setCursorPos( settings.x + windowBuffer.cX - 1, settings.y + windowBuffer.cY - offset )
		end

		local function redirectDraw()
			local offset = ( function() if settings.borderless then return 1 else return 0 end end)()
			oTerm.setCursorBlink( false )
			for line = 1, settings.height do
				for char = 1, settings.width do
					local letter = windowBuffer[line][char]
					if letter.char ~= " " then -- ignore the text if its blank (unedited or reset)
						oTerm.setBackgroundColor( letter.backgroundColor )
						oTerm.setTextColor( letter.textColor )
						oTerm.setCursorPos( settings.x + char - 1, settings.y + line - offset )
						oTerm.write( letter.char )
					end
				end
			end
			oTerm.setBackgroundColor( program.backgroundColor )
			oTerm.setCursorPos( windowBuffer.cX + settings.x - 1, windowBuffer.cY + settings.y - offset ) -- reset cursor position to the windows cursorX
			updateCursorBlink()
		end

		local function setupBuffer( table )
			-- create buffer table
			local lastX, lastY = 1, 1
			for height = 1, settings.height + 1 do
				table[height] = ( function( height ) if table[height] then return table[height] else return {} end end )( height )
				lastY = height
				for width = 1, settings.width + 1 do
					table[height][width] = ( function( height, width ) if table[height][width] then return table[height][width] else return {char = " ", textColor = getColor( table.textColor), backgroundColor = getColor( table.backgroundColor ) } end end )( height, width )
					lastX = width
				end
				-- if any remain, remove them
				for width = lastX, #table[height] do
					table[height][width] = nil
				end
			end
			-- remove old buffer items.
			for height = lastY, #table do
				table[height] = nil
				-- if the height has been shrunk, then remove the excess tables
			end
			-- A window buffer has now been created with a table for each Y-Axis containing another table for each X-Axis.
		end
		setupBuffer(windowBuffer)
		setupBuffer(stageCanvas)

		local function mergeBuffers()
			-- merge the nodes buffer and redirect buffer
			-- TO-DO: Node buffer
			draw() -- redraw the stages internal buffer for use by the programs main buffer
			return stageCanvas
		end

		local function queueRedraw()
			-- order the programQueue to redraw this stage.
			-- if the top bar is active.
			removeBufferRequestFromQueue( settings.name )
			addBufferRequestToQueue( settings.name, mergeBuffers(), 1, 1, settings.width, settings.height )
		end
		--[[
			When the main event manager catches an event, it first checks if the event can be passed to the window using the eventFilter (if window is not active then only events inside the
			filter will be passed to the coroutine). If the event can be passed, the term will be redirected to the new stage term object and resumed.

			Any term calls will be redirected here where they can be buffered and drawn respectively.

			After the coroutine yields, other stages will get their coroutines checked and run if required, then term will be redirected to oTerm (original term).
		]]

		function redirect.isColor() return oTerm.isColor() end
		redirect.isColour = redirect.isColor

		function redirect.write( sString )
			oTerm.setCursorPos( windowBuffer.cX + settings.x - 1, windowBuffer.cY + settings.y - ( function() if settings.borderless then return 1 else return 0 end end)() ) -- cX and cY are cursor positions relative to the window, not the terminal. Make up for this my adding their position.
			if windowBuffer.cX < 1 or windowBuffer.cX > settings.width or windowBuffer.cY < 1 or windowBuffer.cY > settings.height then
				--return oTerm.write(sString)
				return ""
			end

			for charIndex = 1, sString:len() do
				windowBuffer[windowBuffer.cY][windowBuffer.cX].text = sString:sub(charIndex, charIndex)
				windowBuffer[windowBuffer.cY][windowBuffer.cX].textColor = getColor( windowBuffer.textColor )
				windowBuffer[windowBuffer.cY][windowBuffer.cX].backgroundColor = getColor( windowBuffer.backgroundColor )
				windowBuffer.cX = windowBuffer.cX + 1

				if windowBuffer.cX > settings.width then
					--windowBuffer.cY = windowBuffer.cY + 1
					break
				end
			end
			oTerm.setBackgroundColor( getColor( windowBuffer.backgroundColor ) )
			oTerm.setTextColor( getColor( windowBuffer.textColor ) )
			local r = oTerm.write(sString)
			oTerm.setBackgroundColor( program.backgroundColor )
			oTerm.setTextColor( colors.white )
			return r
		end
		function redirect.blit( sString, sBackground, sTextColor ) end

		function redirect.clear() end
		function redirect.clearLine() end

		function redirect.getCursorPos() return windowBuffer.cX, windowBuffer.cY end
		function redirect.setCursorPos( nX, nY ) windowBuffer.cX, windowBuffer.cY = tonumber( nX ), tonumber( nY ) updateCursorPos() end

		function redirect.setCursorBlink( bBlink ) windowBuffer.cursorBlink = bBlink updateCursorBlink() end
		function redirect.getCursorBlink() return windowBuffer.cursorBlink end

		function redirect.setTextColor( sColor ) windowBuffer.textColor = sColor end
		redirect.setTextColour = redirect.setTextColor

		function redirect.setBackgroundColor( sColor ) windowBuffer.backgroundColor = sColor end
		redirect.setBackgroundColour = redirect.setBackgroundColor

		function redirect.getBackgroundColor() return windowBuffer.backgroundColor end
		redirect.getBackgroundColour = redirect.getBackgroundColor

		function redirect.getTextColor() return windowBuffer.textColor end
		redirect.getTextColour = redirect.getTextColor

		function redirect.scroll( n )

		end

		function redirect.setVisible( bVisible ) settings.visible = bVisible end
		function redirect.getVisible() return settings.visible end

		function redirect.redraw() redirectDraw() end

		function redirect.restoreCursor() end

		function redirect.getPosition() return settings.x, settings.y end
		function redirect.reposition() end

		function redirect.getSize() return settings.width, settings.height end
		

		local function removeFromEventWhitelist( v )
			for key, event in ipairs( settings.eventWhitelist ) do
				if event == v then
					table.remove( settings.eventWhitelist, key )
				end
			end
		end
		function new.removeFromEventWhitelist( v ) removeFromEventWhitelist( v ) end
		
		local function addToEventWhitelist( v )
			removeFromEventWhitelist( v )
			table.insert( settings.eventWhitelist, v )
		end
		function new.addToEventWhitelist( v ) addToEventWhitelist( v ) end

		local function setEventWhitelist( v )
			settings.eventWhitelist = v
		end
		function new.setEventWhitelist( v ) setEventWhitelist( v ) end

		local function getEventWhitelist()
			return settings.eventWhitelist
		end
		function new.getEventWhitelist() return getEventWhitelist() end

		-- Above event filter methods for whitelist
		
		local function removeFromEventBlacklist( v )
			for key, event in ipairs( settings.eventBlacklist ) do
				if event == v then
					table.remove( settings.eventBlacklist, key )
				end
			end
		end
		function new.removeFromEventBlacklist( v ) removeFromEventBlacklist( v ) end
		
		local function addToEventBlacklist( v )
			removeFromEventBlacklist( v )
			table.insert( settings.eventBlacklist, v )
		end
		function new.addToEventBlacklist( v ) addToEventBlacklist( v ) end

		local function getEventBlacklist()
			return settings.eventBlacklist
		end
		function new.getEventBlacklist() return getEventBlacklist() end


		local function setEventBlacklist( v )
			settings.eventBlacklist = v
		end
		function new.setEventBlacklist( v )
			setEventBlacklist( v )
		end

		local function wrapProgram( path )
			if runningProgram and coroutine.status( runningProgram ) == "suspended" then
				error("wrapProgram: Program already running on stage", 2)
			end
			if not path or type( path ) ~= "string" then
				error("wrapProgram: Expected: path String")
			end
			local func = false
			if getfenv and setfenv and type( getfenv ) == "function" and type( setfenv ) == "function" then
				local result, err = loadfile( path )
				if not result then
					if err then
						error("wrapProgram: "..tostring( err ))
					else
						error("wrapProgram: Error while loading file.")
					end
				elseif result then
					func = result
					--setfenv( func, sandbox )
				end
				if func then
					runningProgram = coroutine.create(function()
						func()
					end)
					pgPath = path
				else
					error("wrapProgram: Could not load file")
				end
			end
		end

		function new.getMerge()
			return mergeBuffers()
		end

		function new.runProgram( path )
			wrapProgram( path )
		end
		local messageCrashed, messageClosed = false, false
		function new.threadCrash( err )
			messageCrashed = coroutine.create(function() -- we use a coroutine so we can still multi task in other windows, if we used a function here the pullEvent would demand all attention 
				term.setTextColor( colors.red )
				print("Thread Crashed: "..err)
				term.setTextColor( colors.white )
				print("Press any key to continue")
				os.pullEventRaw("key")
				restore()
				close()
			end)
		end

		function new.getAlternate()
			return messageCrashed or messageClosed
		end

		function new.threadClosed()
			messageClosed = coroutine.create(function()
				term.setTextColor( colors.white )
				print("Program finished\nPress any key to continue")
				os.pullEventRaw("key")
				restore()
				close()
			end)
		end

		function new.setCloseCallback( self, callback )
			if not self or not ( type( self ) == "table" and self.getType and self.getType() == "stage" ) or not callback then
				error("Expected table SELF of type stage and callback function")
			end
			if self.getName() ~= settings.name then
				error("Passed self does not match this stage")
			end
			settings.onCloseCB = callback
		end

		-- add this stage to the object storage.

		function new.draw( self )
			if not registryFetch( settings.name ) then error("Stage must be built before drawing") end
			draw()
		end

		function new.setColorFilter( filterName )
			settings.filter = filterName
		end

		function new.getType() return "stage" end

		function new.getActive() return settings.active end

		function new.setBufferLevel( self, v )
			settings.bufferLevel = v
		end
		function new.getBufferLevel( self )
			return settings.bufferLevel
		end

		function new.getPos( self ) return settings.x, settings.y end 

		function new.setPos( nX, nY ) settings.x, settings.y = nX, nY end

		function new.getWidth() return settings.width end
		function new.getHeight() return settings.height end

		function new.setBorderless( self, v ) 
			settings.borderless = v
		end
		function new.getBorderless( self ) 
			return settings.borderless
		end

		function new.setCloseButton( self, v ) 
			settings.closeButton = v
		end
		function new.getCloseButton( self ) 
			return setting.closeButton
		end

		function new.getFullscreen( self ) 
			return settings.fullscreen 
		end
		function new.setFullscreen( self, v ) 
			settings.fullscreen = v 
		end

		function new.setMoveable( self, v ) 
			settings.moveable = v
		end
		function new.getMoveable( self ) 
			return settings.moveable
		end

		function new.setBorderBackgroundColor( self, v ) 
			settings.borderBackgroundColor = v
		end
		function new.getBorderBackgroundColor( self ) 
			return settings.borderBackgroundColor
		end

		function new.setBorderTextColor( self, v ) 
			settings.borderTextColor = v
		end
		function new.getBorderTextColor( self ) 
			return settings.borderTextColor
		end

		function new.setBorderCloseBackgroundColor( self, v ) 
			settings.borderCloseBackgroundColor = v
		end
		function new.getBorderCloseBackgroundColor( self ) 
			return settings.borderCloseBackgroundColor
		end

		function new.setBorderCloseTextColor( self, v ) 
			settings.borderCloseTextColor = v
		end
		function new.getBorderCloseTextColor( self ) 
			return settings.borderCloseTextColor
		end

		function new.setBorderCloseText( self, v ) 
			settings.borderCloseText = v
		end
		function new.getBorderCloseText( self ) 
			return settings.borderCloseText
		end

		function new.setTitle( self, v ) 
			settings.title = v
		end
		function new.getTitle( self ) 
			return settings.title
		end

		function new.setTitleOverflow( self, v ) 
			settings.titleOverflow = v
		end
		function new.getTitleOverflow( self ) 
			return settings.titleOverflow
		end

		function new.setTitleCenter( self, v )
			setting.titleCenter = v
		end
		function new.getTitleCenter( self )
			return settings.titleCenter
		end

		function new.setFocus( self, v ) 
			if v then focus() else blur() end
		end
		function new.getFocus( self ) 
			return settings.isActive
		end

		function new.getName( self )
			return settings.name
		end

		function new.getFromRegistry( self )
			return registryFetch( self:getName() )
		end

		function new.updateToRegistry( self )
			registryUpdate( self )
		end

		function new.removeFromRegistry( self )
			registryRemove( self:getName() )
		end

		function new.setScene( self, v )
			settings.scene = v
		end

		function new.getScene( self )
			return settings.scene
		end

		local function handleMouseClick( self, event, button, nX, nY )
			-- handle mouse click, check nodes and stage topBars.
			settings.lastClickX, settings.lastClickY = nX, nY
			if button == 1 and nX > settings.x and nX < settings.x + settings.width and nY == settings.y then
				-- click on top bar
				if nX == settings.x + settings.width - 1 and settings.closeButton then close() else log("no") end
			end
		end

		local function handleMouseScroll()
			
		end

		local function handleMouseDrag( self, event, button, nX, nY )
			-- attempt to move the window. If a move is required, clear the area that the stage is currently in, then move it and queue a redraw.
			-- nX, nY new drag position, settings.lastClickX and lastClickY are fired every mouse click and drag. These can be used to compare.
			-- if the last click was on the top bar, then allow drag.
			if settings.lastClickX >= settings.x and settings.lastClickX <= settings.x + settings.width and settings.lastClickY == settings.y and settings.moveable and settings.active then
				local oX, oY = settings.x, settings.y
				local oldX, oldY = settings.lastClickX, settings.lastClickY
				if nX < settings.lastClickX and settings.x - 1 > 0 then
					settings.x = settings.x - 1
				elseif nX > settings.lastClickX and settings.x + settings.width < termX then
					settings.x = settings.x + 1
				elseif nY < settings.lastClickY and settings.y - 1 > 0 then
					settings.y = settings.y - 1
				elseif nY > settings.lastClickY and nY + settings.height < termY then
					settings.y = settings.y + 1
				end
				if settings.y ~= oldY or settings.x ~= oldX then
					drawAll()
				end
				settings.lastClickX, settings.lastClickY = nX, nY
			end
		end

		local function handleKeyPress()

		end

		local function handleCharPress()

		end

		function new.runEvent( self, e, p1, p2, p3, p4 )
			if settings.active then
				if e == "mouse_click" then
					handleMouseClick( self, e, p1, p2, p3 )
				elseif e == "mouse_scroll" then
					handleMouseScroll( self, e, p1, p2, p3 )
				elseif e == "mouse_drag" then
					handleMouseDrag( self, e, p1, p2, p3 )
				elseif e == "key" then
					handleKeyPress( self, e, p1, p2 )
				elseif e == "char" then
					handleCharPress( self, e, p1 )
				elseif e == "terminate" and settings.allowTerminate then
					registryRemove( settings.name )
					removeBufferRequestFromQueue( settings.name )
					drawAll()
				end
			end
			-- if its not active, and the event was a mouse click, check if in bounds. If it isn't clicked on deactivate it, if it is activate it.
			if e == "mouse_click" and registryFetch(settings.name) then
				local high = getHighestLevel( p2, p3 )
				if p2 >= settings.x and p2 <= settings.x + settings.width - 1 and p3 >= settings.y and p3 <= settings.y + settings.height - 1 and not settings.active then
					-- if the window is the highest level.
					if high and high.getName() == settings.name then
						focus()
					end
				elseif not high or high.getName() ~= settings.name and settings.active then
					blur()
				end
			end
		end

		function new.destroy( self )
			-- if stage is in registry remove it, also stop loop
			registryRemove( settings.name )
			removeBufferRequestFromQueue( settings.name )
		end

		function new.build( self )
			-- add stage to registry
			registryUpdate( self )
			queueRedraw()
		end
		if settings.visible then queueRedraw() end
		log("New stage created: "..settings.name)
		return new

	end

	clone.createScene = function( cfg )
		local sceneDefault = {}
		local new = {}
		local settings = {
			nodes = {}
		}

		-- The scene is attached to a stage. The scene _can_ be used on multiple stages.

		-- If the scene is fetched from a stage, and changed it will affect all stages using the scene.

		-- If the scene is changed from a local variable, and changed it will also affect all stages using this scene.

		setmetatable( sceneDefault, {__index=defaults})
		setmetatable( cfg, {__index=sceneDefault})
		setmetatable( settings, {__index = cfg})


		local function registryUpdate( self )
			for k, v in ipairs( objects.scenes ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.scenes, k )
					end
				end
			end

			table.insert( objects.scenes, self )
		end

		function new.getType() return "scene" end

		function new.getName() return settings.name end

		function new.relaceWithFile( self )

		end
		function new.appendFromFile( self )

		end

		function new.addNode( self, v )

		end
		function new.removeNode( self )

		end
		function new.clearNodes( self )
			settings.nodes = {}
			-- redraw window
		end
		function new.getNodes( self )
			return settings.nodes
		end

		function new.getFromRegistry( self )
			return registryFetch( self:getName() )
		end
		function new.updateToRegistry( self )
			registryUpdate( self )
		end
		function new.removeFromRegistry( self )
			registryRemove( self:getName() )
		end

		function new.setExample( self, v )
			settings.ex = v
		end
		function new.getExample( self )
			return settings.ex
		end

		registryUpdate( new )

		return new

	end

	clone.createButton = function( cfg )
		local buttonDefaults = {}
		local settings = {}
		local new = {}

		setmetatable( buttonDefaults, {__index = defaults})
		setmetatable( cfg, {__index = buttonDefaults})
		setmetatable( settings, {__index = cfg})


		function new.setBackgroundColor( self, v ) 
			settings.backgroundColor = v
		end
		function new.getBackgroundColor( self ) 
			return settings.backgroundColor
		end

		function new.setText( self, v ) 
			settings.text = v
		end
		function new.getText( self ) 
			return settings.text
		end

		function new.setTextColor( self, v ) 
			settings.textColor = v
		end
		function new.getTextColor( self ) 
			return settings.textColor
		end

		function new.setCanBeToggled( self, v ) 
			settings.canBeToggled = v
		end
		function new.getCanBeToggled( self ) 
			return settings.canBeToggled
		end

		function new.setToggledBackgroundColor( self, v ) 
			settings.toggledBackgroundColor = v
		end
		function new.getToggledBackgroundColor( self ) 
			return settings.toggledBackgroundColor
		end

		function new.setToggledText( self, v ) 
			settings.toggledText = v
		end
		function new.getToggledText( self ) 
			return settings.toggledText
		end

		function new.setMaxwidth( self, v ) 
			settings.maxWidth = v
		end
		function new.getMaxwidth( self ) 
			return settings.maxWidth
		end

		function new.setHeight( self, v ) 
			settings.height = v
		end
		function new.getHeight( self ) 
			return settings.height
		end

		function new.setToggledTextColor( self, v ) 
			settings.toggledTextColor = v
		end
		function new.getToggledTextColor( self ) 
			return settings.toggledTextColor
		end

		function new.setX( self, v ) 
			settings.x = v
		end
		function new.getX( self ) 
			return settings.x
		end

		function new.setY( self, v ) 
			settings.y = v
		end
		function new.getY( self ) 
			return settings.y
		end


		-- A node is not added to its own registry. It is added to the scenes node dictionary.

		-- Any changes made to the node via local variable, scene get or stage-scene fetch will be reflected across all scenes using this button.
		return new


	end
	clone.createParagraph = function() end
	clone.createScroll = function() end
	clone.createList = function() end

	clone.getStageFromRegistry = function( name ) -- returns stage from registry. (stage:updateToRegistry())
		return registryFetch( name )
	end

	local function begin( callback )
		local activeEvent = {
			"rednet_message",
			"modem_message",
			"alarm",
			"timer",
			"redstone"
		} -- events that are sent when the stage is not active.
		local tFilter, tMessages = {}, {} --stores filters for coroutines.
		local function filterEvent( event, stage )
			-- if the stage has a coroutine filter, check if its in there
			if tFilter[stage.getName()] == event or not tFilter[stage.getName()] or tFilter[stage.getName()] == "" then
				tFilter[stage.getName()] = nil
				-- check if the event is in the stages blacklist.
				for key, e in ipairs( stage.getEventBlacklist() ) do
					if e == event then return false end
				end
				-- if stage is active, return true.
				if stage.getActive() then return true end
				-- check if the event is in the stages whitelist (stage is not active).
				for key, e in ipairs( stage.getEventWhitelist() ) do
					if e == event then return true end
				end
			end
		end
		local function exeOnEach( e, p1, p2, p3, p4 )
			local re = false
			for _, stage in ipairs( objects.stages ) do
				if stage:runEvent( e, p1, p2, p3, p4 ) then re = true end
				if stage.getActive() and registryFetch(stage.getName()) then stage.draw() end
				term.redirect( stage.getTerm() )
				-- check if a message coroutine is active
				local messageCo, pgCo = stage.getAlternate(), stage.getRunningProgram()
				if messageCo and type( messageCo ) == "thread" and coroutine.status( messageCo ) == "suspended" and ( tMessages[stage.getName()] == e or tMessages[stage.getName()] == nil ) then
					-- send event to the message (threadClosed or crashed).
					local ok, param = coroutine.resume( messageCo, e, p1, p2, p3, p4 )
					log( tostring( ok ) .. ", " .. tostring( param ) )
					if coroutine.status( messageCo ) == "dead" and ok then
						-- finished
					elseif not ok then
						-- crashed
					elseif ok then
						-- set filter
						tMessages[stage.getName()] = param
					end
				elseif pgCo and type( pgCo ) == "thread" and coroutine.status( pgCo ) == "suspended" and filterEvent( e, stage ) then
					-- send event to runningProgram, check its status afterwards to determine if the program finished or crashed.
					local ok, param = coroutine.resume( pgCo, e, p1, p2, p3, p4 )
					if ok and coroutine.status( pgCo ) == "dead" then
						-- finished, reset the filter
						tFilter[stage.getName()] = nil
						stage.threadClosed()
					elseif not ok then
						-- crashed, reset the filter for this coroutine
						tFilter[stage.getName()] = nil
						stage.threadCrash( param )
					elseif ok and param then
						-- store the filter
						tFilter[stage.getName()] = param
					end
				end
				if stage.getActive() and registryFetch(stage.getName()) then stage.redraw() end
				term.redirect( oTerm )
			end
			
			if #objects.stages <= 0 then
				log("Cannot continue windows loop, all stages closed.", "w")
				return "stop"
			end
			drawAll()
		end
		local function loop()
			while true do
				local e, p1, p2, p3, p4 = os.pullEventRaw()
				if e == "program_stop"..program.name then
					break
				else
					if exeOnEach( e, p1, p2, p3, p4 ) == "stop" then break end
				end
				drawAll()
			end
		end
		log("Starting Windows", "w")
		-- Draw every stage
		drawAll()
		if callback and type( callback ) == "function" then
			parallel.waitForAll( loop, callback )
		else
			loop()
		end
	end

	clone.setErrorCallback = function( cb )
		program.customErrorCB = cb
	end

	clone.getErrorCallback = function()
		return program.customErrorCB
	end

	clone.getCatchErrors = function()
		return program.catchErrors
	end

	clone.setCatchErrors = function( v )
		program.catchErrors = v
	end

	clone.startWindows = function( callback )
		local function cPrint( text, y, color )
			if color then term.setTextColor( color ) end
			term.setCursorPos( math.ceil( termX/2-(#text/2) ), y )
			term.clearLine()
			write( text )
		end
		-- starts each windows event loop.
		-- When a stage is destroyed, it will be stopped and must be "rebuilt" in order to function again.
		if program.catchErrors then
			local ok, err = pcall(function() begin( callback ) restore() end)
			if err or not ok then
				log( tostring( err ), "e" )
				restore()
				if program.customErrorCB and type( program.customErrorCB ) == "function" then
					program.customErrorCB( ok, err )
				else
					term.setBackgroundColor( colors.gray )
					term.clear()
					cPrint("DynaCode Version 3 - Exception Caught", 4, colors.orange)
					cPrint("A fatal exception occurred which", 6, colors.lightGray)
					cPrint("has prevented DynaCode from continuing.", 7, colors.lightGray)
					cPrint(tostring( err ), 9, colors.orange)
					cPrint("Please report this error on the forum", 12, colors.lightGray)
					cPrint("following the guidelines on the page.", 13)
					cPrint("Press 'shift' to pause reboot timer", 15, colors.lightGray)
					cPrint("any other key to reboot", 16, colors.lightGray)
					local isTimer, timer, vTimer = true, os.startTimer( 1 ), program.restartTimer or 10
					cPrint("Rebooting in "..vTimer, termY, colors.lightGray)

					local function rTimer()
						vTimer = vTimer - 1
						if vTimer <= 0 then
							os.reboot()
						else
							timer = os.startTimer( 1 )
						end
						cPrint("Rebooting in "..vTimer, termY, colors.lightGray)
					end

					while true do
						local e, p1 = os.pullEventRaw()
						if e == "timer" and p1 == timer and program.restartTimer and isTimer then
							rTimer()
						elseif e == "key" then
							if p1 == keys.leftShift or p1 == keys.rightShift then
								if isTimer then
									isTimer = false
									cPrint("Paused reboot timer", termY, colors.orange)
								elseif not isTimer then
									isTimer = true
									timer = os.startTimer( 1 )
									cPrint("Rebooting in "..vTimer, termY, colors.lightGray)
								end
							else os.reboot() end
						end
					end

				end
			end
		else
			begin()
		end
		restore()
	end

	clone.getObjects = function() return objects end

	clone.file = {
		getHandle = function( path, mode )
			if fs.exists( path ) then
				return fs.open( path, mode or "r" )
			else
				return false
			end
		end,
		write = function( path, content )
			local h = fs.open( path, "w" )
			h.write( content )
			h.close()
			return true
		end,
		append = function( path, content )
			local h = clone.file.getHandle( path, "a" )
			if h then
				h.write( content )
				h.close()
				return true
			else
				return false
			end
		end,
		writeLine = function( path, content )
			local h = fs.open( path, "r" )
			h.writeLine( content )
			h.close()
			return true
		end,
		getLine = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readLine()
				h.close()
				return cnt
			else
				return false
			end
		end,
		getAll = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readAll()
				h.close()
				return cnt
			else
				return false
			end
		end
	}

	clone.createFilter = function( name, tbl ) filterAdd( name, tbl ) end

	clone.getFilterObject = function( name )
		return filterGet( name )
	end

	clone.getColorFromFilter = function( filter, cl )
		return getColorFromFilter( filter, cl )
	end

	clone.canvas = {
		drawArea = function( nX, nY, width, height, background )
			if height < 1 or width < 1 then
				error("Height and width must be greater than 1 to draw a box")
			end
			for i = nY, nY + height do
				clone.canvas.drawHLine( nX, i, width, background )
			end
		end,
		drawHLine = function( nX, nY, width, background )
			paintutils.drawLine( nX, nY, nX+width, nY, background )
		end,
		drawVLine = function( nX, nY, height, background )
			paintutils.drawLine( nX, nY, nX, nY+height, background )
		end,
		drawText = function() end,
		drawCText = function() end
	}

	clone.remote = {
		fetch = function( url )
			for i = 1, 3 do
				local response = http.get( url )
				if response then
					return response
				end
			end
			return false
		end,
		fetchLine = function( url )
			local response = clone.remote.fetch( url )
			if not response then return false else return response.readLine() end
		end,
		fetchAll = function( url )
			local response = clone.remote.fetch( url )
			if not response then return false else return response.readAll() end
		end
	}

	return clone

end