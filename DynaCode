--[[
    DynaCode
    Inspired by JavaFX.

    This is the framework developed by Harry Felton for use in all modern HexCode programs.

    Copyright (c) 2015 Harry Felton, HexCode and all other contributors
]]

local termX, termY = term.getSize()
local oTerm = term.current()

local function restore()
    term.redirect( oTerm )
end

local apiCfg = {
    keepUpToDate = true, -- Check for updates the first time a program is created using this version of the API. (.createProgram())
    updatePath = "DynaCode", -- Where is the API installed
    updateUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/DynaCode", -- Path to download. This is set to my repository on GitHub.
    versionUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/version", -- Path to version file. This is set to my repository on GitHub.
    versionPath = "DynaCodeVersion", -- Leave as is if you like, or change to a file (ideally in the same directory as DynaCode)
    output = true, -- print information to the screen during update check
    resetScreenPost = true, -- clear the screen after update check (recommended because the text color will be changed)
    clearDelay = 1 -- delay before clearing the screen
}

local updateChecked = false

local function clear()
    term.setBackgroundColor( colors.black )
    term.clear()
    term.setCursorPos(1, 1)
end

local function uPrint( color, ... )
    term.setTextColor( color or colors.white )
    if apiCfg.output then
        print( ... )
    end
    term.setTextColor( colors.white )
end

function getUpdateOutputSetting()
    return apiCfg.output
end

function setUpdateOutputSetting( v )
    apiCfg.output = v
end

function getUpdatePathSetting()
    return apiCfg.updatePath
end

function setUpdatePathSetting( v )
    apiCfg.updatePath = v
end

function getUpdateVersionSetting()
    return apiCfg.versionPath
end

function setUpdateVersionSetting( v )
    apiCfg.versionPath = v
end

function getUpdateResetPostSetting()
    return apiCfg.resetScreenPost
end

function setUpdateResetPostSetting( v )
    apiCfg.resetScreenPost = v
end

function setUpdateAutoSetting( v )
    apiCfg.keepUpToDate = v
end

function getUpdateAutoSetting()
    return apiCfg.keepUpToDate
end

function setUpdateDelaySetting( v )
    apiCfg.clearDelay = v
end

function getUpdateDelaySetting()
    return apiCfg.clearDelay
end

function getVersionData( silent )
    if not http then
        if not silent then error("getVersionData: Cannot check for updates. ComputerCraft HTTP API is disabled.") else return false, "HTTP Disabled" end
    end
    for i = 1, 3 do
        uPrint( false, "Fetching version information. Attempt "..i.." of 3")
        local response = http.get( apiCfg.versionUrl )
        if response then
            local rData = textutils.unserialize( response.readAll() )
            if not rData then
                if not silent then
                    error("getVersionData: Remote Version Data Invalid")
                else
                    return false, "getVersionData: Remote Version Data Invalid"
                end
            end
            local update = false
            local localData
            local h = fs.open( apiCfg.versionPath, "r" )
            if h then
                localData = textutils.unserialize( h.readAll() )
                if not localData then
                    h.close()
                    fs.delete( apiCfg.versionPath )
                    uPrint(colors.red, "Reverted corrupted data")
                    sleep(1)
                    os.reboot()
                end
                h.close()
                if localData.version ~= rData.version or localData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
            else
                update = true
            end
            if update then uPrint(colors.orange, "DynaCode 3 is out-of-date") else uPrint( colors.lime, "DynaCode 3 is up-to-date") end
            if apiCfg.resetScreenPost and not silent then sleep(apiCfg.clearDelay) clear() end
            --if update then
                return update, rData, localData or ( not update and true )
            --else
            --  return update, rData, localData
            --end
        end
    end
    uPrint(colors.red, "Could not fetch version file.")
    if apiCfg.resetScreenPost and not silent then sleep(apiCfg.clearDelay) clear() end
    return false, "Could not fetch version file"
end

function installVersionData( rData, silent )
    if not http then
        if not silent then error("installVersionData: Cannot fetch updates. ComputerCraft HTTP API is disabled.") else return false, "HTTP Disabled" end
    end
    -- @rData is the remoteDataFile.
    -- Open local file and compare
    if not rData or type( rData ) ~= "table" then if not silent then error("installVersionData: Expected table, got ".. type( rData )) else return false, "Invalid Version Data" end end
    local h = fs.open( apiCfg.versionPath, "r" )
    local update = false
    local lData
    if not h then update = true else
        lData = textutils.unserialize( h.readAll() )
        h.close()
        if not lData then
            fs.delete( api.versionPath )
            os.reboot()
        end
        if lData.version ~= rData.version or lData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
    end

    if update then
        for i = 1, 3 do
            uPrint(false, "Fetching update files. Attempt ", i, " of 3")
            local response = http.get( apiCfg.updateUrl )
            if response then
                local h = fs.open( apiCfg.updatePath, "w" )
                h.write( response.readAll() )
                h.close()
                h = fs.open( apiCfg.versionPath, "w" )
                h.write( textutils.serialize( rData ) )
                h.close()
                uPrint(colors.lime, "Install complete, rebooting in one second")
                if not silent then
                    sleep(1)
                    os.reboot()
                else return true end
            end
        end
        uPrint(colors.red, "Could not fetch update data")
    end

    if apiCfg.resetScreenPost and not silent then sleep(apiCfg.clearDelay) clear() end
end

function getVersion()
    local h = fs.open( apiCfg.versionPath, "r" )
    if not h then
        return { version = "Unknown", build = "Unknown" }
    end
    local cnt = h.readAll()
    h.close()
    return textutils.unserialize( cnt ) or { version = "Unknown", build = "Unknown" }
end

local function checkAndProceed()
    local go, data = getVersionData()
    if go and data then
        installVersionData( data )
    end
end

local function attemptInstall()
    local old = apiCfg.output
    apiCfg.output = false
    print("Missing Files or corrupted files! Please Wait...")

    local function printError( err )
        print("DynaCode is missing files, while trying to fetch them we encountered a problem: "..tostring( err ))
        sleep(5)
        return false
    end

    local go, data, confirm = getVersionData( true )
    if go and data then
        local success, err = installVersionData( data, true )
        if success then
            print("Finished fetching required files")
            sleep(1)
            os.reboot()
        else
            printError( err )
        end
    elseif not go and not confirm then
        printError( data )
    else
        print("No files are required")
    end
    apiCfg.output = old
end

local function copy(obj)
    if type(obj) ~= 'table' then return obj end
    local res = {}
    for k, v in pairs(obj) do res[copy(k)] = copy(v) end
    return res
end

local function inTable( tTable, aValue )
    if type( tTable ) == "table" then
        if not aValue then return false end
        for i = 1, #tTable do
            local value = tTable[i]
            if value == aValue then 
                return true, key, value 
            end
        end
    end
    return false
end

local function validateRequirements( needed, provided, silent, prefix, suffix )
    if type( provided ) ~= "table" then
        -- easier to understand error if no options were passed
        error("Expected table of settings when validating", 3)
    elseif type( needed ) ~= "table" or type( provided ) ~= "table" or ( type( silent ) ~= "nil" and type( silent ) ~= "boolean" ) or ( type( prefix ) ~= "nil" and type( prefix ) ~= "string" ) or ( type( suffix ) ~= "nil" and type( suffix ) ~= "string" ) then
        error("validateRequirements: Expected: table required, table given, boolean silent, string prefix, string suffix, got: "..type( needed )..", "..type( provided )..", "..type(silent)..", "..type(prefix)..", "..type(suffix), 3)
    end

    -- Loop @provided, then check @needed for the key-value pair found in @provided. If its in their simply remove it.

    local result = copy( needed )

    local function compile( prefix, suffix )
        local msg = prefix or ""
        for k, v in ipairs(result) do
            msg = msg.."- "..tostring(v)
            if k < #result then msg = msg .. "\n" end
        end
        if suffix then msg = msg .. "\n " .. suffix end
        return msg
    end

    for opt in pairs( provided ) do
        for key, req in ipairs( result ) do
            if req == opt then
                table.remove( result, key )
            end
        end
    end

    -- If the length of result is > 0, then not all requirements have been met.

    if #result > 0 then
        if silent then
            return false, compile( prefix or "", suffix or "")
        else
            error( compile( prefix or "", suffix or "" ), 3)
        end
    else
        return true
    end
end

local function convertOptions( presets, provided )

    local opts = {}

    local function convertToType( p, option, value )
        --error( "converting to: "..p .." from "..type( value ) .. " for option " .. option)
        if p == "string" then opts[option] = tostring( value )
        elseif p == "number" then 
            local temp = tonumber( value )
            if temp then opts[option] = temp else error("Invalid option "..option..". Type number expected, could not convert string to number!") end
        elseif p == "boolean" then
            if string.lower(value) == "false" then opts[option] = false elseif string.lower( value ) == "true" then opts[option] = true else error("Invalid option "..option.."Type boolean expected, string true or false must be explicitly set!") end
        elseif p == "table" then
            local temp = textutils.unserialize( value )
            if temp then opts[option] = temp else error("Invalid option "..option..". Type table expected, could not unserialize string to table.") end
        else opts[option] = value end
    end
    if not provided then error("no", 2) end
    for option, value in pairs( provided ) do
        if presets[option] then
            local p = presets[option]
            if type( p ) == "string" then
                if p ~= type( value ) then
                    convertToType( p, option, value )
                else opts[option] = value end
            elseif type( p ) == "table" then
                for _, t in pairs( p ) do
                    if t ~= type( value ) then convertToType( t, option, value ) else opts[option] = value end
                end
            else opts[option] = value end
        else
            opts[option] = value
        end
    end
    return opts
end

local function XMLStringToTable(s)
    local function parseargs(s)
        local arg = {}
        string.gsub(s, "([%-%w]+)=([\"'])(.-)%2", function (w, _, a)
        arg[w] = a
        end)
        return arg
    end
    
    local stack = {}
    local top = {}
    table.insert(stack, top)
    local ni,c,label,xarg, empty
    local i, j = 1, 1
    while true do
        ni,j,c,label,xarg, empty = string.find(s, "<(%/?)([%w:]+)(.-)(%/?)>", i)
        if not ni then break end
        local text = string.sub(s, i, ni-1)
        if not string.find(text, "^%s*$") then
            --table.insert(top, text)
            top["content"] = text
        end
        if empty == "/" then  -- empty element tag
            table.insert(top, {label=label, xarg=parseargs(xarg), empty=1})
        elseif c == "" then   -- start tag
            top = {label=label, xarg=parseargs(xarg)}
            table.insert(stack, top)   -- new level
        else  -- end tag
            local toclose = table.remove(stack)  -- remove top
            top = stack[#stack]
            if #stack < 1 then
                error("nothing to close with "..label)
            end
            if toclose.label ~= label then
                error("trying to close "..toclose.label.." with "..label)
            end
            table.insert(top, toclose)
        end
        i = j+1
    end
    local text = string.sub(s, i)
    if not string.find(text, "^%s*$") then
        table.insert(stack[#stack], text)
    end
    if #stack > 1 then
        error("unclosed "..stack[#stack].label)
    end
    return stack[1]
end

function createProgram( options )
    validateRequirements({ "name" }, options, false, "Missing requirements to initialize program:\n", "\nPlease define the above settings when creating your program instance")
    if not updateChecked then

        local h = fs.open( apiCfg.versionPath, "r" )
        if h then
            local r = h.readAll()
            h.close()
            if not r then
                attemptInstall()
            elseif r then
                r = textutils.unserialize( r )
                if not r then
                    attemptInstall()
                elseif r then
                    _G._DYNACODE = r
                end
            end
        else
            attemptInstall()
        end

        if apiCfg.keepUpToDate then
            -- check for updates now
            checkAndProceed()
        end

        updateChecked = true

    end
    
    local termX, termY = term.getSize()
    local ins, rem, len, sub, setCursorPos, setBackgroundColor, setTextColor, rep = table.insert, table.remove, string.len, string.sub, term.setCursorPos, term.setBackgroundColor, term.setTextColor, string.rep

    local defaults = { backgroundColor = colors.black, debug = true, debugWait = 0.5, debugPauseOnException = true, catchErrors = true, customErrorCB = false, restartTimer = 10 }

    local objects = { -- program registry
        scenes = {}, -- not drawn, just here to be accessed.
        stages = {}, -- drawn
        dialogs = {},
        buffer = {},
        animations = {},
        layers = {}
    }
    local programQueue, tEvents, reorderRequests = {}, {}, {}

    local filters = {
        {
            name = "_NORMAL",
            tbl = {
                ["white"] = colors.white,
                ["orange"] = colors.orange,
                ["magenta"] = colors.magenta,
                ["lightBlue"] = colors.lightBlue,
                ["yellow"] = colors.yellow,
                ["lime"] = colors.lime,
                ["pink"] = colors.pink,
                ["gray"] = colors.gray,
                ["lightGray"] = colors.lightGray,
                ["cyan"] = colors.cyan,
                ["purple"] = colors.purple,
                ["blue"] = colors.blue,
                ["brown"] = colors.brown,
                ["green"] = colors.green,
                ["red"] = colors.red,
                ["black"] = colors.black
            }
        },
        {
            name = "_UNFOCUSED",
            tbl = {
                ["white"] = colors.lightGray,
                ["orange"] = colors.gray,
                ["magenta"] = colors.lightGray,
                ["lightBlue"] = colors.lightGray,
                ["yellow"] = colors.lightGray,
                ["lime"] = colors.gray,
                ["pink"] = colors.lightGray,
                ["gray"] = colors.gray,
                ["lightGray"] = colors.lightGray,
                ["cyan"] = colors.gray,
                ["purple"] = colors.gray,
                ["blue"] = colors.gray,
                ["brown"] = colors.gray,
                ["green"] = colors.gray,
                ["red"] = colors.gray,
                ["black"] = colors.gray
            }
        }
    }

    local clone = {}
    local program = {}
    setmetatable( options, {__index = defaults})
    setmetatable( program, {__index = options})

    local function log( msg, mode )
        if program.loggingReady and program.logging then
            local prefix = "Info"
            if mode == "w" then prefix = "Warn" elseif mode == "e" then prefix = "ERROR" end
            clone.file.append( program.loggingPath, "["..os.clock().."] ["..prefix.."] "..msg.."\n")
        end
        if program.debug then
            if mode == "w" or mode == "e" then setTextColor( colors.red ) end
            setBackgroundColor( colors.black )
            print( "DEBUG OUTPUT: "..tostring( msg ) )
            setTextColor( colors.white )
            if program.debugWait and ( mode == "i" or not mode ) then sleep( program.debugWait ) end
            if program.debugPauseOnException then
                if mode == "w" then
                    print("Warning Caught - Press any key to continue")
                    os.pullEventRaw("key")
                elseif mode == "e" then
                    print("Exception Caught - Press any key to continue")
                    os.pullEventRaw("key")
                end
            end
        end
    end

    local function filterGet( name )
        if not name then error("filterGet: Expected string to fetch filter") end

        for i = 1, #filters do
            if filters[i].name == name then return filters[i] end
        end
        return false

    end

    local function filterRemove( name )
        if not name then error("filterRemove: Expected string to remove filter") end

        for i = 1, #filters do
            if filters[i] == name then
                filters[i] = nil
            end
        end

    end

    local function filterAdd( name, tbl )
        if not name or not tbl then
            error("filterAdd: Expected argument of type string and table")
        end
        filters[#filters + 1] = { name = name, tbl = tbl or {} }
    end

    local function getColorFromFilter( filter, cl )
        if not filter or not cl then
            error("getColorFromFilter: Expected filter string and color string to fetch color from filter.", 3)
        end
        local r = filterGet( filter )
        local c
        if not r then
            log("getColorFromFilter: Filter not found in program instance: "..tostring(filter)..". Returning API color by default", "e")
            r = colors
            c = r[cl]
        else
            c = r.tbl[cl]
        end
        if not c then
            log("getColorFromFilter: Cannot find color ("..tostring(cl)..") in filter, returning WHITE", "w")
            return colors.white
        else
            return c
        end
    end

    function clone.setLoggingPath( v )
        program.loggingPath = v
    end
    function clone.getLoggingPath()
        return program.loggingPath
    end

    function clone.setLoggingEnabled( v )
        program.logging = v
    end
    function clone.getLoggingEnabled()
        return program.logging
    end

    function clone.logToFile( content, mode )
        log( content, mode )
    end

    function clone.initializeLogFile()
        if not program.logging or not program.loggingPath then
            error("Set logging and logging path before initializing", 2)
        end
        local h = fs.open( program.loggingPath, "w" )
        local ver = getVersion()
        if h then
            h.write("--@@@==== DynaCode Logging - Instance: "..program.name.." ====@@@--\n")

            -- Output instance information (version information too)
            h.write("\nDynaCode \n--------\nVersion: "..ver.version.."\nBuild: "..ver.build.."\nStable: "..tostring(ver.stable).."\n")
            local title = "\nProgram Instance (" .. tostring( program.name ) .. ")"
            h.write(title.."\n".. rep( "-", len(title) ) .. "\n")
            local str = "Debug: "..tostring( program.debug )
            h.write(str.."\n")
            if program.debug then
                h.write( rep( "-", len( str ) ).."\n" )
                h.write("Wait: "..tostring( program.debugWait ).."\n")
                h.write("PauseOnException: "..tostring( program.debugPauseOnException ).."\n")
            end
            h.write("\n")
            h.write("customErrorCallback: " .. ( type( program.customErrorCB ) == "function" and "true" or "false" ) .. "\n" )
            if not program.customErrorCB then h.write("dynacodeCrashScreen Timer: "..program.restartTimer .. " (seconds)\n") end
            h.write("\n".. rep("=", 30) .."\nLog initialized\n\nSTART SYSTEM LOG\n")
            h.close()
            program.loggingReady = true
        else error("Could not initialize log file", 2) end
    end

    local function registryFetch( nm )
        local objects = objects.stages
        local v
        for i = 1, #objects do
            v = objects[i]
            if v and type( v ) == "table" and v.getName then
                if v:getName() == nm then
                    return v
                end
            end
        end
        return false
    end

    local function registryRemove( nm )
        local objects = objects.stages
        local v
        for i = 1, #objects do
            v = objects[i]
            if v and type( v ) == "table" and v.getName then
                if v:getName() == nm then
                    rem( objects, i )
                end
            end
        end
    end

    local function addReorderRequestToQueue( sStage )
        reorderRequests[ #reorderRequests + 1 ] = sStage
    end

    local function addBufferRequestToQueue( sStage, tBuffer, xStart, yStart, xEnd, yEnd )
        --log("Queueing redraw for "..sStage..", "..xStart..", "..yStart..", "..xEnd..", "..yEnd)
        --error( sStage.getBufferLevel )
        programQueue[ #programQueue + 1 ] = { stage = sStage, yStart = yStart, xStart = xStart, xEnd = xEnd, yEnd = yEnd }
    end

    local function removeBufferRequestFromQueue( sStage )
        local request
        for i = 1, #programQueue do
            request = programQueue[i]
            if request.stage == sStage then programQueue[i] = nil end
        end
    end

    local last = {}

    local function createBuffer()
        for y = 1, termY do
            objects.buffer[y] = {}
            for x = 1, termX do
                objects.buffer[y][x] = { " ", colors.white, program.backgroundColor }
            end
        end
        for y = 1, termY do
            last[y] = {}
            for x = 1, termX do
                last[y][x] = { " ", colors.white, program.backgroundColor }
            end
        end
    end
    createBuffer()

    local function formMap()
        for y = 1, termY do
            local layerY = objects.layers[y]
            objects.layers[y] = {}
            for x = 1, termX do
                objects.layers[y][x] = "init"
            end
        end
    end
    formMap()

    local function mapPixels( x1, y1, x2, y2 )
        -- Create a map of the terminal, each plot on the map will contain the Z-index of the window.
        local stages = objects.stages
        local layers = objects.layers

        for i = #stages, 1, -1 do

            local stage = stages[i]
            local bufferLevel = stage:getBufferLevel()
            local visible = stage:getVisible()

            local winX1, winY1 = stage:getPos()
            local winX2, winY2 = winX1 + stage:getWidth() - 1, winY1 + stage:getHeight() - 1

            if not (winX1 > x2 or winY1 > y2 or x1 > winX2 or y1 > winY2) then
                
                for y = math.max(winY1, y1), math.min(winY2, y2) do

                    local layerY = layers[y]
                    if layerY then
                        for x = math.max(winX1, x1), math.min(winX2, x2) do
                            local layerX = layerY[x]

                            if layerX then

                                if (layerX == "init" or layerX > bufferLevel or layerX == 0 ) and visible then

                                    objects.layers[y][x] = bufferLevel
                                elseif layerX == bufferLevel and not visible then

                                    objects.layers[y][x] = 0
                                end

                            end
                        end
                    end
                end

                if visible then stage:redraw() end
            end
        end


        local buffer = objects.buffer
        for y = y1, y2 do
            local layerY = objects.layers[y]
            for x = x1, x2 do
                if layerY and layerY[x] and (layerY[x] == 0 or layerY[x] == "init") then
                    local b = buffer[y][x]
                    b[1] = " "
                    b[2] = 1
                    b[3] = program.backgroundColor
                end
            end
        end

    end


    local function renderBuffer( force )
        -- Compare each entry in here to the old buffer. Only redraw if changed.
        -- Draw the table passed (should be size of entire terminal)

        local buffer = objects.buffer

        local oTC, oBG = colors.white, colors.black

        local getTC, getBG

        if term.getTextColor and term.getBackgroundColor then
            getTC = term.getTextColor
            getBG = term.getBackgroundColor
        else
            getTC = function() return oTC end
            getBG = function() return oBG end
        end

        setTextColor( oTC )
        setBackgroundColor( oBG )
        
        local tX, oX
        for y = 1, termY do

            local tY = buffer[y]
            local oY = last[y]

            for x = 1, termX do

                tX = tY[x]
                oX = oY[x]

                if force or tX[1] ~= oX[1] or tX[2] ~= oX[2] or tX[3] ~= oX[3] then
                    setCursorPos( x, y )
                    
                    if tX[2] ~= getTC() then setTextColor( tX[2] ) oTC = tX[2] end --only change if required.
                    if tX[3] ~= getBG() then setBackgroundColor( tX[3] ) oBG = tX[3] end
                    
                    term.write( tX[1] )

                    oX[1] = tX[1]
                    oX[2] = tX[2]
                    oX[3] = tX[3]
                end

            end
        end
    end

    local needsChange = true

    local function drawAll()
        local stages = objects.stages
        for i = 1, #stages do
            stages[i]:redraw()
        end
        renderBuffer( false )
    end

    function clone.drawAll() drawAll() end

    local function reorderBufferLevels( sTop )

        local stages = objects.stages
        local start = 1
        for i = 1, #stages do
            local stage = stages[i]
            if stage.getName() == sTop then stage:setBufferLevel(1) start = 2 end
        end
        table.sort(stages, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)
        local stage
        for i = 1, #stages do
            stage = stages[i]
            if stage.getName() ~= sTop then
                stage:setBufferLevel(start)
                start = start + 1
            end
        end
    end

    local function getHighestLevel( nX, nY )
        local list = {}
        local stages = ( objects.stages )
        local dialogs = ( objects.dialogs )

        local tbls = { stages, dialogs }
        for i = 1, #tbls do
            local tbl = tbls[i]
            for item = 1, #tbl do
                list[#list + 1] = tbl[item]
            end
        end
        table.sort(list, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)

        --[[ Compile a list of windows and dialogs ]]

        for i = #list, 1, -1 do
            local sX, sY = list[i].getPos()
            local offset = 0
            if list[i].getType() == "stage" then
                if list[i].getBorderless() then offset = 1 else offset = 0 end
            else offset = 1 end
            if nX >= sX and nX <= sX + list[i].getWidth() - 1 and nY >= sY and nY <= sY + list[i].getHeight() - offset then
                return list[i]
            end
        end
    end

    function clone.setDebug( v )
        program.debug = v
    end

    function clone.setDebugSleep( v ) program.debugWait = v end

    function clone.setDebugPauseOnException( v ) program.debugPauseOnException = v end

    local animationPresets = {}
    local validAnimationTargets = { 
    ["stage"] = {
        "x", "y", "width", "height"
    },
    ["button"] = {
        "x", "y", "width", "height"
    },
    ["label"] = {
        "x", "y"
    },
    ["pane"] = {
        "x", "y"
    },
    ["input"] = {
        "x", "y"
    }}
    local animationTimers = {}
    function clone.createAnimation( sName, target, mode, setting, newValue, interval, step )
        if type( target ) ~= "table"
        or type( sName ) ~= "string"
        or type( mode ) ~= "string"
        or type( setting ) ~= "string"
        or type( newValue ) == "nil"
        or type( interval ) ~= "number"
        or type( step ) ~= "number" then
            error("Expected string, table, string, string, new var, number, number", 2)
        end

        if type( target.getType ) ~= "function" then error("Invalid target. getType method not found") end

        local targetType, valid = target.getType(), false
        if validAnimationTargets[targetType] then
            for _, property in ipairs( validAnimationTargets[targetType] ) do
                if property == setting then valid = true break end
            end
            if not valid then error("Invalid property to animate, only\n"..(function()
                local str = ""
                for key, v in ipairs( validAnimationTargets[targetType] ) do str = str .. "- " ..v.."\n" end
                str = str .. "Can be animated."
                return str
            end)()) end
        else error("Cannot animate this target. Only\n"..(function()
            local str = ""
            for key, v in pairs( validAnimationTargets ) do str = str .. "- "..key.."\n" end
            str = str .. "Can be animated."
            return str
        end)()) end

        local function registryUpdate( self )
            for k, v in ipairs( objects.animations ) do
                if v and type(v) == "table" then
                    if v.getName() == sName then
                        table.remove( objects.animations, k )
                    end
                end
            end

            table.insert( objects.animations, self )
        end

        if type( newValue ) ~= type( target.getAnimationProperty( setting ) ) then error("target value and animation type should match "..(type( newValue ) .. ", " .. type( target.getAnimationProperty( setting ) ))) end

        -- This object will contain a couple of methods (resume, stop, pause, start) and some settings.
        local animationDefaults = {}
        local new = {}
        local private = {}

        local function calculateInterval()
            -- get the difference of the two values
            local oV = target.getAnimationProperty( setting ) -- Handle getting property values in each object.
            if type( oV ) == "number" then
                -- Get the difference of the two, (multiply by -1 if the number is negative). Then divide the result by the duration to get the interval (math.floor it)
                local diff = oV - newValue
                if diff < 0 then diff = diff * -1 end
                if diff == 0 then private.interval = duration else
                    private.interval = duration/diff -- How often we need to change the setting (advance the animation)
                end
            elseif type( oV ) == "string" then
                -- Cannot really animate this, so set the animation interval to the duration.
                private.interval = duration
            end
        end

        local function setupPrivate()
            --calculateInterval()
            if step < 0 then step = step*-1 end
        end

        local function updateInitialValue()

        end

        local function queueTimer( self )
            -- Queue a timer object containing the actual animation ( self )
            animationTimers[os.startTimer( interval )] = {
                animation = sName
            }
        end

        function new.start( self )
            --calculateInterval()
            if target.getAnimationProperty( setting ) ~= newValue then
                private.running = true
                queueTimer( self )
            end
        end
        function new.resume( self ) end

        function new.stop( self ) private.running = false end
        function new.pause( self ) end

        function new.setLooping( self ) end -- if looping is true, the animation will animate from the original setting, to the new one, and back again. From there it will restart

        function new.processFrame( self )
            local current = target.getAnimationProperty( setting )
            if current ~= newValue and private.running then
                if current - newValue < 0 then private.direction = step else private.direction = step*-1 end
                
                -- If moving down towards new value, then check that moving by direction increment won't overshoot. If it will change it.
                local am = private.direction
                if current - newValue > 0 then
                    -- moving to newValue from in-front (newValue is less than current value)
                    if current - newValue < am*-1 then am = newValue - current end
                else
                    if current + am > newValue then am = current - newValue end
                    if am < 0 then am = am *-1 end
                end
                target:setAnimationProperty( setting, current + am, private.interval )
                
                local new = target.getAnimationProperty( setting )
                if new ~= newValue and private.running then
                    if type( new ) == type( newValue ) then
                        queueTimer( self )
                    else
                        error("Types not same. AnimationProperty from target and newValue should be the same type")
                    end
                else private.running = false end
            else private.running = false end
        end

        function new.getName() return sName end

        function new.getRunning() return private.running end

        setupPrivate()
        registryUpdate( new )
        return new
    end

    function clone.createDialog( cfg )
        --[[
            The dialog is stored in the programs registry, when the stage it is bound to is updated, the dialog box is also updated.

            On redraw @func processBufferQueue will identify any dialogs boxes owned by a particular stage and draw them appropriately.

            If the dialog has no owner, it will simply not be displayed and no events will be passed to it.

            The parent will be directly used to getColors from its filters and to update its draw status.
        ]]
        local dialogDefaults = {
            headerText = "Dialog Header",
            headerTextColor = "blue",
            headerBackgroundColor = "lightGray",
            height = 5,
            width = 30,
            x = 10,
            y = 1,
            bodyTextColor = colors.white,
            bodyBackgroundColor = "gray"
        }

        local function registryUpdate( self )
            for k, v in ipairs( objects.dialogs ) do
                if v and type(v) == "table" then
                    if v == self then
                        table.remove( objects.dialogs, k )
                    end
                end
            end

            table.insert( objects.dialogs, self )
        end


        local new = {}
        local settings = {}
        local cache = { needsRedraw = true }
        setmetatable( cfg, {__index=dialogDefaults})
        setmetatable( settings, {__index=cfg})
        local parent = false

        -- when moved a forced redraw will occur, after the event has passed through all coroutines drawAll() will redraw this dialog if it requires redrawing.

        function new.drawToTable( self, tBuffer, nMaxX, nMaxY, nXOffset, nYOffset )
            -- If the dialog box has header text, create a box at the top of the buffer for it, center the text (one line)
            local util = parent
            if not util then return tBuffer end
            local headerString = {}
            for i = 1, #settings.headerText do
                headerString[i] = string.sub( settings.headerText, i, i )
            end

            for y = 1, settings.height do
                if y + settings.y - 1 + nYOffset > nMaxY then break end
                for x = 1, settings.width do
                    if x + settings.x + nXOffset - 1 <= nMaxX then
                        if y >= 1 and y <= 3 and settings.headerText then
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].char = " "
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].backgroundColor = util.getColor( settings.headerBackgroundColor )
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].textColor = util.getColor( settings.headerTextColor )
                            if y == 2 and x >= 1 and x <= settings.width - 1 then
                                if headerString[x-1] then tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].char = headerString[x-1] end
                            end
                        elseif y == 4 then
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].char = "-"
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].backgroundColor = util.getColor( settings.headerBackgroundColor )
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].textColor = util.getColor( settings.headerTextColor )
                        else
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].char = " "
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].backgroundColor = util.getColor( settings.bodyBackgroundColor )
                            tBuffer[y + nYOffset + settings.y - 1][x + nXOffset + settings.x - 1].textColor = util.getColor( settings.bodyTextColor )
                        end
                    end
                end
            end
            return tBuffer
        end

        function new.bindTo( self, v ) if parent then error("Dialog is already bound to a parent: "..parent.getName()..". Unbind before binding this dialog box again") else parent = v v:setDialog( self ) end end
        function new.unbind( self ) end
        function new.getBind( self ) return parent end

        function new.setHeaderText( self, v ) 
            settings.headerText = v
        end
        function new.setHeaderTextColor( self, v ) 
            settings.headerTextColor = v
        end
        function new.setHeaderBackgroundColor( self, v ) 
            settings.headerBackgroundColor = v
        end

        function new.getHeaderText( self ) return settings.headerText end
        function new.getHeaderTextColor( self ) return settings.headerTextColor end
        function new.getHeaderBackgroundColor( self ) return settings.headerBackgroundColor end

        function new.setBodyText( self, v ) 
            settings.bodyText = v
        end
        function new.setBodyTextColor( self, v ) 
            settings.bodyTextColor = v
        end
        function new.setBodyBackgroundColor( self, v ) 
            settings.bodyBackgroundColor = v
        end

        function new.getBodyText( self ) return settings.bodyText end
        function new.getBodyTextColor( self ) return settings.bodyTextColor end
        function new.getBodyBackgroundColor( self ) return settings.bodyBackgroundColor end

        function new.destroy( self ) end

        function new.setRedrawStatus( self, v )
            cache.needsRedraw = v
        end
        function new.getRedrawStatus( self )
            return cache.needsRedraw
        end

        function new.setX() end
        function new.setY() end

        function new.getPos() return settings.x, settings.y end

        function new.getWidth() return settings.width end
        function new.getHeight() return settings.height end

        function new.getBufferLevel()
            if parent then return parent.getBufferLevel() else return false end
        end

        function new.getType() return "dialog" end

        function new.attentionFlash()
            for i = 1, 4 do
                -- flash to attention twice.
                
            end
        end

        registryUpdate( new )

        return new
    end

    local function getTotalOffset( node )
        local x, y, i, last = 0, 0, 0, false
        last = node:getParent()
        --log("Getting total offset, last: "..tostring( last ) .. ".  Type> "..( last and last.getType and last.getType() or "no type" ))
        if last and last.getPos then
            while true do
                local nX, nY = last:getPos()
                x = x + nX
                y = y + nY
                i = i + 1
                if last.getParent and last:getParent() and last:getParent().getPos then
                    last = last:getParent()
                else
                    break
                end
            end
        end
        return x, y, i, last
    end


    function clone.createStage( cfg )
        validateRequirements({ "name" }, cfg, false, "The following options must be defined:\n", "\nPlease define these settings when creating your stage.")
        local stageDefaults = {
            bufferLevel = 1,
            active = false,
            x = 2,
            y = 2,
            width = 12,
            height = 5,
            backgroundColor = "white",
            textColor = "black",
            lastClickX = 2,
            lastClickY = 2,
            closeButton = true,
            closeButtonColor = "red",
            closeButtonTextColor = "white",
            topBarColor = "gray",
            topBarDisabledColor = "lightGray",
            filter = "_NORMAL",
            unfocusedFilter = "_UNFOCUSED",
            moveable = true,
            visible = true,
            fullscreen = false,
            eventWhitelist = {},
            eventBlacklist = {},
            minWidth = 12,
            minHeight = 5,
            maxWidth = 12,
            maxHeight = 5,
            onEvent = false,
            onResize = false,
            onClose = false,
            onReposition = false,
            onThreadTermination = false,
            onFocus = false,
            onBlur = false,
            onThreadCrash = false,
            onThreadFinish = false
        } -- manual settings will override these
        local window, windowBuffer, new, settings, cache, cacheDefaults, stageCanvas, nodeCanvas = {}, {}, {}, {}, {}, { needsRedraw = true, redrawNodes = true, forceRedraw = true }, {}, {}
        setmetatable( stageDefaults, {__index = defaults})
        setmetatable( cfg, {__index = stageDefaults} )
        setmetatable( settings, {__index=cfg} )
        setmetatable( cache, {__index=cacheDefaults})
        local dialog = false
        local stageCallbacks = {
            ["event"] = settings.onEvent,
            ["resize"] = settings.onResize,
            ["close"] = settings.onClose,
            ["reposition"] = settings.onReposition,
            ["threadTerminate"] = settings.onThreadTermination,
            ["focus"] = settings.onFocus,
            ["blur"] = settings.onBlur,
            ["threadCrash"] = settings.onThreadCrash,
            ["threadFinish"] = settings.onThreadFinish
        }

        local bufferDefaults = {
            cursorBlink = false, 
            backgroundColor = settings.backgroundColor, 
            textColor = colors.white, 
            cX = 1, 
            cY = 1
        }
        setmetatable( windowBuffer, {__index=bufferDefaults})
        setmetatable( stageCanvas, {__index=bufferDefaults})

        local function registryUpdate( self )
            for i = 1, #objects.stages do
                local v = objects.stages[i]
                if v and type(v) == "table" then
                    if v:getName() == settings.name then
                        table.remove( objects.stages, k )
                    end
                end
            end
            objects.stages[ #objects.stages + 1 ] = self
        end

        local colorCodes = {
            ["white"] = { decimal = 1, paint = "0" },
            ["orange"] = { decimal = 2, paint = "1" },
            ["magenta"] = { decimal = 4, paint = "2" },
            ["lightBlue"] = { decimal = 8, paint = "3" },
            ["yellow"] = { decimal = 16, paint = "4" },
            ["lime"] = { decimal = 32, paint = "5" },
            ["pink"] = { decimal = 64, paint = "6" },
            ["gray"] = { decimal = 128, paint = "7" },
            ["lightGray"] = { decimal = 256, paint = "8" },
            ["cyan"] = { decimal = 512, paint = "9" },
            ["purple"] = { decimal = 1024, paint = "a" },
            ["blue"] = { decimal = 2048, paint = "b" },
            ["brown"] = { decimal = 4096, paint = "c" },
            ["green"] = { decimal = 8192, paint = "d" },
            ["red"] = { decimal = 16384, paint = "e" },
            ["black"] = { decimal = 32768, paint = "f" }
        }

        local function convertColor( cl, blit )
            -- gets the name of the number @cl color.
            -- This can then be used with getColor.
            -- loop each key
            if not cl or ( type( cl ) ~= "string" and type( cl ) ~= "number" ) then
                error("convertColor: Expected: string/number color", 2)
            else
                if type( cl ) == "string" and blit then
                    if colorCodes[cl] then
                        return colorCodes[cl].paint
                    else return false end
                else

                    for i = 1, #colorCodes do
                        local color = colorCodes[i]
                        if type( color ) == "table" then
                            if color.decimal == cl then
                                return color
                            end
                        end
                    end
                end
            end
            return nil
        end

        local function getColor( cl, blit )
            local filter, col
            if settings.active then
                filter = filterGet( settings.filter )
            else
                filter = filterGet( settings.unfocusedFilter )
            end
            if not filter then filter = assert( filterGet( "_NORMAL" ), "NORMAL filter cannot be found, this filter should not have been overwritten" ) end
            -- if the color is not a string, covert it to one
            if type( cl ) == "number" or blit then
                col = convertColor( cl, blit )
            end
            if blit and col then return col end
            if col then
                -- now that we have a color, get the color from the filter
                local c = filter.tbl[col]
                if c then return c end
            elseif type( cl ) == "string" then
                -- this color cannot be converted, it is already a string.
                local c = filter.tbl[cl]
                if c then return c end
            end
            return colors[cl] or cl or colors.white
        end

        local function mapWindow()
            mapPixels( settings.x, settings.y, settings.x + settings.width - 1, settings.y + settings.height - 1 )
        end

        local nodeMap = {}

        local function formMap()
            for y = 1, settings.height do
                nodeMap[y] = {}
                for x = 1, settings.width do
                    nodeMap[y][x] = { "init" }
                end
            end
        end
        formMap()

        local function mapNodes( x1, x2, y1, y2 )
            --log("Mapping nodes: X: "..x1..", "..x2.."  Y: "..y1..", "..y2)
            -- Create a map of the nodeCanvas, each point on the map will contain the ID of the node.

            local layers = nodeMap
            local nodes = settings.scene.getNodes()

            local background = settings.scene.getStage() and settings.scene.getStage().getColor( settings.backgroundColor ) or 1

            for i = #nodes, 1, -1 do

                local node = nodes[i]
                local nodeID = node:getID()
                local visible = node:getVisible()

                local nodeX1, nodeY1 = node:getPos()
                local nodeX2, nodeY2 = nodeX1 + node:getWidth() - 1, nodeY1 + node:getHeight() - 1

                --log("Mapping node: "..tostring( node ).."("..tostring( node:getName() )..", "..tostring( node.getType and node:getType() or "nil" )..")  "..tostring( nodeX1 )..", "..tostring( nodeY1 )..". "..tostring(nodeX2)..", "..tostring(nodeY2)..". visible: "..tostring(visible).." ID: "..tostring(nodeID), "w")

                if not (nodeX1 > x2 or nodeY1 > y2 or x1 > nodeX2 or y1 > nodeY2) then
                    
                    for y = math.max(nodeY1, y1), math.min(nodeY2, y2) do

                        local layerY = layers[y]
                        if layerY then
                            for x = math.max(nodeX1, x1), math.min(nodeX2, x2) do
                                local layerX = layerY[x]

                                if layerX then

                                    if ( layerX ~= nodeID ) and visible then

                                        nodeMap[y][x] = nodeID
                                    elseif layerX == nodeID and not visible then
                                        nodeMap[y][x] = 0
                                    end
                                end
                            end
                        end
                    end

                    if visible then node.setRedraw( true ) end
                end
            end

            --clone.file.write("hex/etc/dump/nodeLayers", textutils.serialize( layers ))


            local buffer = nodeCanvas
            for y = y1, y2 do
                local layerY = nodeMap[y]
                for x = x1, x2 do
                    if layerY and layerY[x] and (layerY[x] == 0 or layerY[x] == "init") then
                        local b = buffer[y][x]
                        buffer[y][x][1] = false
                        buffer[y][x][2] = false
                        buffer[y][x][3] = false
                    end
                end
            end
        end

        function new.mapNodes( x1, x2, y1, y2 ) mapNodes( x1, x2, y1, y2 ) end



        --[[
            Node Utilities

            Used by nodes in drawToTable methods.
        ]]

        function new.drawHLine( x1, x2, y ) end
        function new.drawBox() end

        function new.drawText() end



        local function runCallback(name, tPass, keepPacked)
            if stageCallbacks[name] and type( stageCallbacks[name] ) == "function" then
                if type( tPass ) == "table" and not keepPacked then
                    stageCallbacks[name](unpack( tPass )) 
                else
                    stageCallbacks[name]( tPass )
                end
            end
        end

        local canvas = {}
        for functionName, functionObject in pairs( term.native() ) do
            canvas[functionName] = functionObject
        end

        function canvas.write( text, p )
            local offset = (function() if settings.borderless then return 0 else return 1 end end)()
            if stageCanvas.cX < 1 or 
                stageCanvas.cX > 1 + settings.width or 
                stageCanvas.cY < 1 or 
                stageCanvas.cY > settings.height then
                return ""
            end
            if not cache.needsRedraw then cache.needsRedraw = true end

            local stageY, stageX

            stageY = stageCanvas[stageCanvas.cY]
            oTerm.setCursorPos( stageCanvas.cX + settings.x - 1, stageCanvas.cY + settings.y + 1 )

            for charIndex = 1, len(text) do
                stageX = stageCanvas[stageCanvas.cY][stageCanvas.cX]
                if not stageY then error(settings.name.." invalid Y-axis: "..stageCanvas.cY) end
                if not stageX then error(settings.name.." invalid X-axis: "..stageCanvas.cX) end
                stageX[1] = sub(text, charIndex, charIndex)
                if p then
                    stageX[2] = ( stageCanvas.textColor )
                    stageX[3] = ( stageCanvas.backgroundColor )
                else
                    stageX[2] = ( stageCanvas.textColor )
                    stageX[3] = ( stageCanvas.backgroundColor )
                end
                stageCanvas.cX = stageCanvas.cX + 1
                if stageCanvas.cX > settings.width then
                    break
                end
            end
        end

        function canvas.setTextColor( color )
            stageCanvas.textColor = color
        end

        function canvas.setBackgroundColor( color, name )
            stageCanvas.backgroundColor = color
        end

        function canvas.setCursorPos( nX, nY )
            stageCanvas.cX, stageCanvas.cY = nX, nY
            oTerm.setCursorPos( nX, nY )
        end

        local function draw()
            log("stageCanvas redraw", "w")
            term.redirect( canvas )
            local oX, oY = term.getCursorPos()
            local emptyString = rep( " ", settings.width)

            local startY, endY = 1, settings.height + 1 + (function() if not settings.borderless then return 1 else return 0 end end)()

            local bgColor, tcColor, topBarColor = getColor( settings.backgroundColor ), getColor( settings.textColor ), getColor( settings.topBarColor )

            setBackgroundColor( bgColor )
            setTextColor( tcColor )
            local bg, tc = true, true
            for y = startY, endY do
                if y == startY and not settings.borderless then
                    setBackgroundColor( topBarColor )
                    bg = false
                else
                    if not bg then
                        setBackgroundColor( bgColor )
                        bg = true
                    end
                    if not tc then setTextColor( tcColor ) tc = true end
                end
                setCursorPos(1, y)
                term.write(emptyString)
                if y == startY and settings.title and not settings.borderless then
                    local str, offset = settings.title, (function() if settings.closeButton then return 1 else return 0 end end)()
                    if #settings.title >= settings.width - offset then
                        local overflow = #settings.title - ( settings.width - offset )
                        if overflow == 0 then
                            str = sub( settings.title, 1, #settings.title-1-offset) .. "."
                        else
                            str = sub( settings.title, 1, #settings.title-overflow-1-offset) .. rep(".", overflow+1)
                        end
                    end
                    setCursorPos( 1, 1 )
                    term.write( str )
                end
                if y == startY and settings.closeButton and not settings.borderless then
                    setBackgroundColor( getColorFromFilter( settings.filter, settings.closeButtonColor ) )
                    setTextColor( getColorFromFilter( settings.filter, settings.closeButtonTextColor ) )
                    setCursorPos( settings.width , 1 )
                    term.write( "X", true )
                    bg, tc = false, false
                end
            end
            setCursorPos( oX, oY )
            setBackgroundColor( program.backgroundColor )
            term.redirect( oTerm )
        end

        -- Terminal Integration and coroutines
        local runningProgram, pgPath, redirect = false, false, {}

        local function close()
            runCallback("close")
            registryRemove( settings.name )
            removeBufferRequestFromQueue( settings.name )
            drawAll()
        end

        local function updateCursorPos()
            local offset = ( function() if settings.borderless then return 1 else return 0 end end)()
            oTerm.setCursorPos( settings.x + windowBuffer.cX - 1, settings.y + windowBuffer.cY - offset )
        end

        local function focus()
            log("window "..settings.name..", focused")
            runCallback("focus")
            settings.active = true
            cache.forceRedraw = true
            addReorderRequestToQueue( settings.name )
            mapWindow()
        end

        local function blur()
            log("window "..settings.name..", blurred")
            runCallback("blur")
            cache.forceRedraw = true
            settings.active = false
            mapWindow()
        end

        setmetatable( new, {__index=redirect})

        local function compileText( text, maxWidth, maxHeight )
            -- Returns a buffer containing word wrapped text
            local cX, cY = 1, 1
            local compiled = {}
            local function newLine()
                cX, cY = 1, cY + 1
                if cY > maxHeight then
                    compiled[cY-1][maxWidth-3] = "."
                    compiled[cY-1][maxWidth-2] = "."
                    compiled[cY-1][maxWidth-1] = "."
                    return true
                end
            end

            for y = 1, maxHeight do
                compiled[y] = {}
                for x = 1, maxWidth do compiled[y][x] = {} end
            end

            -- separate the text into separate words and process.
            while string.len( text ) > 0 do

                local whitespace = string.match( text, "^[ \t]+" )
                if whitespace then
                    cX = cX + #whitespace
                    text = string.sub( text, string.len(whitespace) + 1 )
                end


                local word = string.match( text, "^[^ \t\n]+" )
                if word then
                    text = text:sub( word:len() + 1 )
                    if word:len() > maxWidth then
                        -- if reached end of line, create new line.
                        if cX > maxWidth then if newLine() then return compiled end end
                        -- we have enough room for this word, separate it into chars and add them to the buffer
                        for index = 1, word:len() do
                            compiled[cY][cX] = word:sub( index, index )
                            cX = cX + 1
                            if cX > maxWidth then if newLine() then return compiled end end
                        end
                        --end
                    else
                        -- if at end of line, create a new line.
                        if cX + #word - 1 > maxWidth then if newLine() then return compiled end end
                        for index = 1, word:len() do
                            compiled[cY][cX] = word:sub( index, index )
                            cX = cX + 1
                            if cX > maxWidth then if newLine() then return compiled end end
                        end
                    end
                end
            end
            return compiled

        end

        function new.getRedrawStatus( self ) return cache.needsRedraw end
        function new.setRedrawStatus( self, v ) cache.needsRedraw = v end

        --[[

            Callback Setters and Getters

        ]]

        function new.setEventCallback( self, v ) 
            stageCallbacks.event = v
        end
        function new.getEventCallback( self ) 
            return stageCallbacks.event
        end

        function new.setResizeCallback( self, v ) 
            stageCallbacks.resize = v
        end
        function new.getResizeCallback( self ) 
            return stageCallbacks.resize
        end

        function new.setCloseCallback( self, v ) 
            stageCallbacks.close = v
        end
        function new.getCloseCallback( self ) 
            return stageCallbacks.close
        end

        function new.setRepositionCallback( self, v ) 
            stageCallbacks.reposition = v
        end
        function new.getRepositionCallback( self ) 
            return stageCallbacks.reposition
        end

        function new.setThreadTerminateCallback( self, v ) 
            stageCallbacks.threadTerminate = v
        end
        function new.getThreadTerminateCallback( self ) 
            return stageCallbacks.threadTerminate
        end

        function new.setFocusCallback( self, v ) 
            stageCallbacks.focus = v
        end
        function new.getFocusCallback( self ) 
            return stageCallbacks.focus
        end

        function new.setBlurCallback( self, v ) 
            stageCallbacks.blur = v
        end
        function new.getBlurCallback( self ) 
            return stageCallbacks.blur
        end

        function new.setThreadCrashCallback( self, v ) 
            stageCallbacks.threadCrash = v
        end
        function new.getThreadCrashCallback( self ) 
            return stageCallbacks.threadCrash
        end

        function new.setThreadFinishCallback( self, v ) 
            stageCallbacks.threadFinish = v
        end
        function new.getThreadFinishCallback( self ) 
            return stageCallbacks.threadFinish
        end

        function new.getRunningProgram() return runningProgram end
        function new.getTerm() return redirect end

        local function updateCursorBlink()
            --oTerm.setCursorBlink( windowBuffer.cursorBlink )
        end

        local function setupBuffer( table, offset, cl )
            local lastX, lastY = 1, 1
            local tc, bg = getColor( table.textColor ), getColor( table.backgroundColor )
            for height = 1, settings.height + 1 + offset do
                table[height] = ( function( height ) if table[height] then return table[height] else return {} end end )( height )
                lastY = height
                for width = 1, settings.width + 1 do
                    table[height][width] = ( function( height, width ) if table[height][width] then return table[height][width] else if cl then return { false, tc, bg } else return { " ", tc, bg } end end end )( height, width )
                    lastX = width
                end
                for width = lastX, #table[height] do
                    table[height][width] = nil
                end
            end
            for height = lastY, #table do
                table[height] = nil
            end
        end
        
        local function resetBuffer()
            setupBuffer(windowBuffer, 0 )
            setupBuffer(stageCanvas, (function() if settings.borderless then return 0 else return 1 end end)())
            setupBuffer(nodeCanvas, 0, true )
            formMap()
        end

        resetBuffer()
        function new.mapPixels() mapWindow() end

        local function redraw( self )
            if not settings.visible then return end

            local layers = objects.layers
            if cache.forceRedraw then draw() end
            if settings.scene then
                local nodes = settings.scene:getNodes()
                for i = 1, #nodes do
                    local node = nodes[i]
                    if node:needsRedraw() or cache.forceRedraw then
                        node.drawToTable( nodeCanvas, settings.width, settings.height, (settings.borderless and 0 or -1), self )
                        node.setRedraw( false )
                    elseif node.getContains and node.getContains() then
                        -- this node contains other nodes (eg: pane)
                        node.handleDraw( nodeCanvas, settings.width, settings.height, (settings.borderless and 0 or -1), self )
                    end
                end
            end
            cache.forceRedraw = false

            for y = 1, settings.height do
                local layerY = layers[ settings.y + y - 1 ]
                if layerY then
                    local nodeY = nodeCanvas[y]
                    for x = 1, settings.width do
                        if layerY[ settings.x + x - 1 ] == settings.bufferLevel then
                            local b = objects.buffer[ settings.y + y - 1 ][ settings.x + x - 1 ]
                            local nodeX = (nodeY and nodeY[x]) or { false, false, false }
                            if nodeX[1] then
                                b[1] = nodeX[1]
                                b[2] = nodeX[2]
                                b[3] = nodeX[3]
                            else
                                local stage = stageCanvas[y][x]
                                b[1] = stage[1]
                                b[2] = stage[2]
                                b[3] = stage[3]
                            end
                        end
                    end
                end
            end
        end

        function new:redraw() redraw( self ) end


        local function queueRedraw( self )
            --[[removeBufferRequestFromQueue( settings.name )
            addBufferRequestToQueue( self, mergeBuffers( self, true ), 1, 1, settings.width, settings.height+(function() if not settings.borderless then return 1 else return 0 end end)() )]]
            mapWindow()
        end
        --[[
            When the main event manager catches an event, it first checks if the event can be passed to the window using the eventFilter (if window is not active then only events inside the
            filter will be passed to the coroutine). If the event can be passed, the term will be redirected to the new stage term object and resumed.

            Any term calls will be redirected here where they can be buffered and drawn respectively.

            After the coroutine yields, other stages will get their coroutines checked and run if required, then term will be redirected to oTerm (original term).
        ]]

        function redirect.isColor() return oTerm.isColor() end
        redirect.isColour = redirect.isColor

        function redirect.write( sString )
            
            oTerm.setCursorPos( windowBuffer.cX + settings.x - 1, windowBuffer.cY + settings.y + ( function() if settings.borderless then return 1 else return 0 end end)() ) -- cX and cY are cursor positions relative to the window, not the terminal. Make up for this my adding their position.
            if windowBuffer.cX < 1 or windowBuffer.cX > settings.width or windowBuffer.cY < 1 or windowBuffer.cY > settings.height then
                return ""
            end
            if not cache.needsRedraw then cache.needsRedraw = true end
            for charIndex = 1, len(sString) do
                windowBuffer[windowBuffer.cY][windowBuffer.cX].char = sString:sub(charIndex, charIndex)
                windowBuffer[windowBuffer.cY][windowBuffer.cX].textColor = getColor( windowBuffer.textColor )
                windowBuffer[windowBuffer.cY][windowBuffer.cX].backgroundColor = getColor( windowBuffer.backgroundColor )
                windowBuffer.cX = windowBuffer.cX + 1

                if windowBuffer.cX > settings.width then
                    break
                end
            end
            oTerm.setBackgroundColor( program.backgroundColor )
            oTerm.setTextColor( colors.white )
        end
        function redirect.blit( sString, sBackground, sTextColor ) end

        function redirect.clear() end
        function redirect.clearLine() end

        function redirect.getCursorPos() return windowBuffer.cX, windowBuffer.cY end
        function redirect.setCursorPos( nX, nY ) windowBuffer.cX, windowBuffer.cY = tonumber( nX ), tonumber( nY ) updateCursorPos() end

        function redirect.setCursorBlink( bBlink ) windowBuffer.cursorBlink = bBlink updateCursorBlink() end
        function redirect.getCursorBlink() return windowBuffer.cursorBlink end

        function redirect.setTextColor( sColor ) windowBuffer.textColor = sColor end
        redirect.setTextColour = redirect.setTextColor

        function redirect.setBackgroundColor( sColor ) windowBuffer.backgroundColor = sColor end
        redirect.setBackgroundColour = redirect.setBackgroundColor

        function redirect.getBackgroundColor() return windowBuffer.backgroundColor end
        redirect.getBackgroundColour = redirect.getBackgroundColor

        function redirect.getTextColor() return windowBuffer.textColor end
        redirect.getTextColour = redirect.getTextColor

        function redirect.scroll( n )

        end

        function redirect.setVisible( bVisible ) settings.visible = bVisible end
        function redirect.getVisible() return settings.visible end

        function redirect.restoreCursor() end

        function redirect.getPosition() return settings.x, settings.y end
        function redirect.reposition() end

        function redirect.getSize() return settings.width, settings.height end
        

        local function removeFromEventWhitelist( v )
            for key, event in ipairs( settings.eventWhitelist ) do
                if event == v then
                    table.remove( settings.eventWhitelist, key )
                end
            end
        end
        function new.removeFromEventWhitelist( v ) removeFromEventWhitelist( v ) end
        
        local function addToEventWhitelist( v )
            removeFromEventWhitelist( v )
            table.insert( settings.eventWhitelist, v )
        end
        function new.addToEventWhitelist( v ) addToEventWhitelist( v ) end

        local function setEventWhitelist( v )
            settings.eventWhitelist = v
        end
        function new.setEventWhitelist( v ) setEventWhitelist( v ) end

        local function getEventWhitelist()
            return settings.eventWhitelist
        end
        function new.getEventWhitelist() return getEventWhitelist() end
        
        local function removeFromEventBlacklist( v )
            for key, event in ipairs( settings.eventBlacklist ) do
                if event == v then
                    table.remove( settings.eventBlacklist, key )
                end
            end
        end
        function new.removeFromEventBlacklist( v ) removeFromEventBlacklist( v ) end
        
        local function addToEventBlacklist( v )
            removeFromEventBlacklist( v )
            table.insert( settings.eventBlacklist, v )
        end
        function new.addToEventBlacklist( v ) addToEventBlacklist( v ) end

        local function getEventBlacklist()
            return settings.eventBlacklist
        end
        function new.getEventBlacklist() return getEventBlacklist() end


        local function setEventBlacklist( v )
            settings.eventBlacklist = v
        end
        function new.setEventBlacklist( v )
            setEventBlacklist( v )
        end

        local function wrapProgram( path )
            if type( path ) == "string" then
                if runningProgram and coroutine.status( runningProgram ) == "suspended" then
                    error("wrapProgram: Program already running on stage", 2)
                end
                if not path or type( path ) ~= "string" then
                    error("wrapProgram: Expected: path String")
                end
                local func = false
                if getfenv and setfenv and type( getfenv ) == "function" and type( setfenv ) == "function" then
                    local result, err = loadfile( path )
                    if not result then
                        if err then
                            error("wrapProgram: "..tostring( err ))
                        else
                            error("wrapProgram: Error while loading file.")
                        end
                    elseif result then
                        func = result
                    end
                    if func then
                        runningProgram = coroutine.create(function()
                            func()
                        end)
                        pgPath = path
                    else
                        error("wrapProgram: Could not load file")
                    end
                end
            elseif type( path ) == "function" then
                runningProgram = coroutine.create( path )
                pgPath = false
            else error("Expected path or run function") end
        end

        function new.getMerge( self )
            return mergeBuffers( self )
        end

        function new.runProgram( path )
            wrapProgram( path )
        end
        local messageCrashed, messageClosed = false, false
        function new.threadCrash( err )
            if not messageCrashed then
                runCallback("threadCrash")
                messageCrashed = coroutine.create(function()
                    term.setTextColor( colors.red )
                    print("Thread Crashed: "..err)
                    term.setTextColor( colors.white )
                    print("Press any key to continue")
                    os.pullEventRaw("key")
                    restore()
                    close()
                end)
            end
        end

        local function terminate()
            if not messageCrashed then
                runCallback("threadTerminate")
                messageCrashed = coroutine.create(function()
                    term.setTextColor( colors.red )
                    print("Thread Terminated")
                    term.setTextColor( colors.white )
                    print("Press any key to continue")
                    os.pullEventRaw("key")
                    restore()
                    close()
                end)
            end
        end

        function new.getColor( cl ) return getColor( cl ) end

        function new.getAlternate()
            return messageCrashed or messageClosed
        end

        function new.threadClosed()
            if not messageClosed then
                runCallback("threadFinish")
                messageClosed = coroutine.create(function()
                    term.setTextColor( colors.white )
                    print("Program finished\nPress any key to continue")
                    os.pullEventRaw("key")
                    restore()
                    close()
                end)
            end
        end

        function new.setDialog( self, diag )
            dialog = diag
        end

        function new.getDialog( self ) return dialog end

        function new.draw( self )
            if not registryFetch( settings.name ) then error("Stage must be built before drawing") end
            draw()
        end

        function new.setColorFilter( filterName )
            settings.filter = filterName
        end

        function new.getType() return "stage" end

        function new.getActive() return settings.active end

        function new.setBufferLevel( self, v )
            settings.bufferLevel = v
        end
        function new.getBufferLevel( self )
            return settings.bufferLevel
        end

        function new.getPos( self ) return settings.x, settings.y end 

        function new.setPos( self, nX, nY ) settings.x, settings.y = nX, nY end

        function new.getWidth() return settings.width end
        function new.getHeight() return settings.height end

        function new.setBorderless( self, v ) 
            settings.borderless = v
        end
        function new.getBorderless( self ) 
            return settings.borderless
        end

        function new.setCloseButton( self, v ) 
            settings.closeButton = v
        end
        function new.getCloseButton( self ) 
            return setting.closeButton
        end

        function new.getFullscreen( self ) 
            return settings.fullscreen 
        end
        function new.setFullscreen( self, v ) 
            settings.fullscreen = v 
        end

        function new.setMoveable( self, v ) 
            settings.moveable = v
        end
        function new.getMoveable( self ) 
            return settings.moveable
        end

        function new.setBorderBackgroundColor( self, v ) 
            settings.borderBackgroundColor = v
        end
        function new.getBorderBackgroundColor( self ) 
            return settings.borderBackgroundColor
        end

        function new.setBorderTextColor( self, v ) 
            settings.borderTextColor = v
        end
        function new.getBorderTextColor( self ) 
            return settings.borderTextColor
        end

        function new.setBorderCloseBackgroundColor( self, v ) 
            settings.borderCloseBackgroundColor = v
        end
        function new.getBorderCloseBackgroundColor( self ) 
            return settings.borderCloseBackgroundColor
        end

        function new.setBorderCloseTextColor( self, v ) 
            settings.borderCloseTextColor = v
        end
        function new.getBorderCloseTextColor( self ) 
            return settings.borderCloseTextColor
        end

        function new.setBorderCloseText( self, v ) 
            settings.borderCloseText = v
        end
        function new.getBorderCloseText( self ) 
            return settings.borderCloseText
        end

        function new.setTitle( self, v ) 
            settings.title = v
        end
        function new.getTitle( self ) 
            return settings.title
        end

        function new.setTitleOverflow( self, v ) 
            settings.titleOverflow = v
        end
        function new.getTitleOverflow( self ) 
            return settings.titleOverflow
        end

        function new.setTitleCenter( self, v )
            setting.titleCenter = v
        end
        function new.getTitleCenter( self )
            return settings.titleCenter
        end

        function new.setFocus( self, v ) 
            if v then focus() else blur() end
        end
        function new.getFocus( self ) 
            return settings.isActive
        end

        function new.getName( self )
            return settings.name
        end

        function new.getFromRegistry( self )
            return registryFetch( self:getName() )
        end

        function new.updateToRegistry( self )
            registryUpdate( self )
        end

        function new.removeFromRegistry( self )
            registryRemove( self:getName() )
        end

        function new.setScene( self, v )
            if (type( v ) ~= "table") or ( (type( v ) == "table") and ( not v.getType or v.getType() ~= "scene" ) ) then
                error("Invalid scene target. A scene ([program].createScene()) must be created and passed to set a stages scene.", 2)
            end
            settings.scene = v
            settings.scene:setStage( self ) -- scene is now bound.
        end

        function new.getScene( self )
            return settings.scene
        end

        function new.setMinWidth( self, v ) settings.minWidth = v end
        function new.getMinWidth() return settings.minWidth end
        local dragging = false
        local lastMoveX, lastMoveY = false, false

        local function handleMouseClick( self, event )
            local button, nX, nY = event[2], event[3], event[4]
            local offset = (function() if settings.borderless then return 0 else return 1 end end)()

            if nX < settings.x or nX > settings.x + settings.width - 1 or nY < settings.y or nY > settings.y + settings.height + offset then return end

            local onNode = false

            if settings.scene and type( settings.scene ) == "table" and settings.scene.getType and settings.scene.getType() == "scene" then
                local nodes = settings.scene.getNodes()
                local found = false
                for i = #nodes, 1, -1 do

                    if nodes[i].getContains and nodes[i]:getContains() then
                        nodes[i]:checkEvent( event, self )
                    end

                    local node = nodes[i]
                    local nodeX, nodeY = node.getPos()
                    local nodeW, nodeH = node.getWidth(), node.getHeight()

                    local x, y = nX - settings.x + 1, nY - settings.y + 1 - offset

                    if x >= nodeX and x <= nodeX + nodeW - 1 and y >= nodeY and y <= nodeY + nodeH - 1 and not found then

                        onNode = node
                        found = true

                    elseif node.blur and node.blurWhenNotClicked and node.blurWhenNotClicked() then 
                        node:blur( settings.name ) 
                    end

                end
            end
            if onNode and not (onNode.getContains and onNode.getContains() or false) then -- stops double submission to container nodes.
                -- Call the nodes onClick
                onNode:checkEvent( event, self )
            else

                -- however, if the click was not on a node or there is no scene, check for window functions
                if button == 1 and nX > settings.x and nX < settings.x + settings.width and nY == settings.y and not settings.borderless then
                    if nX == settings.x + settings.width - 1 and settings.closeButton then 
                        close() 
                        return 
                    end
                end
                if button == 1 and nX >= settings.x and nX <= settings.x + settings.width and nY == settings.y then
                    -- Clicked on top bar, set to move mode.

                    dragging = {
                        mode = "move",
                        event = event,
                        target = self,
                        x = event[3],
                        y = event[4]
                    }

                    lastMoveX, lastMoveY = nX, nY

                elseif button == 1 and nY == settings.y + settings.height - 1 and nX == settings.x + settings.width - 1 then

                    dragging = {
                        mode = "resize",
                        event = event,
                        target = self
                    }

                    lastResizeX, lastResizeY = nX, nY
                end

            end
        end

        local function handleMouseScroll()
            
        end

        local function handleMouseDrag( self, event )
            local button, nX, nY = event[2], event[3], event[4]
            local offset = (function() if not settings.borderless then return 0 else return 1 end end)()

            local function move( x, y )
                -- remap the area
                x = x or settings.x
                y = y or settings.y
                settings.visible = false
                mapWindow()
                settings.x = x
                settings.y = y
                settings.visible = true
                --cache.forceRedraw = true
                runCallback("reposition")
                mapWindow()
            end

            local function resize( width, height )
                width = width or settings.width
                height = height or settings.height
                settings.visible = false
                mapWindow()
                settings.width = width
                settings.height = height
                settings.visible = true
                resetBuffer()
                cache.forceRedraw = true
                runCallback("resize")
                mapWindow()
            end

            if type( dragging ) == "table" and dragging.mode == "move" and settings.moveable and settings.active then
                if nX < lastMoveX and (settings.allowOffScreen or settings.x - 1 > 0) then
                    
                    move( settings.x + event[3] - lastMoveX )
                    
                elseif nX > lastMoveX and ( settings.allowOffScreen or settings.x + settings.width - 1 < termX ) then
                    
                    move( settings.x + event[3] - lastMoveX )
                    
                end
                if nY < lastMoveY and (settings.allowOffScreen or settings.y - 1 > 0) then
                    
                    move( nil, settings.y + event[4] - lastMoveY )
                    
                elseif nY > lastMoveY and (settings.allowOffScreen or nY + settings.height - 1 - offset < termY) then
                    
                    move( nil, settings.y + event[4] - lastMoveY )
                    
                end
                lastMoveX, lastMoveY = nX, nY
            elseif type( dragging ) == "table" and dragging.mode == "resize" and settings.active then
                
                local oW, oH = settings.width, settings.height
                if nX < lastResizeX and settings.width - 1 > 0 and settings.width - 1 >= settings.minWidth then
                    resize( settings.width + event[3] - lastResizeX )
                elseif nX > lastResizeX and settings.x + settings.width - 1 < termX and settings.width < settings.maxWidth then
                    resize( settings.width + event[3] - lastResizeX )
                end
                if nY < lastResizeY and settings.height - 1 > 0 and settings.height > settings.minHeight then
                    resize( nil, settings.height + event[4] - lastResizeY )
                elseif nY > lastResizeY and settings.y + settings.height - 1 - offset < termY and settings.height < settings.maxHeight then
                    resize( nil, settings.height + event[4] - lastResizeY )
                end
                lastResizeX, lastResizeY = nX, nY
            end
        end

        local function handleKeyPress( self, event )
            if settings.scene and settings.scene.getNodeFocus() then
                settings.scene.getNodeFocus():checkEvent( event, self )
            end
        end

        local function handleMouseUp( self, event )
            if dragging then dragging = false end
            if settings.scene then
                local nodes = settings.scene:getNodes()
                for i = 1, #nodes do
                    local node = nodes[i]
                    node:checkEvent( event, self )
                end
            end
        end

        local function handleCharPress( self, event )
            if settings.scene.getNodeFocus() then
                settings.scene.getNodeFocus():checkEvent( event, self )
            end
        end

        function new.runEvent( self, event )
            local e, p1, p2, p3 = event[1], event[2], event[3], event[4]
            runCallback("event", event )

            if settings.scene then settings.scene:checkEvent( event, self ) end

            if e == "deactivate" then
                if p1 == settings.name then focus() else blur() end
            end
            if not dialog and settings.active then
                if e == "mouse_click" then
                    handleMouseClick( self, event )
                elseif e == "mouse_scroll" then
                    handleMouseScroll( self, event )
                elseif e == "mouse_drag" then
                    handleMouseDrag( self, event )
                elseif e == "mouse_up" then
                    handleMouseUp( self, event )
                elseif e == "key" then
                    handleKeyPress( self, event )
                elseif e == "char" then
                    handleCharPress( self, event )
                elseif e == "terminate" and settings.allowTerminate then
                    if runningProgram then terminate()
                    else close() end
                end
            elseif dialog and settings.active and e == "mouse_click" then
                local dX, dY = dialog.getPos()
                if p2 < dX or p2 > dX + dialog.getWidth() - 1 or p3 < dY or p3 > dY + dialog.getHeight() - 1 and ( p2 >= settings.x and p2 <= settings.x + settings.width - 1 and p3 >= settings.y and p3 <= settings.y + settings.height ) then
                    -- flash dialog
                    dialog.attentionFlash()
                end
            end

            if e == "mouse_click" and registryFetch(settings.name) then
                local high = getHighestLevel( p2, p3 )
                if high then
                    if high.getType() == "stage" then
                        if p2 >= settings.x and p2 <= settings.x + settings.width - 1 and p3 >= settings.y and p3 <= settings.y + settings.height and high.getName() == settings.name then
                            if not settings.active then focus() end
                        elseif settings.active then blur() end
                    elseif high.getType() == "dialog" and high.getBind().getName() == settings.name then
                        local dX, dY = high.getPos()
                        if p2 >= dX and p2 <= dX + high.getWidth() - 1 and p3 >= dY and p3 <= dY + high.getHeight() - 1 then
                            if not settings.active then focus() end
                        elseif settings.active then blur() end
                    elseif high then
                        if (high.getType() == "stage" and high.getName() ~= settings.name) or (high.getType() == "dialog" and high.getBind().getName() ~= settings.name) and settings.active then blur() end
                    end
                elseif settings.active then blur() end
            end

        end

        function new.destroy( self )
            registryRemove( settings.name )
            removeBufferRequestFromQueue( settings.name )
        end

        function new.build( self )
            registryUpdate( self )
            --reorderBufferLevels( settings.name )
            addReorderRequestToQueue( settings.name ) -- tells DynaCode to reorder the stages with this one on top.
            os.queueEvent( "deactivate", settings.name ) -- deactivates all stages except the specified stage.
            queueRedraw( self )
        end

        function new.getAnimationProperty( property )
            if settings[property] then return settings[property] else error("Cannot find: "..tostring( property ) .. " on stage", 2) end
        end

        function new.setAnimationProperty( target, setting, value )
            if settings[setting] then settings[setting] = value else error(setting.." not found in stage object") end
        end

        function new.getDisabledFilter( self, stage )
            if settings.disabledFilter then return settings.disabledFilter else return "_NORMAL" end
        end
        return new

    end

    local function setAnimationProperty( target, setting, value, settings, private )
        local function map()
            private.mappingFunction( settings.x, settings.x + settings.width - 1, settings.y, settings.y + settings.height - 1 )
        end
        settings.visible = false
        map()
        if settings[setting] then settings[setting] = value else error(setting.." not found in object") end
        settings.visible = true -- Set the flag to true so DynaCode will map this node instead of setting its space to blank.
        map()

    end

    function clone.createPane( cfg )

        local nodeRequiredMethods = {
            "getPos",
            "setPos",
            "drawToTable",
            "setScene",
            "checkEvent",
            "getHeight",
            "getWidth",
            "setParent",
            "getParent",
            "needsRedraw",
            "setRedraw",
            "getVisible",
            "setVisible",
            "init",
            "remap"
        }

        cfg = convertOptions({
            ["x"] = "number",
            ["y"] = "number",
            ["width"] = "number",
            ["height"] = "number",
            ["enabled"] = "boolean",
            ["overflowX"] = "boolean",
            ["overflowY"] = "boolean",
            ["visible"] = "boolean"
        }, cfg)
        local xmlCallbacks = {
            ["button"] = clone.createButton,
            ["label"] = clone.createLabel,
            ["pane"] = clone.createPane,
            ["input"] = clone.createInput
        }
        --[[
            A pane can contain nodes, a pane is itself a node and should be added to a scene. Any nodes within the pane are drawn relative to the panes position
            allowing one to animate the pane, resulting in its contents moving as well.

            One may imagine it as a mini stage settable via XML.

            <pane x="1" y="1">
                <button></button>
                <label></label>
            </pane>
        ]]
        local paneDefaults = {
            width = 10,
            height = 5,
            backgroundColor = "white",
            textColor = "black",
            x = 1,
            y = 1,
            filter = false,
            disabledFilter = false,
            enabled = true,
            overflowX = true,
            overflowY = true,
            scrollBarBackgroundColor = "lightGray",
            scrollBarTextColor = "gray",
            visible = true
        }
        local settings = {}
        setmetatable( cfg, {__index=paneDefaults} )
        setmetatable( settings, {__index=cfg} )
        local private = {
            nodes = {},
            scrollbar = {
                horizontal = {
                    width = 0,
                    offset = 0
                },
                vertical = {
                    height = 0,
                    offset = 0
                }
            },
            color = {
                raw = { bg = false, tc = false, sbg = false },
                processed = { bg = false, tc = false, sbg = false }
            },
            needsRedraw = true,
            ID = false,
            mappingFunction = function() error("Not set") end
        }
        local new = {}

        local nodeMap = {}
        local nodeCanvas = {}

        local function formMap()
            for y = 1, settings.height do
                nodeMap[y] = {}
                for x = 1, settings.width do
                    nodeMap[y][x] = { "init" }
                end
            end
        end
        formMap()

        local function mapNodes( x1, x2, y1, y2 )
            -- Create a map of the nodeCanvas, each point on the map will contain the ID of the node.
            local layers = nodeMap
            local nodes = private.nodes

            local background = colors.red

            for i = #nodes, 1, -1 do

                local node = nodes[i]
                local nodeID = node:getID()
                local visible = node:getVisible()

                local nodeX1, nodeY1 = node:getPos()
                local nodeX2, nodeY2 = nodeX1 + node:getWidth() - 1, nodeY1 + node:getHeight() - 1
                log("Mapping node: "..tostring( node ).."("..tostring( node:getName() )..", "..tostring( node.getType and node:getType() or "nil" )..")  "..tostring( nodeX1 )..", "..tostring( nodeY1 )..". "..tostring(nodeX2)..", "..tostring(nodeY2)..". visible: "..tostring(visible).." ID: "..tostring(nodeID), "w")

                if not (nodeX1 > x2 or nodeY1 > y2 or x1 > nodeX2 or y1 > nodeY2) then
                    
                    for y = math.max(nodeY1, y1), math.min(nodeY2, y2) do

                        local layerY = layers[y]
                        if layerY then
                            for x = math.max(nodeX1, x1), math.min(nodeX2, x2) do
                                local layerX = layerY[x]

                                if layerX then

                                    if ( layerX ~= nodeID ) and visible then

                                        nodeMap[y][x] = nodeID
                                    elseif layerX == nodeID and not visible then

                                        nodeMap[y][x] = 0
                                    end
                                end
                            end
                        end
                    end

                    if visible then node.setRedraw( true ) end
                end
            end

            --clone.file.write("hex/etc/dump/nodeLayers", textutils.serialize( nodeMap ))


            local buffer = nodeCanvas
            for y = y1, y2 do
                local layerY = nodeMap[y]
                for x = x1, x2 do
                    if layerY and layerY[x] and (layerY[x] == 0 or layerY[x] == "init") then
                        local b = buffer[y][x]
                        b[1] = false
                        b[2] = false
                        b[3] = false
                    end
                end
            end
        end

        function new:init()
            if private.parent then

                for i = 1, #private.nodes do
                    private.nodes[i]:init()
                end

                local t = private.parent.getType()
                if t == "scene" then
                    private.mappingFunction = private.parent.getStage().mapNodes
                else
                    private.mappingFunction = private.parent.mapNodes
                end

                if not private.ID then
                    local pNode = private.parent.getNodes()
                    local n = pNode[ #pNode ]
                    if n then private.ID = (n:getID() or 0) + 1 log("PANE ID: "..tostring( private.ID ) ) else log("ID for pane failed fetch: "..tostring( textutils.serialize( pNode ) ) ) private.ID = 1 end
                end


            else log("Cannot initialize pane node. No parent set", "e") end
        end

        function new.mapNodes( x1, x2, y1, y2 ) mapNodes( x1, x2, y1, y2 ) end

        function new.getID() return private.ID end

        function new.getVisible() return settings.visible end
        function new:setVisible( bool ) settings.visible = bool end

        function new.handleXML( self, content )
            -- Get the inner nodes, if a node can contain other nodes, add the node and pass it the XML to handle.
            for key, xml in ipairs( content ) do
                -- find this panes content (main label is this pane)
                if key ~= "label" and key ~= "content" and key ~= "xargs" and type( xml ) == "table" then
                    if xmlCallbacks[xml.label] then
                        local args = xml.xarg
                        if xml.label == "button" or xml.label == "label" then if xml.content then args.text = xml.content end end
                        local node = xmlCallbacks[xml.label]( args )
                        if not node or type( node ) ~= "table" then error("Invalid callback response for "..tostring( xml.label ).." creation, response: "..tostring( node )) end
                        for key, func in ipairs( nodeRequiredMethods ) do
                            if not node[func] then error("Node ("..xml.label..") missing function: "..func..", check DynaCode Developer Assistance for more information") end
                        end
                        node:setScene( private.scene )
                        node:setParent( self )
                        if node.getContains and type( node.getContains ) == "function" and node.getContains() then
                            node:handleXML( xml )
                        end
                        table.insert( private.nodes, node )
                    else error("Unknown node: "..xml.label) end
                end
            end
        end

        -- Needs methods for adding, removing and getting nodes from within
        function new.addNode( self, v )
            local node = v

            node:setParent( self )
            node:setScene( private.scene )
            node:init()

            private.nodes[ #private.nodes + 1 ] = node
        end
        function new.removeNode( self, v )

            for i = 1, #private.nodes do
                local node = private.nodes[i]

                if node:getName() == tostring( v ) or node == v then -- if a string, does name match? If its a node, are they the same?
                    table.remove( private.nodes, i )
                end

            end

        end
        function new.getNode( self, v )
            for i, node in ipairs( private.nodes ) do
                if node:getName() == v then return node end
            end
        end
        function new.clearNodes( self )
            for i = 1, #private.nodes do
                local node = private.nodes[i]

                node:setParent( nil )
                node:setScene( nil )

                table.remove( private.nodes, i )

            end
        end
        function new.getNodes( self ) return private.nodes end

        function new.getEnabled() return settings.enabled end

        function new.getDisabledFilter( self, stage )
            if settings.disabledFilter then return settings.disabledFilter else
                -- return the parents disabled filter.
                if private.parent then
                    return private.parent:getDisabledFilter( stage )
                else error("No parent: "..tostring( settings.name )) end
            end
        end

        function new.getTotalEnabled()
            if private.parent then 
                if settings.enabled then
                    return private.parent:getTotalEnabled() 
                else
                    return false
                end
            else error("No parent: "..tostring( settings.name ) ) end
        end


        function new.setScene( self, v ) private.scene = v end
        function new.getScene( self ) return private.scene end

        function new.setParent( self, v ) 
            private.parent = v
        end
        function new.getParent() return private.parent end

        local function handleScrollClick( relX, relY )
            
        end

        function new.needsRedraw() return private.needsRedraw end
        function new.setRedraw( v ) private.needsRedraw = v end

        local function calculateBarSize( ver, hor, verContent, horContent )
            local vTray = settings.height
            if hor then vTray = vTray - 1 end
            local hTray = settings.width
            if ver then vTray = vTray - 1 end

            private.scrollbar.vertical.height = math.ceil( ( vTray * settings.height ) / verContent )
            private.scrollbar.horizontal.width = math.ceil( ( hTray * settings.width ) / horContent )
        end

        local function updateCanvas()
            for y = 1, settings.height do
                nodeCanvas[y] = {}
                for x = 1, settings.width do
                    nodeCanvas[y][x] = { false, false, false }
                end
            end
        end
        updateCanvas()

        local function remap()
            private.mappingFunction( settings.x, settings.x + getWidth() - 1, settings.y, settings.y + settings.height - 1 )
        end

        function new.handleDraw( canvas, maxWidth, maxHeight, yOffset, caller )
            -- redraw each node into a nodeCanvas IF it needs to be updated. Otherwise don't update it.
            -- If no node is in the position, pass the background color of the pane.
            local nodes = private.nodes
            for i = 1, #nodes do
                local node = nodes[i]
                if node:needsRedraw() or private.forceRedraw then
                    node.drawToTable( nodeCanvas, maxWidth, maxHeight, yOffset, caller )
                end
            end
            private.forceRedraw = false

            local cl = caller.getColor( settings.backgroundColor )
            for y = 1, settings.height do
                if y + settings.y - 1 > maxHeight then break end
                for x = 1, settings.width do
                    if x + settings.x - 1 <= maxWidth then
                        if nodeCanvas[y][x][1] then
                            local c = canvas[y + settings.y - 1][x + settings.x - 1]
                            local n = nodeCanvas[y][x]
                            c[1] = n[1]
                            c[2] = n[2]
                            c[3] = n[3]
                        else
                            local c = canvas[y + settings.y - 1][x + settings.x - 1]
                            c[1] = " "
                            c[2] = cl
                            c[3] = cl
                        end
                    end
                end
            end

            if private.forceRedraw or private.remap then -- no need to remap every time.
                --[[if private.parent.getType() == "scene" then
                    caller.mapNodes( settings.x, settings.x + settings.width - 1, settings.y, settings.y + settings.height - 1 )
                else
                    private.parent.mapNodes( settings.x, settings.x + settings.width - 1, settings.y, settings.y + settings.height - 1 )
                end]]
                remap()
                private.remap = false
            end
        end

        function new:remap()
            remap()
        end

        function new.drawToTable(tBuffer, nWidth, nHeight, nOffset, util)
   
            --[[local contentHeight, contentWidth, contentRight, contentLeft, contentTop, contentBottom = 0, 0, 0, 0, 0, 0

            for i = 1, #private.nodes do
                local node = private.nodes[i]

                local x, y = node:getPos()
                if settings.overflowX then
                    -- Get the width of the nodes, if they overlap the panesWidth then add them.
                    -- If the X is < 1 then its off the pane to the left so add it to contentLeft.
                    if x < 1 then
                        local temp = 0
                        if x < 0 then
                            contentLeft = contentLeft > x and x or contentLeft
                        else
                            contentLeft = contentLeft < x and x or contentLeft
                        end
                    else
                        local temp = x + node:getWidth() - 1
                        if temp > settings.width then
                            contentRight = contentRight < ( temp - settings.width ) and temp - settings.width or contentRight
                        end
                    end
                end
                if settings.overflowY then
                    if y < 1 then
                        if y < 0 then
                            contentTop = y < contentTop and y or contentTop
                        else
                            contentTop = contentTop > y and y or contentTop
                        end
                    else
                        if y + node:getHeight() > settings.height then
                            contentTop = contentTop < ( y + node:getHeight() - settings.height ) and y + node:getHeight() - settings.height or contentTop
                        end
                    end
                end
            end
            if contentLeft < 0 then
                contentWidth = contentWidth + ( contentLeft * -1 )
            else
                contentWidth = contentWidth + contentLeft
            end
            contentWidth = contentWidth + contentRight + settings.width
            
            if contentTop < 0 then
                contentHeight = contentHeight + ( contentTop * -1 )
            else
                contentHeight = contentHeight + contentTop
            end
            contentHeight = contentHeight + contentBottom + settings.height

            -- We now have the height and width of the content.
            local hScroll, vScroll = false, false
            if contentHeight > settings.height then vScroll = true end
            if contentWidth > settings.width then hScroll = true end

            calculateBarSize( vScroll, hScroll, contentHeight, contentWidth )
            private.scrollbar.horizontal.offset = ( contentLeft < 0 and contentLeft * -1 ) or contentLeft
            private.scrollbar.vertical.offset = ( contentTop < 0 and contentTop * -1 ) or contentTop
            --log("Pane scrollbar size: "..private.scrollbar.vertical.height..", "..private.scrollbar.horizontal.width)]]

            local gc = util.getColor
            local bg, tc, sbg = gc( settings.backgroundColor ), gc( settings.textColor ), 1
            if hScroll or vScroll then
                sbg = gc( settings.scrollBarBackgroundColor )
            end


            local nBuffer = {}
            for y = 1, nHeight do nBuffer[y] = {} for x = 1, nWidth do nBuffer[y][x] = {} end end
            for i = 1, #private.nodes do
                local node = private.nodes[i]
                node.drawToTable( nBuffer, nWidth, nHeight, nOffset, util )
            end
            
            local nY, nX
            for y = 1, settings.height do
                if y + settings.y - 1 > nHeight then break
                elseif y + settings.y - 1 > 0 then
                    for x = 1, settings.width do

                        nY = nBuffer and nBuffer[y] or false
                        if nY then nX = nY[x] end

                        if x + settings.x - 1 <= nWidth then
                            if vScroll and x == settings.width and ( not hScroll or y < settings.height ) then
                                -- is the scroll bar here?
                                local scroll = private.scrollbar.vertical
                                if y >= scroll.offset and y <= scroll.height + scroll.offset + 1 then
                                    tBuffer[ settings.y + y - 1 ][ settings.x + x - 1 ] = { " ", sbg, sbg, nDefined = true}
                                else
                                    tBuffer[ settings.y + y - 1 ][ settings.x + x - 1 ] = { " ", sbg, sbg, nDefined = true}
                                end
                            elseif hScroll and y == settings.height and ( not vScroll or x < settings.width ) then
                                local scroll = private.scrollbar.horizontal
                                if x >= scroll.offset and x <= scroll.width + scroll.offset + 1 then
                                    tBuffer[ settings.y + y - 1 ][ settings.x + x - 1 ] = { " ", sbg, sbg, nDefined = true}
                                else
                                    tBuffer[ settings.y + y - 1 ][ settings.x + x - 1 ] = { " ", sbg, sbg, nDefined = true}
                                end
                            elseif nX and nX[1] then
                                tBuffer[ settings.y + y - 1 ][ settings.x + x - 1 ] = { nX[1], nX[2], nX[3], nDefined = true }
                            else
                                tBuffer[ settings.y + y - 1 ][ settings.x + x - 1 ] = { " ", tc, bg, nDefined = true }
                            end
                        end
                    end
                end
            end
        end
        function new.getWidth( self ) return settings.width end
        function new.getHeight( self ) return settings.height end
        function new.getPos( self, v ) return settings.x, settings.y end
        function new.setPos( self, nX, nY ) settings.x, settings.y = nX, nY end

        function new.checkEvent( self, event, stage )
            --if true then return end
            if event[1] == "mouse_click" then
                --if event[2] == 1 then
                    local found = false
                    for key, node in ipairs( private.nodes ) do
                        if node.getContains and node.getContains() then
                            node:checkEvent( event, stage )
                        else
                            local xOffset, yOffset, amount, last = getTotalOffset( node )
                            local nX, nY = node.getPos()
                            local nHeight, nWidth = node.getHeight(), node.getWidth()
                            local sX, sY = stage.getPos()
                            local x = event[3] - sX - xOffset + amount + 1
                            local y = event[4] - sY - yOffset + amount

                            if stage.getBorderless() then y = y + 1 end

                            if x >= nX and x <= nX + nWidth - 1 and y >= nY and y <= nY + nHeight - 1 and not found then
                                node:checkEvent( event, stage )
                                found = true
                            elseif node.blur and node.blurWhenNotClicked and node.blurWhenNotClicked() then 
                                node:blur( stage ) 
                            end
                        end
                    end
                --end
            else
                local nodes = private.nodes
                for i = 1, #nodes do
                    nodes[i]:checkEvent( event, stage )
                end
            end
        end

        function new.getContains() return true end
        function new.sendAllEvents() return true end

        function new.getName() return settings.name end
        function new.getType() return "pane" end

        function new.getAnimationProperty( property )
            if settings[property] then return settings[property] else error("Cannot find: "..tostring( property ) .. " on pane", 2) end
        end

        function new.setAnimationProperty( target, setting, value )
            --[[settings.visible = false
            local mapFunc = function() error("feature not implemented") end
            if private.parent.getType() == "scene" or private.parent.getType() == "pane" then
                mapFunc = private.parent.getStage().mapNodes
            end
            local function map()
                mapFunc( settings.x, settings.x + settings.width - 1, settings.y, settings.y + settings.height - 1 )
            end
            map()
            if settings[setting] then settings[setting] = value else error(setting.." not found in pane object") end
            settings.visible = true
            private.remap = true
            --map()
            --(private.scene):setRedrawStatus( true )]]
            setAnimationProperty( target, setting, value, settings, private )
        end

        return new
    end

    function clone.createScene( cfg )
        local xmlCallbacks = {
            ["button"] = clone.createButton,
            ["label"] = clone.createLabel,
            ["pane"] = clone.createPane,
            ["input"] = clone.createInput
        }
        local nodeRequiredMethods = {
            "getPos",
            "setPos",
            "drawToTable",
            "setScene",
            "checkEvent",
            "getHeight",
            "getWidth",
            "setParent",
            "getParent",
            "needsRedraw",
            "setRedraw",
            "getVisible",
            "setVisible",
            "init",
            "remap"
        }
        validateRequirements({ "name" }, cfg, false, "The following options must be defined:\n", "\nPlease define these settings when creating your scene.")
        local sceneDefault = {}
        local new = {}
        local settings = {}
        local private = {
            nodes = {},
            controller = {},
            needsRedraw = true,
            nodeFocus = false,
            tabOrder = {},
            tabIndex = 1,
            lastIndex = false,
            redraw = {},
            stage = false
        }

        -- The scene is attached to a stage. The scene _can_ be used on multiple stages.

        -- If the scene is fetched from a stage, and changed it will affect all stages using the scene.

        -- If the scene is changed from a local variable, and changed it will also affect all stages using this scene.

        setmetatable( sceneDefault, {__index=defaults})
        setmetatable( cfg, {__index=sceneDefault})
        setmetatable( settings, {__index = cfg})

        local function init( node )
            if private.stage then
                node:init()
            end
        end


        local function registryUpdate( self )
            for k, v in ipairs( objects.scenes ) do
                if v and type(v) == "table" then
                    if v:getName() == settings.name then
                        table.remove( objects.scenes, k )
                    end
                end
            end

            table.insert( objects.scenes, self )
        end

        local function reorderTabIndex()
            private.tabOrder = {}
            for _, node in ipairs( private.nodes ) do
                if node.getTabIndex and node.getTabIndex() then
                    if not node.blur or not node.focus then error("TabIndexed node requires blur and focus methods.") else
                        table.insert( private.tabOrder, node )
                    end
                end
            end
            table.sort( private.tabOrder, function( a, b ) return a.getTabIndex() < b.getTabIndex() end )
        end
        local function nextTabIndex( stage )
            reorderTabIndex()
            if private.tabOrder[private.tabIndex+1] then
                if private.lastIndex then private.lastIndex:blur( stage ) end
                private.lastIndex = private.tabOrder[private.tabIndex+1]
                private.tabIndex = private.tabIndex + 1
                private.tabOrder[private.tabIndex]:focus( stage )
            elseif private.tabOrder[1] then
                if private.lastIndex then private.lastIndex:blur( stage ) end
                private.lastIndex = private.tabOrder[1]
                private.tabOrder[1]:focus( stage )
                private.tabIndex = 1
            end
        end
        local function setTabIndex( node )
            -- find the node in the tabOrder and set the tabIndex to its key.
            reorderTabIndex()
            for _, n in ipairs( private.tabOrder ) do
                if n == node then
                    private.tabIndex = _
                    private.lastIndex = n
                    break
                end
            end
            return private.tabIndex
        end
        function new.setTabIndex( self, node ) return setTabIndex( node ) end
        local function previousTabIndex() end

        local function initializeNodes()
            for i = 1, #private.nodes do
                private.nodes[i]:init()
            end
        end

        local function getXML( path )

            local function processNode( xml )
                -- fully create the node, buttons and other objects do not require a name mainly because they are always stored inside the scene. Although without a name specified scene.getNode(string Name) will not work (throws Exception)
                local args = xml.xarg
                if xml.label == "button" or xml.label == "label" then if xml.content then args.text = xml.content end end
                local node = xmlCallbacks[xml.label]( args )
                if not node or type( node ) ~= "table" then error("Invalid callback response for "..tostring( xml.label ).." creation, response: "..tostring( node )) end
                for key, func in ipairs( nodeRequiredMethods ) do
                    if not node[func] then error("Node ("..xml.label..") missing function: "..func..", check DynaCode Developer Assistance for more information") end
                end
                node:setScene( new )
                node:setParent( new )
                init( node )
                if node.getContains and type(node.getContains) == "function" and node.getContains() then
                    node:handleXML( xml )
                end
                return node
            end

            if fs.exists( path ) then
                local f = fs.open( path, "r" )
                local content = f.readAll()
                f.close()
                content = XMLStringToTable( content )
                if #content <= 0 then return false else
                    -- check if an XML tag (label) is valid.
                    local nodes = {}
                    for key, xml in pairs( content ) do
                        local valid = false
                        if not xmlCallbacks[xml.label] then error("Unknown node: "..xml.label) else
                            table.insert( nodes, processNode(xml) )
                        end
                    end
                    return nodes
                end
            else
                error("dcml file "..tostring( path ).." doesn't exist")
            end

        end
        function new.process( self, stage, over, buffer )
            error("Function deprecated", 2)
            --for y = 1, stage:getHeight() do buffer[y] = {} for x = 1, stage:getWidth() do buffer[y][x] = { " ", 1, colors.red } end end
            -- Request a node for an update. Each node will return either a new or previous buffer
            local offset = ( stage:getBorderless() and 0 ) or -1
            for i = 1, #private.nodes do
                local node = private.nodes[i]
                node.drawToTable( buffer, stage:getWidth(), stage:getHeight(), offset, stage )
            end
            return buffer
        end

        function new.getStage() return private.stage end
        function new:setStage( stage )
            private.stage = stage
            initializeNodes()
        end

        local function getFromController( sName )
            return private.nodes[sName] or false
        end
        local function removeFromController( sName )
            private.controller[sName] = nil
            reorderTabIndex()
        end
        local function addToController( sName, fnFunction )
            private.controller[sName] = fnFunction
            reorderTabIndex()
        end

        function new.runFromController( name, ... )
            if private.controller and type( private.controller[name] ) == "function" then
                private.controller[name](...)
            end
        end

        function new.getController( self ) return private.controller end
        function new.setController( self, v ) private.controller = v end

        function new.addToController( self, sName, fnFunction ) addToController( sName, fnFunction ) end
        function new.removeFromController( self, sName ) removeFromController( sName ) end

        function new.getFromController( self, sName ) return getFromController( sName ) end

        function new.getType() return "scene" end

        function new.getName() return settings.name end

        function new.getTotalEnabled( self )
            return true
        end

        function new.replaceWithFile( self, path )
            local nodes = getXML( path )
            if nodes then
                private.nodes = nodes
            else error("DCML file empty") end
            --initializeNodes()
            reorderTabIndex()
        end
        function new.appendFromFile( self, path )
            local nodes = getXML( path )
            if nodes then
                for key, node in ipairs( nodes ) do
                    table.insert( private.nodes, node )
                end
                reorderTabIndex()
            else error("DCML file empty") end
            --initializeNodes()
        end

        function new.getRedrawStatus( self )
            return private.needsRedraw
        end
        function new.setRedrawStatus( self, v )
            private.needsRedraw = v
        end

        function new.addNode( self, v )
            local node = v
            node:setParent( self )
            node:setScene( self )
            init( node )
            private.nodes[ #private.nodes + 1 ] = node
        end
        function new.removeNode( self, v )
            for i = 1, #private.nodes do
                local node = private.nodes[i]
                if not node then log("Node missing in index "..i..".", "w") end
                if node and not node.getName then log("CORRUPT: Node does not contain method 'getName'. Crash imminent", "e") end
                if node:getName() == tostring( v ) or node == v then -- if a string, does name match? If its a node, are they the same?

                    node:setVisible( false )
                    node:remap()

                    node:setParent( nil )
                    node:setScene( nil )

                    node:setVisible( true )

                    table.remove( private.nodes, i )
                    log("Removed node!")
                    break
                end

            end
        end
        function new.clearNodes( self )
            for i = 1, #private.nodes do
                local node = private.nodes[i]
                node:setParent( nil )
                node:setScene( nil )
                table.remove( private.nodes, i )
            end
        end
        function new.getNodes( self )
            return private.nodes
        end

        function new.getNode( self, name )
            for key, node in ipairs( private.nodes ) do
                if node:getName() == name then return node end
            end
            return false
        end

        function new.getFromRegistry( self )
            return registryFetch( settings.name )
        end
        function new.updateToRegistry( self )
            registryUpdate( self )
        end
        function new.removeFromRegistry( self )
            registryRemove( settings.name )
        end

        function new.setNodeFocus( self, node )
            private.nodeFocus = node
        end
        function new.getNodeFocus( self ) 
            return private.nodeFocus
        end

        function new.checkEvent( self, event, stage )
            if event[1] == "key" and event[2] == keys.tab then nextTabIndex( stage ) end
        end

        function new.getDisabledFilter( self, stage )
            if settings.disabledFilter then return settings.disabledFilter else
                local s = assert( registryFetch( stage ), "Invalid stage: "..tostring( stage ))
                if s then return s:getDisabledFilter() end
            end
        end

        reorderTabIndex()
        registryUpdate( new )
        return new
    end

    function clone.createButton( cfg )
        if not cfg then error( "no cfg", 2 ) end
        cfg = convertOptions({
            ["name"] = "string",
            ["x"] = "number",
            ["y"] = "number",
            ["height"] = "number",
            ["maxWidth"] = "number",
            ["toggleable"] = "boolean",
            ["text"] = "string",
            ["toggleState"] = "boolean",
            ["toggleText"] = "string",
            ["padding"] = "number",
            ["visible"] = "boolean"
        }, cfg)
        validateRequirements({}, cfg)
        -- returns a new object
        local buttonDefaults = {
            x = 1,
            y = 1,
            width = "auto",
            padding = 0,
            height = 1,
            maxWidth = 20,
            backgroundColor = "white",
            textColor = "lightGray",
            disabledBackgroundColor = "gray",
            disabledTextColor = "black",
            text = "button",
            toggleable = true,
            toggleState = false,
            toggleText = "toggled button",
            toggleTextColor = "white",
            toggledBackgroundColor = "lightGray",
            activeTextColor = "lightGray",
            activeBackgroundColor = "gray",
            onClick = false,
            name = false,
            visible = true
        }
        local settings = { mappingFunction = function() error("Not set, set a node parent to map this node") end }
        setmetatable(settings, {__index=cfg})
        setmetatable(cfg, {__index=buttonDefaults})
        local needsRedraw = true
        local active = false

        local function getWidth()
            if settings.width == "auto" then
                if settings.toggleState and settings.toggleText then return #settings.toggleText + ( settings.padding * 2 ) else return #settings.text + ( settings.padding * 2 ) end
            elseif type( settings.width ) == "number" then 
                return settings.width
            else 
                error("Invalid Node Width")
            end
        end
        local new = {}

        local function queueRedraw()
            settings.scene:setRedrawStatus( true )
            needsRedraw = true
        end

        function new.queueRedraw() queueRedraw() end

        function new.drawToTable( tBuffer, nWidth, nHeight, nOffset, util )
            -- draw this node to the buffer.
            local textY, textX
            -- If the height of the button is greater than 1, calculate the Y at which the text will be drawn
            if settings.height > 1 then
                textY = math.floor( settings.height/2 ) + 1
            else
                textY = 1
            end
            textX = (function() if settings.padding <= 0 then return 1 else return settings.padding + 1 end end)()
            local tText = {}
            for cIndex = 1, len(settings.text) do
                tText[cIndex] = sub(settings.text, cIndex, cIndex)
            end

            local tc, bg
            if active then
                tc, bg = util.getColor( settings.activeTextColor ), util.getColor( settings.activeBackgroundColor )
            else
                tc, bg = util.getColor( settings.textColor ), util.getColor( settings.backgroundColor )
            end

            local tB

            for y = 1, settings.height do
                if y + settings.y - 1 - nOffset <= nHeight then
                    local bY = tBuffer[y+settings.y-1-nOffset]
                    for x = 1, getWidth() do
                        if x <= nWidth and tBuffer and bY and bY[x+settings.x-1] then
                            tB = bY[x+settings.x-1]
                            tB[1] = " "
                            tB[2] = tc
                            tB[3] = bg
                            tB.defined = true
                            -- if text is supposed to be here, don't overwrite it.
                            if x >= textX and x <= textX + #settings.text and y == textY then
                                tB[1] = tText[x-textX+1] or " "
                            end
                        end
                    end
                else break end
            end
        end

        function new.getVisible()
            return settings.visible
        end
        function new:setVisible( bool ) settings.visible = bool end

        function new.needsRedraw() return needsRedraw end
        function new.setRedraw( v ) needsRedraw = v end

        function new.setScene( self, scene )
            settings.scene = scene
            queueRedraw()
        end

        function new.getScene( self )
            return settings.scene
        end

        function new.setParent( self, v ) settings.parent = v
            if not settings.ID then
                local pNode = settings.parent.getNodes()
                local n = pNode and pNode[ #pNode ] or false
                if n then settings.ID = n:getID() + 1 else settings.ID = 1 end
            end
        end
        function new.getID() return settings.ID end
        function new.getParent() return settings.parent end

        function new.setPos( self, x, y ) settings.x, settings.y = x, y end

        function new.getPos( self ) return settings.x, settings.y end --relative to scene canvas (and stage too)

        function new.setWidth( self, v ) settings.width = v end
        function new.getWidth( self ) 
            return getWidth()
        end

        function new.setPadding( self, v ) settings.padding = v end
        function new.getPadding( self ) return settings.padding end

        function new.setHeight( self, v ) settings.height = v end
        function new.getHeight( self ) return settings.height end

        function new.setMaxWidth( self, v ) settings.maxWidth = v end
        function new.getMaxWidth( self ) return settings.maxWidth end

        function new.setBackgroundColor( self, v ) settings.backgroundColor = v end
        function new.getBackgroundColor( self ) return settings.backgroundColor end

        function new.setTextColor( self, v ) settings.textColor = v end
        function new.getTextColor( self ) return settings.textColor end

        function new.setText( self, v ) settings.text = v settings.scene:setRedrawStatus( true ) end
        function new.getText( self ) return settings.text end

        function new.setToggleable( self, v ) settings.toggleable = v end
        function new.getToggleable( self ) return settings.toggleable end

        function new.setToggleStage( self, v ) settings.toggleStage = v end
        function new.getToggleState( self ) return settings.toggleState end

        function new.setToggleBackgroundColor( self, v ) settings.toggleBackgroundColor = v end
        function new.getToggleBackgroundColor( self ) return settings.toggleBackgroundColor end

        function new.setToggleTextColor( self, v ) settings.toggleTextColor = v end
        function new.getToggleTextColor( self ) return settings.toggleTextColor end

        function new.setToggleText( self, v ) settings.toggleText = v end
        function new.getToggleText( self ) return settings.toggleText end

        function new.setOnClick() end
        function new.getOnClick() return settings.onClick end

        function new.checkEvent( self, event, stage )
            if event[1] == "mouse_click" then
                active = true
                queueRedraw()
                if type( settings.onClick ) == "function" then
                    settings.onClick( self )
                elseif type( settings.onClick ) == "string" then
                    if (settings.onClick):sub(1,1) == "#" then
                        settings.scene.runFromController( ( settings.onClick ):sub(2), self )
                    end
                end
            elseif event[1] == "mouse_up" then active = false queueRedraw() end
        end

        function new.getName() return settings.name end

        function new:remap()
            settings.mappingFunction( settings.x, settings.x + getWidth() - 1, settings.y, settings.y + settings.height - 1 )
        end

        function new:init()
            if settings.parent then
                local t = settings.parent.getType()
                if t == "scene" then
                    settings.mappingFunction = settings.parent.getStage().mapNodes
                else
                    settings.mappingFunction = settings.parent.mapNodes
                end

                self:remap()

            else log("Cannot initialize button node. Failed", "e") end
        end

        return new
    end

    function clone.createLabel( cfg )
        if cfg then 
            cfg = convertOptions({
                ["name"] = "string",
                ["x"] = "number",
                ["y"] = "number",
                ["text"] = "string",
                ["name"] = "string",
                ["visible"] = "boolean"
            }, cfg)
        else cfg = {} end
        validateRequirements({}, cfg)
        -- returns a new object
        local labelDefaults = {
            x = 1,
            y = 1,
            backgroundColor = "white",
            textColor = "lightGray",
            disabledBackgroundColor = "gray",
            disabledTextColor = "black",
            text = "label",
            name = false,
            visible = true
        }
        local settings = { mappingFunction = function() error("Not set. Set a node parent to map") end, height = 1 }
        setmetatable(settings, {__index=cfg})
        setmetatable(cfg, {__index=labelDefaults})
        local needsRedraw = true

        local function getWidth()
            return #settings.text
        end
        local new = {}

        local function queueRedraw()
            settings.scene:setRedrawStatus( true )
        end

        function new.queueRedraw() queueRedraw() end

        function new.drawToTable( tBuffer, nWidth, nHeight, nOffset, util )
            if type( util ) ~= "table" then error("Invalid self call", 2) end
            if settings.visible then
                local tText = {}
                for cIndex = 1, (settings.text):len() do
                    tText[cIndex] = (settings.text):sub(cIndex, cIndex)
                end
                local tc, bg = util.getColor( settings.textColor ), util.getColor( settings.backgroundColor )
                local tB = {}
                for x = 1, getWidth() do
                    if x <= nWidth and settings.y - nOffset <= nHeight and tBuffer and tBuffer[settings.y - nOffset] then
                        tB = tBuffer[settings.y - nOffset][x+settings.x-1]
                        if tB then
                            tB[1] = tText[x] or " "
                            tB[2] = tc
                            tB[3] = bg
                            tB.defined = true
                        end
                    else break end
                end
            end
        end

        function new.needsRedraw() return needsRedraw end
        function new.setRedraw( v ) needsRedraw = v end

        function new.getVisible() return settings.visible end
        function new:setVisible( bool ) settings.visible = bool end

        function new.setScene( self, scene )
            settings.scene = scene
        end

        function new.getScene( self )
            return settings.scene
        end

        function new.setParent( self, v ) settings.parent = v
            if not settings.ID then
                local pNode = settings.parent.getNodes()
                local n = pNode and pNode[ #pNode ] or false
                if n then settings.ID = n:getID() + 1 else settings.ID = 1 end
            end
        end
        function new.getID() return settings.ID end
        function new.getParent() return settings.parent end

        function new.setPos( self, x, y ) settings.x, settings.y = x, y end

        function new.getPos( self ) return settings.x, settings.y end --relative to scene canvas (and stage too)

        function new.getWidth( self ) 
            return getWidth()
        end

        function new.getHeight() return 1 end

        function new.setMaxWidth( self, v ) settings.maxWidth = v end
        function new.getMaxWidth( self ) return settings.maxWidth end

        function new.setBackgroundColor( self, v ) settings.backgroundColor = v end
        function new.getBackgroundColor( self ) return settings.backgroundColor end

        function new.setTextColor( self, v ) settings.textColor = v end
        function new.getTextColor( self ) return settings.textColor end

        function new.setText( self, v ) settings.text = v settings.scene:setRedrawStatus( true ) end
        function new.getText( self ) return settings.text end

        function new.checkEvent( self, event, stage )
            
        end

        function new:remap()
            settings.mappingFunction( settings.x, settings.x + getWidth() - 1, settings.y, settings.y + 2 )
        end

        function new:init()
            if settings.parent then
                local t = settings.parent.getType()
                if t == "scene" then
                    settings.mappingFunction = settings.parent.getStage().mapNodes
                else
                    settings.mappingFunction = settings.parent.mapNodes
                end
                self:remap()
            else log("Cannot initialize label node. Failed", "e") end
        end

        function new.getName() return settings.name end

        return new
    end

    function clone.createInput( cfg )
        -- focusable node. Only receives key/char events when focused
        cfg = convertOptions({
            ["x"] = "number",
            ["y"] = "number",
            ["width"] = "number",
            ["focused"] = "boolean",
            ["enabled"] = "boolean",
            ["visible"] = "boolean",
            ["tabIndex"] = "number",
            ["hidePlaceholderOnFocus"] = "boolean"
        }, cfg)
        local inputDefaults = {
            x = 1,
            y = 1,
            width = 10,
            replace = false,
            textColor = "gray",
            backgroundColor = "white",
            unfocusedTextColor = "white",
            unfocusedBackgroundColor = "gray",
            disabledTextColor = "white",
            disabledBackgroundColor = "black",
            focused = false,
            enabled = true,
            visible = true,
            xCenter = false,
            yCenter = false,
            value = "",
            onSubmit = false,
            onKeyPressed = false,
            onCharPressed = false,
            onFocus = false,
            onBlur = false,
            name = false,
            tabIndex = 1,
            limit = false,
            placeholder = false,
            placeholderFocusedTextColor = "lightGray",
            placeholderBlurredTextColor = "lightGray",
            hidePlaceholderOnFocus = false
        }
        local new, private, settings = {}, { scene = false, position = 0, mappingFunction = function() error("Not set. Set a node parent to map") end }, { height = 1 }
        setmetatable( cfg, {__index=inputDefaults})
        setmetatable( settings, {__index=cfg})

        if settings.limit then
            local limit = tonumber( settings.limit )
            if not limit and string.lower( settings.limit ) ~= "inf" and string.lower( settings.limit ) ~= "true" and string.lower( settings.limit ) ~= "false" then
                error("Input limit invalid. Limit must be either: true, false or a number")
            end
            if limit then settings.limit = limit end
        end

        local inputCallbacks = {
            ["submit"] = "onSubmit",
            ["key"] = "onKeyPressed",
            ["char"] = "onCharPressed",
            ["blur"] = "onBlur",
            ["focus"] = "onFocus"
        }

        local needsRedraw = true

        local function runCallback(self, name, tPass, keepPacked)

            if inputCallbacks[name] and settings[inputCallbacks[name]]then
                local cb = settings[inputCallbacks[name]]
                if type( cb ) == "function" then
                    if keepPacked or type( tPass ) ~= "table" then cb( self, tPass ) else cb( self, unpack( tPass ) ) end
                elseif type( cb ) == "string" then
                    if cb:sub(1,1) == "#" and private.scene then
                        if keepPacked or type( tPass ) ~= "table" then
                            private.scene.runFromController( cb:sub(2), self, tPass )
                        else
                            private.scene.runFromController( cb:sub(2), self, unpack( tPass ))
                        end
                    elseif not private.scene and cb:sub(1,1) then error("No scene object") end
                end
            end

        end

        local function getCallback( cb )
            return settings[inputCallbacks[cb]] or false
        end

        local function setCallback( cb, v )
            if inputCallbacks[cb] then
                settings[inputCallbacks[cb]] = v
            end
        end

        local function handleChar() end
        local function handleKey() end

        function new.getVisible()
            return settings.visible
        end
        function new:setVisible( bool ) settings.visible = bool end

        function new.drawToTable( tBuffer, nWidth, nHeight, nOffset, util )
            if settings.visible then
                local tText = {}
                if (settings.hidePlaceholderOnFocus and settings.focused) or #settings.value > 0 or not settings.placeholder then
                    for charIndex = 1, string.len( settings.value ) do if settings.replace then tText[charIndex] = settings.replace:sub(1,1) else tText[charIndex] = string.sub( settings.value, charIndex, charIndex ) end end
                elseif #settings.value == 0 and settings.placeholder and ( not settings.hidePlaceholderOnFocus or ( settings.hidePlaceholderOnFocus and not settings.focused ) ) then
                    for charIndex = 1, string.len( settings.placeholder ) do tText[charIndex] = string.sub( settings.placeholder, charIndex, charIndex ) end
                end
                local charStart = 1
                if private.position + 2 > settings.width then 
                    if type(settings.limit) ~= "number" then
                        if ( type( settings.limit ) == "string" and string.lower( settings.limit ) == "inf" ) or #settings.value ~= settings.width then
                            charStart = private.position - settings.width + 2
                        end
                    elseif type( settings.limit ) == "number" then
                        if #settings.value == settings.limit then
                            charStart = private.position - settings.width + 1
                        else
                            charStart = private.position - settings.width + 2
                        end
                    end
                end

                local tc, bg = settings.textColor, settings.backgroundColor
                if not settings.focused and settings.enabled then tc = settings.unfocusedTextColor bg = settings.unfocusedBackgroundColor elseif not settings.enabled then
                    tc = settings.disabledTextColor
                    bg = settings.disabledBackgroundColor
                end
                if settings.placeholder and len(settings.value) == 0 and settings.focused then
                    tc = settings.placeholderFocusedTextColor
                elseif settings.placeholder and len(settings.value) == 0 and not settings.focused then
                    tc = settings.placeholderBlurredTextColor
                end
                tc, bg = util.getColor( tc ), util.getColor( bg )
                local tB = {}
                for x = 1, settings.width do
                    if x <= nWidth and settings.y - nOffset <= nHeight and tBuffer and tBuffer[settings.y] then
                        tB = tBuffer[ settings.y - nOffset ][ x + settings.x - 1 ]
                        if tB then
                            tB[1] = tText[charStart + x - 1] or " "
                            tB[2] = tc
                            tB[3] = bg
                        end
                    else break end
                end
            end
        end

        function new.needsRedraw() return needsRedraw end
        function new.setRedraw( v ) needsRedraw = v end

        function new.getPos()
            return settings.x, settings.y
        end
        function new.setPos( self, x, y ) settings.x, settings.y = x, y end

        function new.getHeight() return 1 end
        function new.getWidth() return settings.width end

        function new.setWidth( self, v ) settings.width = v end

        function new.getTyped() end
        function new.setTyped() end

        function new:remap()
            private.mappingFunction( settings.x, settings.x + settings.width - 1, settings.y, settings.y + settings.height - 1 )
        end

        function new:init()
            if private.parent then
                local t = private.parent.getType()
                if t == "scene" then
                    private.mappingFunction = private.parent.getStage().mapNodes
                else
                    private.mappingFunction = private.parent.mapNodes
                end

                self:remap()

            else log("Cannot initialize input node. Failed", "e") end
        end

        function new.setScene( self, scene ) private.scene = scene end
        function new.setParent( self, v ) private.parent = v
            if not settings.ID then
                local pNode = private.parent.getNodes()
                local n = pNode and pNode[ #pNode ] or false
                if n then settings.ID = n:getID() + 1 else settings.ID = 1 end
            end
        end
        function new.getID() return settings.ID end
        function new.getParent() return private.parent end

        local function queueRedraw()
            needsRedraw = true
        end

        function new.checkEvent( self, event, stage )
            --local stage = assert( registryFetch( stage ), "Invalid stage: "..stage)
            if event[1] == "mouse_click" then
                if event[2] == 1 then

                    local xOffset, yOffset, amount, last = getTotalOffset( self )

                    local sX, sY = stage.getPos()

                    local x = event[3] - sX - xOffset + amount + 1
                    local y = event[4] - sY - yOffset + amount
                    if stage.getBorderless() then y = y + 1 end

                    if x >= settings.x and x <= settings.x + settings.width - 1 and y == settings.y then
                        if private.scene and settings.enabled then
                            --# Add focus
                            runCallback( self, "focus", event )
                            settings.focused = true
                            stage:getScene():setTabIndex( self )
                            stage:getScene():setNodeFocus( self )
                            queueRedraw()
                        end
                    else
                        if private.scene then
                            --# Remove focus
                            runCallback( self, "blur", event )
                            settings.focused = false
                            stage:getScene():setTabIndex( self )
                            private.scene:setNodeFocus( false )
                            queueRedraw()
                        else error("Scene object not found") end
                    end
                end
            elseif event[1] == "char" then
                runCallback( self, "char", event )
                if settings.focused then
                    if ( type( settings.limit ) == "number" and #settings.value < settings.limit ) or ( type( settings.limit ) == "string" and settings.limit == "inf" ) or ( type( settings.limit ) ~= "string" and type( settings.limit ) ~= "number" and #settings.value < settings.width ) then
                        settings.value = string.sub( settings.value, 1, private.position ) .. event[2] .. string.sub( settings.value, private.position + 1 )
                        private.position = private.position + 1
                        queueRedraw()
                    end
                end
            elseif event[1] == "key" then
                runCallback( self, "key", event )
                if settings.focused then
                    if event[2] == keys.backspace then
                        if #settings.value > 0 and private.position > 0 then
                            settings.value = string.sub( settings.value, 1, private.position - 1) .. string.sub( settings.value, private.position + 1 )
                            private.position = private.position - 1
                            if private.position < 1 then private.position = 0 end
                            queueRedraw()
                        end
                    elseif event[2] == keys.left then
                        private.position = private.position - 1
                        if private.position < 0 then private.position = 0 end
                        queueRedraw()
                    elseif event[2] == keys.right then
                        private.position = private.position + 1
                        if private.position > #settings.value then private.position = #settings.value end
                        queueRedraw()
                    elseif event[2] == keys.home then
                        private.position = 0
                        queueRedraw()
                    elseif event[2] == keys["end"] then
                        private.position = #settings.value
                        queueRedraw()
                    elseif event[2] == keys.enter then
                        runCallback( self, "submit" )
                        queueRedraw()
                    end
                end
            end
        end

        function new.blurWhenNotClicked() return true end

        function new.getCursorBlink()
            if settings.limit == "inf" then return true
            elseif settings.limit and #settings.value <= settings.limit then return true
            elseif not settings.limit and #settings.value < settings.width then return true
            else return false end
        end
        function new.getCursorPos()
            if settings.limit == "inf" and len(settings.value) >= settings.width then return settings.width, 1
            elseif settings.limit and type( settings.limit ) == "number" and len( settings.value ) < settings.limit and len( settings.value ) > settings.width then return settings.width, 1
            elseif not settings.limit and len( settings.value ) < settings.width then return private.position + 1, 1
            else return private.position + 1, 1 end
        end

        function new.getTextColor() return settings.textColor end

        function new.getName() return settings.name end

        --[[ Callbacks ]]--

        function new.setSubmitCallback( self, v ) 
            setCallback( "submit", v )
        end
        function new.getSubmitCallback( self ) 
            return getCallback( "submit" )          
        end

        function new.setKeyCallback( self, v ) 
            setCallback( "key", v )
        end
        function new.getKeyCallback( self ) 
            return getCallback( "key" )
        end

        function new.setCharCallback( self, v ) 
            setCallback( "char", v )
        end
        function new.getCharCallback( self ) 
            return getCallback( "char" )
        end

        function new.setFocusCallback( self, v ) 
            setCallback( "focus", v )
        end
        function new.getFocusCallback( self ) 
            return getCallback( "focus" )
        end

        function new.setBlurCallback( self, v ) 
            setCallback( "blur", v )
        end
        function new.getBlurCallback( self ) 
            return getCallback( "blur" )
        end

        function new.getTabIndex() return settings.tabIndex end

        function new.blur( self, stage )
            runCallback( self, "blur", event )
            settings.focused = false
            if private.scene.getNodeFocus() == self then private.scene:setNodeFocus( false ) end
            queueRedraw()
        end
        function new.focus( self, stage )
            if not settings.enabled then return end
            runCallback( self, "focus", event )
            settings.focused = true
            private.scene:setNodeFocus( self )
            queueRedraw()
        end

        function new.getValue() return settings.value end
        function new.setValue( self, v ) settings.value = v private.position = #settings.value end

        function new.getAnimationProperty( property )
            if settings[property] then return settings[property] else error("Cannot find: "..tostring( property ) .. " on pane", 2) end
        end

        function new.setAnimationProperty( target, setting, value )
            --if settings[setting] then settings[setting] = value else error(setting.." not found in pane object") end
            setAnimationProperty( target, setting, value, settings, private )
        end

        function new.getType() return"input" end

        return new
    end

    function clone.getStageFromRegistry( name )
        return registryFetch( name )
    end

    local programRunning = true

    local function begin( callback )
        local activeEvent = {
            ["rednet_message"] = true,
            ["modem_message"] = true,
            ["alarm"] = true,
            ["timer"] = true,
            ["redstone"] = true
        } -- events that are sent when the stage is not active.
        local tFilter, tMessages = {}, {} --stores filters for coroutines.
        local function filterEvent( event, stage )
            -- if the stage has a coroutine filter, check if its in there
            if tFilter[stage.getName()] == event or not tFilter[stage.getName()] or tFilter[stage.getName()] == "" then
                tFilter[stage.getName()] = nil
                -- check if the event is in the stages blacklist.
                local bl, wl = stage.getEventBlacklist(), stage.getEventWhitelist()
                for i = 1, #bl do
                    if bl[i] == event then return false end
                end
                -- if stage is active, return true.
                if stage.getActive() then return true end
                -- check if the event is in the stages whitelist (stage is not active).
                for i = 1, #wl do
                    if wl[i] == event then return true end
                end
                return activeEvent[event]
            end
        end
        local cb, aStage = false, false
        local function exeOnEach( eArgs )
            --[[
                If that stage has a dialog box open, do not send the event to any running coroutines. However do send it to the runEvent function
            ]]
            term.setCursorBlink( false )
            for i = 1, #objects.stages do
                local stage = objects.stages[i]
                stage:runEvent( eArgs )
                term.redirect( stage.getTerm() )
                -- check if a message coroutine is active
                local messageCo, pgCo = stage.getAlternate(), stage.getRunningProgram()
                if not stage.getDialog() and stage.getActive() and messageCo and type( messageCo ) == "thread" and coroutine.status( messageCo ) == "suspended" then
                    if ( tMessages[stage.getName()] == eArgs[1] or tMessages[stage.getName()] == nil ) then
                        local ok, param = coroutine.resume( messageCo, unpack( eArgs ) )
                        if coroutine.status( messageCo ) == "suspended" and ok and param then
                            -- set filter
                            tMessages[stage.getName()] = param
                        elseif coroutine.status( messageCo ) == "dead" and not ok then error( param, 2 ) end -- errors in callbacks (crashed threads) will still be called and displayed
                    end
                elseif pgCo and type( pgCo ) == "thread" and coroutine.status( pgCo ) == "suspended" and filterEvent( eArgs[1], stage ) then
                    -- send event to runningProgram, check its status afterwards to determine if the program finished or crashed.
                    local ok, param = coroutine.resume( pgCo, unpack( eArgs ) )
                    if ok and coroutine.status( pgCo ) == "dead" then
                        -- finished, reset the filter
                        tFilter[stage.getName()] = nil
                        stage.threadClosed()
                    elseif not ok then
                        -- crashed, reset the filter for this coroutine
                        tFilter[stage.getName()] = nil
                        stage.threadCrash( param )
                    elseif ok and param then
                        -- store the filter
                        tFilter[stage.getName()] = param
                    end
                end
                if stage.getActive() then
                    -- get the cursor state of this stage and store it.
                    cb = stage.getCursorBlink()
                    aStage = stage
                end
                term.redirect( oTerm )
            end
            
            if #objects.stages <= 0 then
                log("Cannot continue windows loop, all stages closed.", "w")
                return "stop"
            end
        end
        local function loop()
            while programRunning do
                local event = { os.pullEventRaw() }
                if event[1] == "program_stop" and event[2] == program.name then
                    break
                else
                    if exeOnEach( event ) == "stop" then break end
                end

                -- check the timer event for animations
                if event[1] == "timer" and animationTimers[event[2]] then
                    local anim
                    for i = 1, #objects.animations do
                        local animation = objects.animations[i]
                        if animation.getName() == animationTimers[event[2]].animation then
                            anim = animation
                        end
                    end
                    if anim then
                        anim:processFrame()
                    end
                end

                if tEvents[event[1]] then
                    local evs = tEvents[event[1]]
                    for i = 1, #evs do
                        local ev = evs[i]
                        if type( ev ) == "table" then ev.cb(unpack( event )) else ev(unpack( event )) end
                    end
                end

                for i = 1, #reorderRequests do
                    reorderBufferLevels( reorderRequests[i] )
                end
                reorderRequests = {}

                if programRunning and ( true or event[1] == "mouse_click" or event[1] == "mouse_drag" or event[1] == "mouse_scroll" ) then
                    drawAll() 
                end

                local function cbSet( aStage, scene )

                end

                local function nodeSet( aStage, scene )
                    local node = scene.getNodeFocus()
                    if node then
                        if node.getCursorBlink and node.getCursorBlink() then
                            local xOffset, yOffset, amount, last = getTotalOffset( node )
                            local nX, nY = node.getPos()
                            local sX, sY = aStage.getPos()
                            local nodeCX, nodeCY = node.getCursorPos()
                            setCursorPos(nX + sX + nodeCX - 2 - amount + xOffset, nY + sY + nodeCY + yOffset - amount - (function() if aStage.getBorderless() then return 2 else return 1 end end)())
                            setTextColor( aStage.getColor( node.getTextColor() ) )
                            term.setCursorBlink( true )
                            return true
                        else return false end
                    else
                        return false
                    end
                end

                if aStage and aStage.getScene() then
                    local scene = aStage.getScene()
                    if not nodeSet( aStage, scene ) then
                        -- set the cursor to the term redirects position
                        cbSet()
                    end
                else
                    -- set the cursor to the term redirects position
                    cbSet()
                end
            end
        end
        if #objects.stages <= 0 then
            log("Cannot start windows loop, no stages open.", "w")
            return false
        end
        -- Draw every stage
        drawAll()
        if callback and type( callback ) == "function" then
            parallel.waitForAll( loop, callback )
        else
            loop()
        end
    end

    function clone.stopWindows() programRunning = false log("Windows stopped!", "i") end -- uses a variable here because any callbacks that attempts to program.stopWindows() AND use another function that waits for a specific event will eat the event thrown stopping the program from closing.

    function clone.registerEvent( event, callback, id )
        if not tEvents[event] then tEvents[event] = {} end
        if id then
            tEvents[event][ #tEvents[event] + 1 ] = {cb = callback, id = id}
            --table.insert( tEvents[event],  )
        else
            --table.insert( tEvents[event], callback )
            tEvents[event][ #tEvents[event] + 1 ] = callback
        end
    end

    local function processEvent( event, id, rm )
        if tEvents[event] then
            if id then
                for key, ev in ipairs( tEvents[event] ) do
                    if type( ev ) == "table" then
                        if ev.id == id then if rm then table.remove( tEvents[event], key ) else return ev end end
                    else error(type(ev)) end
                end
            else
                if rm then tEvents[event] = nil else return tEvents[event] end
            end
        end
    end

    function clone.unregisterEvent( event, id )
        processEvent( event, id, true )
    end

    function clone.getEventRegistration( event, id ) 
        return processEvent( event, id )
    end

    function clone.setErrorCallback( cb )
        program.customErrorCB = cb
    end

    function clone.getErrorCallback()
        return program.customErrorCB
    end

    function clone.getCatchErrors()
        return program.catchErrors
    end

    function clone.setCatchErrors( v )
        program.catchErrors = v
    end

    function clone.startWindows( callback )
        runningProgram = true
        local function cPrint( text, y, color )
            if color then term.setTextColor( color ) end
            term.setCursorPos( math.ceil( termX/2-(#text/2) ), y )
            term.clearLine()
            write( text )
        end
        -- Starts each windows event loop.
        -- When a stage is destroyed, it will be stopped and must be "rebuilt" in order to function again.
        if program.catchErrors then
            local ok, err = pcall(function() begin( callback ) restore() end)
            if err or not ok then
                log( tostring( err ), "e" )
                restore()
                if program.customErrorCB and type( program.customErrorCB ) == "function" then
                    program.customErrorCB( ok, err )
                else
                    term.setBackgroundColor( colors.gray )
                    term.clear()
                    cPrint("DynaCode Version 3 - Exception Caught", 4, colors.orange)
                    cPrint("A fatal exception occurred which", 6, colors.lightGray)
                    cPrint("has prevented DynaCode from continuing.", 7, colors.lightGray)
                    cPrint(tostring( err ), 9, colors.orange)
                    cPrint("Please report this error on the forum", 12, colors.lightGray)
                    cPrint("following the guidelines on the page.", 13)
                    cPrint("Press 'shift' to pause reboot timer", 15, colors.lightGray)
                    cPrint("any other key to reboot", 16, colors.lightGray)
                    local isTimer, timer, vTimer = true, os.startTimer( 1 ), program.restartTimer or 10
                    cPrint("Rebooting in "..vTimer, termY, colors.lightGray)

                    local function rTimer()
                        vTimer = vTimer - 1
                        if vTimer <= 0 then
                            os.reboot()
                        else
                            timer = os.startTimer( 1 )
                        end
                        cPrint("Rebooting in "..vTimer, termY, colors.lightGray)
                    end

                    while true do
                        local e, p1 = os.pullEventRaw()
                        if e == "timer" and p1 == timer and program.restartTimer and isTimer then
                            rTimer()
                        elseif e == "key" then
                            if p1 == keys.leftShift or p1 == keys.rightShift then
                                if isTimer then
                                    isTimer = false
                                    cPrint("Paused reboot timer", termY, colors.orange)
                                elseif not isTimer then
                                    isTimer = true
                                    timer = os.startTimer( 1 )
                                    cPrint("Rebooting in "..vTimer, termY, colors.lightGray)
                                end
                            else os.reboot() end
                        end
                    end

                end
            end
        else
            begin()
        end
        restore()
    end

    clone.getObjects = function() return objects end

    clone.file = {
        getHandle = function( path, mode )
            if fs.exists( path ) then
                return fs.open( path, mode or "r" )
            else
                return false
            end
        end,
        write = function( path, content )
            local h = fs.open( path, "w" )
            h.write( content )
            h.close()
            return true
        end,
        append = function( path, content )
            local h = clone.file.getHandle( path, "a" )
            if h then
                h.write( content )
                h.close()
                return true
            else
                return false
            end
        end,
        writeLine = function( path, content )
            local h = fs.open( path, "r" )
            h.writeLine( content )
            h.close()
            return true
        end,
        getLine = function( path )
            local h = clone.file.getHandle( path, "r" )
            if h then
                local cnt = h.readLine()
                h.close()
                return cnt
            else
                return false
            end
        end,
        getAll = function( path )
            local h = clone.file.getHandle( path, "r" )
            if h then
                local cnt = h.readAll()
                h.close()
                return cnt
            else
                return false
            end
        end
    }

    clone.createFilter = function( name, tbl ) filterAdd( name, tbl ) end

    clone.getFilterObject = function( name )
        return filterGet( name )
    end

    clone.getColorFromFilter = function( filter, cl )
        return getColorFromFilter( filter, cl )
    end

    clone.canvas = {
        drawArea = function( nX, nY, width, height, background )
            if height < 1 or width < 1 then
                error("Height and width must be greater than 1 to draw a box")
            end
            for i = nY, nY + height do
                clone.canvas.drawHLine( nX, i, width, background )
            end
        end,
        drawHLine = function( nX, nY, width, background )
            paintutils.drawLine( nX, nY, nX+width, nY, background )
        end,
        drawVLine = function( nX, nY, height, background )
            paintutils.drawLine( nX, nY, nX, nY+height, background )
        end,
        drawText = function() end,
        drawCText = function() end
    }

    clone.remote = {
        fetch = function( url )
            for i = 1, 3 do
                local response = http.get( url )
                if response then
                    return response
                end
            end
            return false
        end,
        fetchLine = function( url )
            local response = clone.remote.fetch( url )
            if not response then return false else return response.readLine() end
        end,
        fetchAll = function( url )
            local response = clone.remote.fetch( url )
            if not response then return false else return response.readAll() end
        end
    }

    return clone

end