--[[
	DynaCode Framework [DEPRECATED]

	Copyright Harry Felton (c) 2015

	The DynaCode framework is used by all major HexCode programs.
	http://github.com/hbomb79/DynaCode

	It is created with developers in mind, allowing for easy, simple object oriented, buffer controlled GUI creation in computercraft.

	This framework is for ComputerCraft (1.6+).
	Tested on 1.63 and 1.74
]]

function clone( ID, callback, options )
	error("DYNACODE Is officially deprecated. Try version 2 here: https://github.com/hbomb79/DynaCode/blob/master/DynaCode2 ")
	local defaults = { --If an element cannot find a variable in itself(self), the passed settings(self.options) or the instance settings(options) then it will fallback to these (defaults)
		allowTerminate = false,
		addToBufferOnCreation = false,
		protected = true, -- Prevents laggy operations
		redraw = true,
		toggle = function( self )
			-- Toggle click state of element
			if self.toggled then self.toggled = false else self.toggled = true end
			return self
		end,
		toggleEnabled = function( self )
			if self.enabled then self.enabled = false else self.enabled = true end
			return self
		end,
		enable = function( self )
			self.enabled = true
			return self
		end,
		disable = function( self )
			self.enabled = false
			return self
		end,
		toggleShow = function( self )
			if self.visible then self:hide() else self:show() end
		end,
		hide = function( self )
			-- Hide element
			self.visible = false
			return self
		end,
		show = function( self )
			-- Show element
			self.visible = true
			return self
		end,
		onredraw = function( self )

		end,
		beforeRedraw = function( self )

		end,
		remove = function( self )
			self:bufferRemove()
			self:removeFromDict()
		end,
		scrollBackground = colors.lightGray,
		scrollColor = colors.gray,
		x = 1,
		y = 1,
		padding = 1,
		width = 10,
		height = 1,
		focusable = true,
		textColor = colors.white,
		backgroundColor = colors.red,
		defaultTextColor = colors.gray,
		defaultBackground = colors.white,
		enabled = true,
		visible = true,
		type = "NONE",
		text = "NaN",
		blacklist = false,
		whitelist = false,
		scrollBar = true,
		toggleText = "NaN",
		toggleTextColor = colors.white,
		toggleBackgroundColor = colors.red,
		limit = 10,
		zindex = 1,
		disabledBackgroundColor = colors.lightGray,
		disabledTextColor = colors.black,
		onclick = function() end,
		onsubmit = function() end,
		onkeyup = function() end,
		keyError = function() end,
		focused = false

	}
	if options then
		setmetatable( options, {__index=defaults})
	end
	if not ID then error"Needs ID to init" end
	-- Create a new table for elements to be stored.
	local clone = {}
	clone.alias={}
	setmetatable( clone.alias, {__index=defaults})
	if options then setmetatable( clone, {__index = options} ) else
		setmetatable( clone, {__index=defaults})
	end
	clone.timers = {}
	clone.name = {}
	clone.groups = {}
	clone.bufferList = {}
	clone.customEvents = {}
	clone.elementGroups = {}
	clone.ID = ID
	clone.termX, clone.termY = term.getSize()
	local this = clone


	--[[
		Object Declarations
		 ---===========---

		All objects have the following settings:
		- @integer x
		- @integer y
		- @boolean enabled
		- @boolean visible
		- @string name
		- @integer backgroundColor
		- @integer textColor
		- @integer defaultBackground
		- @integer defaultTextColor
		- @integer disabledBackgroundColor
		- @integer disabledTextColor

		All objects have the following callbacks:
		- onredraw
	]]

	--[[
		Object: Button,
		Parameters: options
		@options.name required
		
		Description:
		Create an onscreen button at @options.x and @options.y.

		Object Specific Settings:
		- @integer toggleBackgroundColor
		- @integer toggleTextColor
		- @integer padding
		- @string text
		- @string toggleText
		- @boolean canBeToggled
		- @boolean toggled
		- @integer width
		- @integer height

		Object Specific Callbacks:
		- onclick
	]]

	clone.button = function( options )
		req, missing = this.checkRequirements( options, {
			"name"
		})
		if not req then error("Missing requirements: "..textutils.serialize( missing )) end
		setmetatable( options, {__index = this})
		local new = {}
		setmetatable( new, {__index = options} )
		new.type = "button"
		new.getLongest = function( self )
			if not self.canBeToggled then return #self.text end
			if #self.text >= #self.toggleText then 
				return self.text 
			else 
				return self.toggleText 
			end
		end
		new.groupSelect = function( self, group )
			-- Returns table of elements with a e.group matching [group]
		end
		new.draw = function( self )
			-- Draw this element
			oldX, oldY = term.getCursorPos()
			if self.canBeToggled and self.toggled then
				self.width = #self.toggleText+self.padding*2
			else
				self.width = #self.text+self.padding*2
			end
			if self.beforeRedraw then self:beforeRedraw() end
			term.setCursorPos( self.x, self.y )
			if self.visible then
				this.drawing.drawStraight(self.x, self.y, self.x + self.getLongest( self ) + self.padding - 1, self.defaultBackground)
				--error( self.enabled )
				if self.enabled then
					if self.toggled then
						-- This element should use secondary vars
						term.setTextColor( self.toggleTextColor )
						term.setBackgroundColor( self.toggleBackgroundColor )
						self:drawPadding()
						term.write( self.toggleText )
					else
						term.setTextColor( self.textColor )
						term.setBackgroundColor( self.backgroundColor )
						self:drawPadding()
						term.write( self.text )
					end
				elseif not self.enabled then
					-- not enabled
					local text = false
					if self.toggled then text = self.toggleText else text = self.text end
					this.drawing.drawStraight(self.x, self.y, self.x+#text, self.disabledBackgroundColor)
					term.setTextColor( self.disabledTextColor )
					self:drawPadding()
					term.write( text )
				end
				self:drawPadding() 
			end
			term.setTextColor( self.defaultTextColor )
			term.setBackgroundColor(self.defaultBackground)
			term.setCursorPos( oldX, oldY )
			if self.onredraw then self:onredraw() end
			return self -- Allows chaining of functions (like jQuery)
		end
		new.drawPadding = function( self )
			-- Draw padding
			for i = 1, self.padding do
				term.write(" ")
			end
			return self
		end
		if this.addToBufferOnCreation then new:bufferAdd() end
		new:addToDict()
		return new
	end

	--[[
		Object: Input,
		Parameters: options
		@options.name required
		
		Description:
		Create an onscreen text box that can be typed in and submitted using the enter key.

		Object Specific Settings:
		- @string typed
		- @boolean focused
		- @integer padding
		- @string text
		- @table white-list
		- @table black-list
		- @boolean focusable
		- @integer limit
		- @string replaceChar

		Object Specific Callbacks:
		- onsubmit
		- onkeyup
		- keyError
	]]

	clone.input = function( options )
		req, missing = this.checkRequirements( options, {
			"name"
		})
		if not req then error("Missing requirements: "..textutils.serialize( missing )) end
		setmetatable( options, { __index = this } ) -- If an option is not set in new, it will look in options. if its not there it will then look in clone (super)
		local new = {}
		setmetatable( new, {__index = options})
		new.typed = options.typed or ""
		new.type = "input"
		new.focused = false
		new.keyup = function ( self, e, key )
			-- User pressed key, if this field is active add text to buffer and write on screen
			if not self.enabled or not self.visible or not self.focused then return self end
			term.setCursorBlink(true)
	        if e=="char" then
	        	if not self:isKeyAllowed( key ) then
	        		self:keyError( key )
	        		return self:bufferDraw()
	        	end
	            if #self.typed < options.limit then
	                self.typed = self.typed .. key
	                term.write(options.replaceChar or key)
	            end
	            if #self.typed >= options.limit then term.setCursorBlink(false) end
	        elseif e=="key" and key==keys.backspace and #self.typed > 0 then
	            self.typed = self.typed:sub(1,#self.typed-1)
	            local x,y = term.getCursorPos()
	            term.setCursorPos(x-1,y)
	            term.write(" ")
	            term.setCursorPos(x-1,y)
	        elseif e=="key" and key==keys.enter and #self.typed > 0 then
	        	-- Submit the input
	        	self:blur()
	        	if self.onsubmit then self:onsubmit() end
	        end
	        if self.onkeyup then self:onkeyup( key ) end
	        return self
		end
		new.draw = function( self )
			-- Draw GUI
			oldX, oldY = term.getCursorPos()
			term.setCursorPos( self.x, self.y )
			this.drawing.drawStraight(self.x, self.y, self.x+self.limit - 1, self.defaultBackground)
			if self.visible then
				-- Draw text from buffer
				if self.enabled then
					this.drawing.drawStraight( self.x, self.y, self.x + self.limit - 1, self.backgroundColor)
					-- Draw cursor...
					term.setTextColor( self.textColor )
					write( self.typed )
					if #self.typed >= self.limit then term.setCursorBlink( false ) else term.setCursorBlink( true ) end
					if not self.focused then
						term.setCursorBlink( false )
					end
				elseif not self.enabled then
					term.setTextColor( self.disabledTextColor )
					term.setCursorBlink( false )
					this.drawing.drawStraight( self.x, self.y, self.x + self.limit - 1, self.disabledBackgroundColor)
					write( self.typed )
				end
			else
				term.setTextColor( self.defaultTextColor )
				term.setBackgroundColor( self.defaultBackground )
			end
			if self.onredraw then self:onredraw() end
			return self
		end
		new.isKeyAllowed = function( self, char )
			local tbl = false
			local bl = false
			local wl = false
			if self.blacklist then
				tbl = self.blacklist
				bl = true
			elseif self.whitelist then
				tbl = self.whitelist
				wl = true
			else return true end
			for i, v in pairs(tbl) do
				if v == char then
					if wl then
						return true
					else return false end
				end
			end
			if wl then return false else return true end
		end
		new.focus = function( self )
			self.focused = true
			return self
		end
		new.blur = function( self )
			self.focused = false
			return self
		end
		if this.addToBufferOnCreation then new:bufferAdd() end
		new:addToDict()
		return new
	end

	--[[
		Object: Text Block,
		Parameters: options
		@options.name required
		
		Description:
		Create an onscreen group of text starting at Y

		Object Specific Settings:
		- @table Content

		Object Specific Callbacks:
		NONE
	]]

	clone.textBlock = function( options )
		req, missing = this.checkRequirements( options, {
			"lines"
		})
		if not req then error("Missing requirements: "..textutils.serialize( missing )) end
		setmetatable( options, {__index=this})
		local new = {}
		setmetatable( new, {__index=options})

		new.draw = function( self )
			--[[
				Loops through self.lines, writes each line per specification in @param options - @fallback super
			]]
			if not self.visible or not self.enabled then return self end
			local cl = 0
			term.setTextColor( self.textColor )
			term.setBackgroundColor( self.backgroundColor )
			for i, v in ipairs( self.lines ) do
				-- Get the line, set cursor position to the next line and write according to options
				if self.center then
					term.setCursorPos( math.floor(this.termX/2-#v/2), self.y + cl )
				else
					term.setCursorPos( self.x, self.y + cl )
				end
				write( v )
				cl = cl + 1
			end
			term.setBackgroundColor( self.defaultBackground )
			term.setTextColor( self.defaultTextColor )
			if self.onredraw then self:onredraw() end
			return self
		end

		new:addToDict()
		if this.addToBufferOnCreation then new:bufferAdd() end
		return new
	end

	--[[
		Object: Text Line,
		Parameters: options
		@options.name required
		
		Description:
		Create a line of text

		Object Specific Settings:
		- @string Text

		Object Specific Callbacks:
		NONE
	]]

	clone.textLine = function( options )
		req, missing = this.checkRequirements( options, {
			"text"
		})
		if not req then error("Missing requirements: "..textutils.serialize( missing )) end
		setmetatable( options, {__index=this})
		local new = {}
		setmetatable( new, {__index=options})

		new.draw = function( self )
			if not self.visible or not self.enabled then return self end
			term.setTextColor( self.textColor )
			term.setBackgroundColor( self.backgroundColor )
			if self.center then
				term.setCursorPos( math.floor(this.termX/2-#self.text/2), self.y )
			else
				term.setCursorPos( self.x, self.y )
			end
			term.clearLine()
			write( self.text )
			term.setBackgroundColor( self.defaultBackground )
			term.setTextColor( self.defaultTextColor )
			if self.onredraw then self:onredraw() end
			return self
		end

		new:addToDict()
		if this.addToBufferOnCreation then new:bufferAdd() end
		return new
	end

	--[[
		Object: Scroll area,
		Parameters: options
		@options.name required
		
		Description:
		Creates a scrollable area that can contain string text or buttons

		Object Specific Settings:
		- @string Text
		- @integer width
		- @integer height

		Object Specific Callbacks:
		NONE
	]]

	clone.getStringConfig = function( str )
		if type( str ) ~= "string" then
			error("Expected @str to be type string, got "..type( str ))
		end
		return str:match("%[.*%]") 
	end

	clone.getStringSetting = function( str, setting )

		str = str:match("%[.*%]")
		if not str then return false end
		strTable, strSetting = {}, {}
		temp_word = str:gmatch("%S+")
		if not temp_word then return false end
		for word in temp_word do
			table.insert( strTable, word )
		end
		for k, v in ipairs( strTable ) do
			start = v:match(".*%S*%=*")
			if start then
				-- Remove "[" from start of string if exists.
				if start:sub(1, 1) == "[" then
					start = start:sub( 2 )
				end
				if start:sub(-1, -1) == "]" then
					start = start:sub( 1, -2 )
				end
				-- Strip from start to "=". If this matches @setting, return the value
				tSetting = start:match(".*%=")
				tSetting = tSetting:sub( 1, -2 )
				if tSetting and tSetting == setting then
					rSetting = start:sub( #tSetting+2 )
					return rSetting
				end
			end
		end
		return false
	end

	clone.keyMenu = function( options )
		req, missing = this.checkRequirements( options, {
			"name",
			"content"
		})
		if not req then error("Missing requirements: "..textutils.serialize( missing )) end
		setmetatable( options, {__index=this})
		local new = {}
		new.type = "keymenu"
		new.selected = 1
		setmetatable( new, {__index=options})

		new.draw = function( self )
			if not self.visible or not self.enabled then return self end
			for k, option in ipairs( self.content ) do
				-- Loop each option, if selected, set color to @self.toggleTextColor else set to @self.textColor.
				local bg, tc = self.backgroundColor, self.textColor
				if k  == self.selected then
					bg, tc = self.toggleBackgroundColor, self.toggleTextColor
				end
				term.setBackgroundColor( bg )
				term.setTextColor( tc )
				local x, y = self.x, self.y + k - 1
				if self.center then
					x = this.termX/2 - ( #option.label / 2 )
				end
				term.setCursorPos( x, y )
				write( option.label )
			end
		end

		new.keyup = function( self, event, key )
			-- Check key
			if key == keys.down or key == keys.s then
				-- If selected is at boundary, set to 1
				self.selected = self.selected + 1
				if self.selected > #self.content then self.selected = 1 end
			elseif key == keys.up or key == keys.w then
				self.selected = self.selected - 1
				if self.selected < 1 then self.selected = #self.content end
			elseif key == keys.enter then
				if self.content[ self.selected ] and type( self.content[ self.selected ].onselect ) == "function" then
					self.content[ self.selected ].onselect( self )
				end
			end
			self:draw()
		end

		new:addToDict()
		return new
	end

	clone.scroll = function( options )
		req, missing = this.checkRequirements( options, {
			"name",
			"content"
		})
		if not req then error("Missing requirements: "..textutils.serialize( missing )) end
		setmetatable( options, {__index=this})
		new = {}
		new.offset = options.offset or 1
		new.type = "scroll"
		setmetatable( new, {__index=options})

		new.draw = function( self )
			if self.visible and self.enabled then
				-- Loop through each item in content. If it is in bounds, set to visible=true
				local ln = 0
				this.drawing.drawArea( self.x, self.y, self.width-1, self.height-1, self.backgroundColor )
				term.setTextColor( self.textColor )
				for k, v in ipairs( self.content ) do
					if k >= self.offset and k <= self.offset+ln and ( type(v) == "string" or type(v) ~= "string" and v.type == "button" ) then
						if self.y+ln <= self.y+self.height-1 then
							if type( v ) == "string" then
								s = this.getStringSetting( v, "color" )
								if s then
									s = s:sub( s:find("%..*") )
									s = s:sub( 2 )
									term.setTextColor( colors[s] )
								else
									term.setTextColor( self.textColor )
								end
								v = v:gsub( "%[.*%]", "" )
								if v:sub( -1 ) == " " then
									v = v:sub( 1, -2 )
								end
								local cx = self.x
								if self.center then
									cx = math.ceil( self.x - 1 + self.width/2-( #v/2 ) )
								end
								term.setCursorPos( cx, self.y+ln)
								write( v )
								ln = ln + 1
							elseif v.type == "button" then
								-- The element is a button, its Y axis needs to be manipulated for it to scroll correctly
								v.y = self.y+ln
								if self.center then
									v.x = math.ceil( self.x - self.padding*2 + self.width / 2 - ( ( #v.text+v.padding ) / 2 ) )
								else
									v.x = self.x
								end
								v:draw()
								ln = ln + 1
							end
						end
					end
				end
				self:updateScrollbar()
			end
			term.setTextColor( self.defaultTextColor )
			term.setBackgroundColor( self.defaultBackground )
		end

		new.updateScrollbar = function( self )
			if self.scrollBar and #self.content > self.height then
				-- Calculate new scroll bar position
				maxoffset = #self.content - self.height + 1
				if self.offset > maxoffset then self.offset = maxoffset self:draw() return self end
				height =  math.ceil( ( self.height / 100 ) * ( ( self.height / #self.content ) * 100 ) ) -- Get height as result of percentage
				pos = math.floor( self.offset * ( self.height / #self.content ) )
				if pos < 1 then pos = 1
				elseif pos > self.height - height then pos = self.height - height end
				if height > 0 and maxoffset > 0 and height ~= self.height then
					if self.offset >= maxoffset then
						pos = self.height - height
					elseif self.offset == 1 then
						pos = 1
					elseif pos >= self.height - height then pos = pos - 1
					elseif pos <= 1 then pos = pos + 1
					end
					paintutils.drawLine( self.x+self.width-1, self.y, self.x+self.width-1, self.y+self.height-1, self.scrollBackground)
					paintutils.drawLine( self.x+self.width-1, self.y+pos-1, self.x+self.width-1, self.y+pos+height-1 , self.scrollColor)
				end
			end
			return self
		end

		new.onscroll = function( self, event, direction, x, y )
			-- if x and y are in bounds (user was hovering on scroll area) then increment/decrement the offset
			if x >= self.x and x <= self.x+self.width and y >= self.y and y <= self.y+self.height-1 then
				-- In bounds
				if direction == -1 then
					-- scrolled up
					self.offset = self.offset - 1
					if self.offset < 1 then self.offset = 1 end
				elseif direction == 1 then
					-- scrolled down
					self.offset = self.offset + 1
					if not self.content[ self.offset + self.height - 1 ] then self.offset = self.offset - 1 end
					if self.offset > #self.content then self.offset = #self.content end
				end
			end
			self:draw()
		end

		new.ondrag = function( self, event, x, y )
			-- Check if dragging down or up..
			if y == self.y or y == self.y + self.height - 1 then
				self:onclick( "mouse_click", 1, x, y )
			elseif x == self.x+self.width - 1 and y >= self.y-1 and y <= self.y+self.height - 1 then
				if not self.oldY then self.oldY = self.y end
				drag = y - self.y + 1
				dragPos = math.floor( ( drag / ( self.height / #self.content ) ) )
				self.offset = dragPos
				if self.offset < 1 then 
					self.offset = 1 
				elseif not self.content[ self.offset + self.height - 1 ] then 
					self.offset = #self.content - self.height + 1
				elseif 
					self.offset > #self.content then self.offset = #self.content 
				end
				self.oldY = y
				self:draw()
			end
		end

		new.onclick = function( self, event, button, x, y )
			-- Scroll to location. On click get the Y axis. Use this as a percentage, get the same percentage via the same formula as used in updateScrollbar
			if x == self.x+self.width - 1 then
				self.oldX, self.oldY = x, y
				height =  math.floor( ( self.height / 100 ) * ( ( self.height / #self.content ) * 100 ) )
				clickPos = y - self.y + 1
				if clickPos == 1 then
					self.offset = 1
				elseif clickPos == self.height then
					self.offset = #self.content - self.height + 1
				else
					scrollPos = math.floor( ( clickPos / ( self.height / #self.content ) ) )
					self.offset = scrollPos
				end
				self:draw()
			end
		end

		new.checkBoundaries = function( self, element )
			if element.y < self.y or element.y > self.y+self.height or element.y+element.height > self.y+self.height then
				return false
			else return true end
		end
		new:bufferAdd()
		new:addToDict()
		return new
	end

	clone.checkRequirements = function( given, req )
		if not given then error"No options given for object" end
		set = {}
		function inReq( i )
			for k, v in pairs( req ) do
				if v == i then return true end
			end
			return false
		end

		function inSet( i )
			for k, v in pairs( set ) do
				if v == i then return true end
			end
			return false
		end

		function setMissing()
			local set = {}
			for key, value in pairs( req ) do
				
				-- Check if KEY provided in @given. If it isn't, then add it to local @set
				aSet = true
				for k, v in pairs( given ) do
					if k == value then aSet = false end
				end
				if aSet then table.insert( set, value ) end

			end
			return set
		end

		for k,v in pairs( given ) do
			if inReq( k ) and not inSet( k ) then table.insert( set, k ) end
		end

		missing = setMissing()

		if #set == #req then
			return true, {}
		else return false, missing end

	end


	--[[
		 System Functions
		---============---
		
		The following functions are used by the API, you can also use them by targeting your instance:

		<instance>.[fnName]

	]]



	clone.eventBind = function( event, func )
		-- Create custom event handler
		if not this.customEvents[event] then
			this.customEvents[event] = {} --Create a new table space for this event
		end
		table.insert(this.customEvents[event], func)
	end

	clone.eventUnbind = function( event )
		-- remove custom set event handler
		if this.customEvents[event] then
			for i, v in ipairs( this.customEvents[event] ) do
				table.remove( this.customEvents[event], i )
			end
		end
	end

	clone.hideAll = function()
		for k, v in pairs( this.bufferList ) do
			for i, v in pairs( this.bufferList[k] ) do
				obj = this.group.fetchObject( v )
				if not obj.hide then error("unknown object: "..tostring( obj ) ) end
				obj:hide()
			end
		end
		this.buffer.drawBuffer()
	end

	clone.removeAll = function()
		this.bufferList = {}
	end

	clone.setTimer = function( nm, duration, callback, rp )
		-- make timer, insert name into table for use later
		if duration <= 0.3 then
			if this.protected then
				error"Cannot create timer: The duration is too low. Increase duration"
			end
		end
		this.stopTimer( nm ) --Removes any timers with the same name
		this.timers[ os.startTimer( duration ) ] = {
			duration = duration,
			oncomplete = callback,
			rp = rp,
			name = nm
		}
	end

	clone.stopTimer = function( name )
		for k, v in pairs( this.timers ) do
			if v.name == name then
				os.cancelTimer( k )
				if v.rp then v.rp = false end
			end
		end
	end

	clone.setAlias = function( name, callback )
		this.alias[name] = callback
	end

	clone.removeAlias = function( name )
		this.alias[name] = nil
	end

	--[[
	
		 System Listeners
		---============---

		Used by the API to monitor OS events. Should not be called from local instance

	]]

	clone.click = function( e, button, x, y )
		-- Check if click location was on a button. If it was run the callback attached.
		if e == "mouse_click" then
			if x and y then
				-- Loop through elements and find a button at the location
				local redraw = false
				for i, v in ipairs(this.name) do
					if not v.toggled and x >= v.x - v.padding and x < v.x + #v.text + v.padding and y >= v.y and y <= v.y+v.height-1 and v.type == "button" or v.toggled and x >= v.x - v.padding and x < v.x + #v.toggleText + v.padding and y >= v.y and y <= v.y+v.height-1 and v.type == "button" then
						if v.enabled and v.visible then
							if v.canBeToggled then v:toggle() else redraw = true end
							v:onclick()
						end
					elseif v.type == "scroll" and v.enabled and v.visible and x >= v.x and x <= v.x+v.width and y >= v.y and y <= v.y+v.height-1 then
						v:onclick( e, button, x, y )			
					elseif v.type == "input" and v.enabled and v.visible and v.focusable then
						if x >= v.x - 1 and x < v.x + v.limit - 1 and y == v.y then 
							v:focus()
						else
							if v.focused then v:blur() end
						end
						redraw = true
					end
				end
				if redraw then
					--this.buffer.drawBuffer()
				end
			end
		end
	end

	--[[

		    System APIs
		 ---===========---
	
		Utilities that you can use to make developing programs easier.

	]]

	clone.group = {
		create = function( name, content )
			if type( content ) ~= "table" then
				error("Invalid Argument, Table expected, got "..type( content ))
			end
			this.elementGroups[name] = {}
			for key, value in pairs( content ) do
				local fnname = false
				if type( value ) == "string" then
					fnname = value
				elseif type( value ) == "table" then
					fnname = value.name
				end
				table.insert( this.elementGroups[name], fnname )
			end
		end,
		fetch = function( group )
			return this.elementGroups[ group ] or false
		end,
		fetchObject = function( name )
			for k, v in pairs( this.name ) do
				if v.name and v.name == name then
					return this.name[k]
				end
			end
		end,
		removeAll = function( group )
			if type( group ) == "string" then
				group = this.group.fetch( group )
			end
			for k, v in pairs( group ) do
				el = this.group.fetchObject( v )
				if el and el.remove then
					el:remove()
				end
			end
		end,
		loop = function( group, callback ) 
			for k, item in ipairs( group ) do
				item:callback()
			end
		end,
		changeSetting = function( group, setting, newValue )
			-- Change @setting on all elements in @group to @newValue
			if type( group ) == "string" then
				group = this.group.fetch( group )
			end
			for key, value in pairs( group ) do
				this.group.fetchObject( value )[setting] = newValue
			end
			this.buffer.drawBuffer()
		end,
		remove = function( name )
			for k, v in pairs( this.elementGroups ) do
				print( k )
			end
		end
	}

	clone.addToDict = function( self )
		self:removeFromDict()
		table.insert( this.name, self )
	end

	clone.removeFromDict = function( self )
		for k, v in ipairs( this.name ) do
			if v.name == self.name then
				table.remove( this.name, k )
			end
		end
	end

	clone.bufferAdd = function( self )
		this.buffer.addToBuffer( self )
		return self
	end
	clone.bufferDraw = function( self )
		this.buffer.drawBuffer()
		return self
	end
	clone.bufferRemove = function( self )
		this.buffer.removeFromBuffer( self.name )
		return self
	end

	clone.start = function( callback )
		if callback then
			parallel.waitForAll( callback, this.startEventLoop )
		else
			this.startEventLoop()
		end
	end

	clone.startEventLoop = function( callback )
		-- Start loop, run callback
		if this.allowTerminate then
			this.eventBind("terminate", function(event)
				this.stopEventLoop()
				error("Terminated Program")
			end)
		end
		if callback then callback() end
		while true do
			local event, p1, p2, p3, p4, p5, p6 = os.pullEventRaw()
			if event == "cancel_loop_"..tostring(this.ID) then
				break
				-- Calling an os event [cancel_loop_<targetID>]. @targetID = ID at time of clone.
				-- This is ID specific else it cancels all clone loops, not just the one you called from.
			elseif event == "mouse_click" then
				this.click( event, p1, p2, p3 )
			elseif event == "mouse_scroll" then
				for i, v in ipairs( this.name ) do
					if v.enabled and v.visible and v.type == "scroll" then v:onscroll( event, p1, p2, p3 ) end
				end
			elseif event == "mouse_drag" then
				for i, v in ipairs( this.name ) do
					if v.enabled and v.visible and v.type == "scroll" then v:ondrag( event, p2, p3 ) end
				end
			elseif event == "char" then
				for i, v in ipairs( this.name ) do
					if v.enabled and v.focused and v.type == "input" then v:keyup( event, p1 ) end
				end
			elseif event == "key" then
				for i, v in ipairs( this.name ) do
					if v.enabled and v.focused and v.type == "input" or v.enabled and v.visible and v.type == "keymenu" then v:keyup( event, p1 ) end
				end
			elseif event == "timer" then
				-- Check if timer is in timer table
				if this.timers[p1] then
					tmr = this.timers[p1]
					tmr:oncomplete()
					if tmr.rp then --tmr.rp is set false by this.stopTimer( p1 )
						-- restart timer
						this.setTimer( tmr.name, tmr.duration, tmr.oncomplete, tmr.rp )
					end
				end
			end
			-- Check if custom event
			if this.customEvents[event] then
				for i, e in ipairs(this.customEvents[event]) do
					-- If multiple
					e(event, p1, p2, p3, p4, p5, p6)
				end
			end
		end
	end

	clone.stopEventLoop = function( callback )
		-- Stop event loop, code after this is run in the program will execute.
		os.queueEvent("cancel_loop_"..tostring( this.ID ))
		if callback then callback() end
	end



	clone.buffer = {
		--[[
		
			Add elements to a draw buffer.
			Every time a change happens to the buffer, it will be resorted and drawn.
	
			Each element must contain a zindex property, or else the buffer will default to 1.

			If text is wanted in the buffer, the this.textLine or this.textBlock object must be used instead

		]]
		drawBuffer = function()

			len = 0
			order = {}
			for _, tbl in pairs( this.bufferList ) do
				len = len + 1
				order[len] = tbl
			end
			for i = #order, 1, -1 do
				for k,v in pairs( order[i] ) do
					element = this.group.fetchObject( order[i][k] )
					if not element then error("Missing element: "..tostring( order[i][k] ) ) end
					if element.redraw then
						element:draw()
					end
				end
			end
		end,
		addToBuffer = function( content )
			if not content or not content.zindex then error(tostring(content).." cannot be added to the buffer") end
			if content.zindex < 1 then error( "zindex of "..tostring( content.name ).." must be greater than 0") end
			if not this.bufferList[ content.zindex ] then
				-- Create a new table to store the elements inside of.
				this.bufferList[ content.zindex ] = {}
			end
			table.insert(this.bufferList[content.zindex], content.name)
			--error( this.bufferList[content.zindex][1].zindex )
		end,
		removeFromBuffer = function( name )

			for k, z in pairs( this.bufferList ) do
				--error( textutils.serialize( z ) )
				--for _, v in pairs( z ) do
				for i, v in ipairs( z ) do
					if this.group.fetchObject( v ).name == name then
						--print( textutils.serialize( v ))
						table.remove( z, i )
					end
				end
			end
			--[[
			for i = 0, #this.bufferList do
				for i, v in ipairs( this.bufferList[i] ) do
					if v.name == name then
						table.remove( this.bufferList[i], i )
					end
				end
			end]]
		end
	}

	clone.monitor = {
		drawTo = function( wrap, text, x, y )
			--[[
				@param self = hexcode(wrap)
			]]
			monX, monY = wrap.getSize()
			if x > monX or y > monY then
				error("too small to write on")
			end
			wrap.setCursorPos( x, y )
			wrap.write( text )
		end,
		drawToGroup = function( group, text, x, y )
			--[[
				@param self = peripheral.getGroup OR table of wraps
			]]
			for i, v in ipairs( group ) do
				this.monitor.drawTo( group, text, x, y )
			end
		end,
		drawToGroupCentered = function( group, text, y)
			-- First, get the monX and monY value
			for i, v in ipairs( group ) do
				--v.clear()
				monX, monY = v.getSize()
				center = math.floor( monX/2-(#text/2) )
				this.monitor.drawTo( v, text, center, y )
			end
		end,
		clearGroup = function( group )
			for k, v in ipairs( group ) do
				v.clear()
			end
		end,
		backgroundColorGroup = function( group, bg )
			for k, v in ipairs( group ) do
				v.setBackgroundColor( bg )
			end
		end,
		textColorGroup = function( group, tc )
			for k, v in ipairs( group ) do
				v.setTextColor( tc )
			end
		end

	}

	clone.drawing = {
		drawArea = function( startX, startY, width, height, color )
			if width <= 0 or height <= 0 then 
				this.drawing.drawDot( startX, startY, color )
			else
				for y = 0, height do
					this.drawing.drawStraight( startX, startY+y, startX+width, color )
				end
			end
		end,
		drawDot = function( x, y, color )
			local oldX, oldY = term.getCursorPos()
			term.setCursorPos( x, y )
			term.setBackgroundColor( color )
			write(" ")
			term.setCursorPos( oldX, oldY )
		end,
		drawStraight = function( startX, y, endX, tcolor )
			local oldX, oldY = term.getCursorPos()
			paintutils.drawLine( startX, y, endX, y, tcolor )
			term.setCursorPos( oldX, oldY )
		end,
		drawCentre = function ( text, y, tc, bg )
			-- body
			local termX, termY = term.getSize()
			text = this.helpers.shorten( text, termX )
			this.drawing.draw( text, y, math.floor(termX/2-(#text/2)), tc, bg ) -- Use draw to make text centered
		end,
		draw = function ( text, y, x, tc, bg )
			if tc then this.helpers.tc( tc ) end
			if bg then this.helpers.bg( bg ) end
			term.setCursorPos( x, y )
			term.clearLine()
			term.write( text )
		end
	}

	clone.filters = {
		default = "normal",
		invert = {

		},
		normal = {
			white = colors.white,
			orange = colors.orange,
			magenta = colors.magenta,
			lightBlue = colors.lightBlue,
			yellow = colors.yellow,
			lime = colors.lime,
			pink = colors.pink,
			gray = colors.gray,
			lightGray = colors.lightGray,
			cyan = colors.cyan,
			purple = colors.purple,
			brown = colors.brown,
			blue = colors.blue,
			green = colors.green,
			red = colors.red,
			black = colors.black
		},
		highlight = {

		},
		grayscale = {
			white = colors.white,
			orange = colors.lightGray,
			magenta = colors.gray,
			lightBlue = colors.lightGray,
			yellow = colors.white,
			lime = colors.white,
			pink = colors.lightGray,
			gray = colors.gray,
			lightGray = colors.lightGray,
			cyan = colors.gray,
			purple = colors.gray,
			brown = colors.black,
			green = colors.lightGray,
			red = colors.gray,
			black = colors.black
		}
	}

	clone.log = {
		config = {
			enabled = true,
			location = "systemLog.log"
		},
		Initialise = function()
			-- Start the log file
			this.log.output( "i", "--== Cap Bank V0.2 ==--", true )
			this.log.output( "i", "     LOG follows:      \n" )
		end,
		output = function( type, text, rewrite )
			if this.log.config.enabled then
				local f
				if rewrite then 
					f = fs.open( this.log.config.location, "w")
				else
					f = fs.open( this.log.config.location, "a")
				end
				local msg = "Info"
				if not type or type == "e" then
					msg = "FATAL"
				elseif type == "w" then
					msg = "Warning"
				end
				text = "[".._G.runningProgram.."] [" ..msg.. "] " .. text .."\n"
				f.write( text )
				f.close()
			end
		end
	}

	clone.helpers = {
		shorten = function(text, limit)
			-- Reduce text size by replace middle of string with "..."
			if #text > limit then
				local extraLength = #text-limit
				local fHalf = text:sub( 0, math.floor(#text/2-1-extraLength/2) )
				local sHalf = text:sub( math.floor(#text/2+1) )
				sHalf = sHalf:sub( (#sHalf - 5 - extraLength/2) * -1 )
				return fHalf .. " ... " .. sHalf
			else
				return text
			end
		end,
		getFilter = function( name )
			if name then
				return this.filters[name]
			else
				return this.filters[ this.filters.default ]
			end
		end,
		getColor = function( color, filter )
			return this.helpers.getFilter(filter)[color]
		end,
		bg = function( color, filter )
			term.setBackgroundColor( this.helpers.getFilter( filter )[color] )
		end,
		tc = function( color, filter )
			term.setTextColor( this.helpers.getFilter( filter )[ color ] )
		end,
		pos = function( x, y )
			term.setCursorPos( x, y )
		end,
		clear = function()
			term.clear()
		end,
		waitForEvent = function( event, textfunc, callback )
			if textfunc then textfunc() end
			while true do
				local e, p1, p2, p3, p4, p5, p6 = os.pullEvent()
				if not event or e == event then
					if callback then
						if callback( e, p1, p2, p3, p4, p5, p6 ) then break end
					else break end
				end
			end
		end
	}

	clone.remote = {
		request = function(url)
			if not http then return false end
			-- try to connect three times
			for i=0, 3 do
				response = http.get( url )
				if response then return response end
			end
			return false
		end,
		getLine = function( url )
			response = this.remote.request( url )
			if response then return response.readLine() or false else return false end
		end,
		getAll = function( url )
			response = this.remote.request( url )
			if response then return response.readAll() or false else return false end
		end
	}

	clone.file = {
		write = function( file, content, mode )
			if fs.isDir( file ) then error"Cannot write to directory" end
			local f = fs.open( file, mode or "w")
			f.write( content )
			f.close()
		end,
		readAll = function( file )
			if not fs.exists(file) or fs.exists(file) and fs.isDir(file) then return false end
			local f = fs.open( file, "r" )
			content = f.readAll()
			f.close()
			return content
		end,
		readLine = function( file )
			if not fs.exists(file) or fs.exists(file) and fs.isDir(file) then return false end
			local f = fs.open( file, "r" )
			content = f.readLine()
			f.close()
			return content
		end
	}

	clone.peripheral = {
		getAllNames = function( oftype )
			--[[
				@return table of sides
			]]
			pers = peripheral.getNames()
			ready = {}
			for i, v in pairs( pers ) do
				if oftype then
					if peripheral.getType( v ) == oftype then
						table.insert( ready, v )
					end
				else
					table.insert( ready, v )
				end
			end
			return ready
		end,
		getAllWraps = function( oftype )
			--[[
				@return table of wraps (for group setting) of all sides (wraps every peripheral that matches @param oftype)
			]]
			pers = peripheral.getNames()
			ready = {}
			for i, v in pairs( pers ) do
				if oftype then
					if peripheral.getType( v ) == oftype then
						table.insert( ready, peripheral.wrap(v) )
					end
				else
					table.insert( ready, peripheral.wrap(v) )
				end
			end
			return ready
		end,
		getWrap = function( side, typeof )
			if typeof and peripheral.getType( side ) == typeof or not typeof and peripheral.isPresent(side) then
				return peripheral.wrap( side )
			else
				return false
			end
		end,
		setGroup = function( wraps, name )
			--[[
				creates a group of peripheral wraps saved with name. Can be accessed with get group
			]]
			this.groups[name] = {}
			for i, v in pairs( wraps ) do
				table.insert( this.groups[name], v )
			end
			return this.groups[name]
		end,
		getGroup = function( name )
			if this.groups[name] then
				return this.groups[name]
			else
				error("No group set with name: "..tostring(name))
			end
		end
	}

	if callback then callback() end
	return clone
end