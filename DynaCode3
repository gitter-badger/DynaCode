--[[

	DynaCode Version 3
	Inspired by JavaFX.

	This is the framework developed by Harry Felton for use in all modern HexCode programs.

	Copyright (c) 2015 Harry Felton, HexCode and all other contributors

]]

local apiCfg = {
	keepUpToDate = true, -- Check for updates the first time a program is created using this version of the API. (.createProgram())
	updatePath = "DynaCodeTEST", -- Where is the API installed
	updateUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/DynaCode3", -- Path to download. This is set to my repository on GitHub.
	versionUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/version", -- Path to version file. This is set to my repository on GitHub.
	versionPath = "DynaCodeVersion", -- Leave as is if you like, or change to a file (ideally in the same directory as DynaCode)
	output = true, -- print information to the screen during update check
	resetScreenPost = true, -- clear the screen after update check (recommended because the text color will be changed)
	clearDelay = 1
}

local updateChecked = false

local function clear()
	term.setBackgroundColor( colors.black )
	term.clear()
	term.setCursorPos(1, 1)
end

local function uPrint( color, ... )
	term.setTextColor( color or colors.white )
	if apiCfg.output then
		print( ... )
	end
	term.setTextColor( colors.white )
end

function getUpdateOutputSetting()
	return apiCfg.output
end

function setUpdateOutputSetting( v )
	apiCfg.output = v
end

function getUpdatePathSetting()
	return apiCfg.updatePath
end

function setUpdatePathSetting( v )
	apiCfg.updatePath = v
end

function getUpdateVersionSetting()
	return apiCfg.versionPath
end

function setUpdateVersionSetting( v )
	apiCfg.versionPath = v
end

function getUpdateResetPostSetting()
	return apiCfg.resetScreenPost
end

function setUpdateResetPostSetting( v )
	apiCfg.resetScreenPost = v
end

function setUpdateAutoSetting( v )
	apiCfg.keepUpToDate = v
end

function getUpdateAutoSetting()
	return apiCfg.keepUpToDate
end

function setUpdateDelaySetting( v )
	apiCfg.clearDelay = v
end

function getUpdateDelaySetting()
	return apiCfg.clearDelay
end

function getVersionData()
	if not http then
		error("Cannot check for updates. ComputerCraft HTTP API is disabled.")
	end
	for i = 1, 3 do
		uPrint( false, "Fetching version information. Attempt "..i.." of 3")
		local response = http.get( apiCfg.versionUrl )
		if response then
			local rData = assert( textutils.unserialize( response.readAll() ), "Remote Version Data Invalid")
			local update = false
			local localData
			local h = fs.open( apiCfg.versionPath, "r" )
			if h then
				localData = textutils.unserialize( h.readAll() )
				if not localData then
					h.close()
					fs.delete( apiCfg.versionPath )
					os.reboot()
				end
				h.close()
				if localData.version ~= rData.version or localData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
			else
				update = true
			end
			if update then uPrint(colors.orange, "DynaCode 3 is out-of-date") else uPrint( colors.lime, "DynaCode 3 is up-to-date") end
			if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
			return update, rData, localData --Returns true if update required and also returns the remote and local version data for manual checks.
		end
	end
	uPrint(colors.red, "Could not fetch version file.")
	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
	return false, nil
end

function installVersionData( rData )
	if not http then
		error("Cannot fetch updates. ComputerCraft HTTP API is disabled.")
	end
	-- @rData is the remoteDataFile.
	-- Open local file and compare
	if not rData or type( rData ) ~= "table" then error("Expected remoteData table, got ".. type( rData )) end
	local h = fs.open( apiCfg.versionPath, "r" )
	local update = false
	local lData
	if not h then update = true else
		lData = textutils.unserialize( h.readAll() )
		h.close()
		if not lData then
			fs.delete( api.versionPath ) --file corrupted, remove it
			os.reboot()
		end
		if lData.version ~= rData.version or lData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
	end

	if update then
		-- fetch update, install and change version file to new remote one passed in installVersionData()
		for i = 1, 3 do
			uPrint(false, "Fetching update files. Attempt ", i, " of 3")
			local response = http.get( apiCfg.updateUrl )
			if response then
				local h = fs.open( apiCfg.updatePath, "w" )
				h.write( response.readAll() )
				h.close()
				h = fs.open( apiCfg.versionPath, "w" )
				h.write( textutils.serialize( rData ) )
				h.close()
				uPrint(colors.lime, "Install complete, rebooting in one second")
				sleep(1)
				os.reboot()
			end
		end
		uPrint(colors.red, "Could not fetch update data")
	end

	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
end

local function getVersion()
	local h = fs.open( apiCfg.versionPath, "r" )
	if not h then
		return { version = "Unknown", build = "Unknown" }
	end
	local cnt = h.readAll()
	h.close()
	if cnt then
		return textutils.unserialize( cnt )
	else
		return { version = "Unknown", build = "Unknown" }
	end
end

local function checkAndProceed()
	local go, data = getVersionData()
	if go and data then
		installVersionData( data )
	end
end

local function copy( tbl )
	if type( tbl ) == "table" then
		-- loop through table, copying keys
		local copy = {}
		for key, value in ipairs(tbl) do
			copy[key] = value
		end
		return copy
	else
		return tbl
	end
end

local function validateRequirements( needed, provided, silent, prefix, suffix )

	if type( needed ) ~= "table" or type( provided ) ~= "table" or ( type( silent ) ~= "nil" and type( silent ) ~= "boolean" ) or ( type( prefix ) ~= "nil" and type( prefix ) ~= "string" ) or ( type( suffix ) ~= "nil" and type( suffix ) ~= "string" ) then
		error("Bad arguments, expected: table, table, boolean(optional), string(optional), string(optional), got: "..type( needed )..", "..type( provided )..", "..type(silent)..", "..type(prefix)..", "..type(suffix), 3)
	end

	-- Loop @provided, then check @needed for the key-value pair found in @provided. If its in their simply remove it.

	local result = copy( needed )

	local function compile( prefix, suffix )
		local msg = prefix or ""
		for k, v in ipairs(result) do
			msg = msg.."- "..tostring(v)
			if k < #result then msg = msg .. "\n" end
		end
		if suffix then msg = msg .. "\n " .. suffix end
		return msg
	end

	for opt in pairs( provided ) do
		for key, req in ipairs( result ) do
			if req == opt then
				table.remove( result, key )
			end
		end
	end

	-- If the length of result is > 0, then not all requirements have been met.

	if #result > 0 then
		if silent then
			return false, compile( prefix or "", suffix or "")
		else
			error( compile( prefix or "", suffix or "" ), 3)
		end
	else
		return true
	end
end

function createProgram( options )
	validateRequirements({ "name" }, options, false, "Missing requirements to initialize program:\n", "\nPlease define the above settings when creating your program instance")
	if not updateChecked and apiCfg.keepUpToDate then
		-- check for updates now
		checkAndProceed()
		updateChecked = true
	end

	local defaults = { backgroundColor = colors.black }

	local objects = { -- program registry
		scenes = {}, -- not drawn, just here to be accessed.
		stages = {}, -- drawn
		dialogs = {}, -- drawn last. Not zbased.
		buffer = {} -- compiled "order" of draw.
	}

	local filters = {
		{
			name = "NORMAL",
			tbl = {
				["white"] = colors.white,
				["orange"] = colors.orange,
				["magenta"] = colors.magenta,
				["lightBlue"] = colors.lightBlue,
				["yellow"] = colors.yellow,
				["lime"] = colors.lime,
				["pink"] = colors.pink,
				["gray"] = colors.gray,
				["lightGray"] = colors.lightGray,
				["cyan"] = colors.cyan,
				["purple"] = colors.purple,
				["blue"] = colors.blue,
				["brown"] = colors.brown,
				["green"] = colors.green,
				["red"] = colors.red,
				["black"] = colors.black
			}
		}
	}

	local clone = {}
	local program = {}
	setmetatable( options, {__index=defaults})
	setmetatable( program, {__index = options})
	-- Each function will use the @self argument to adjust its own settings.

	local function log( msg, mode )
		if program.loggingReady then
			local prefix = "Info"
			if mode == "w" then prefix = "Warn" elseif mode == "e" then prefix = "ERROR" end
			clone.file.append( program.loggingPath, "["..os.clock().."] ["..prefix.."] "..msg.."\n")
		end
	end

	local function filterGet( name )
		if not name then error("Expected string to fetch filter") end
		for k, v in ipairs( filters ) do
			if v.name == name then return v end
		end
		return false
	end

	local function filterRemove( name )
		if not name then error("Expected string to remove filter") end
		for k, v in ipairs( filters ) do
			if v.name == name then
				table.remove( k, filters )
			end
		end
	end

	local function filterAdd( name, tbl )
		if not name or not tbl then
			error("Expected argument of type string and table")
		end
		table.insert( filters, {
			name = name,
			tbl = tbl or {}
		})
	end

	local function getColorFromFilter( filter, cl )
		print( filter )
		if not filter or not cl then
			error("Expected filter string and color string to fetch color from filter.", 3)
		end
		local r = filterGet( filter )
		if not r then
			log("Filter not found in program instance: "..tostring(filter)..". Returning API color by default", "w")
			r = colors
		end
		local c = r.tbl[cl]
		if not c then
			log("Cannot find color ("..tostring(cl)..") in filter, returning WHITE")
			return colors.white
		else
			return c
		end
	end

	clone.setLoggingPath = function( v )
		program.loggingPath = v
	end
	clone.getLoggingPath = function()
		return program.loggingPath
	end

	clone.setLoggingEnabled = function( v )
		program.logging = v
	end
	clone.getLoggingEnabled = function()
		return program.logging
	end

	clone.logToFile = function( content, mode )
		log( content, mode )
	end

	clone.initializeLogFile = function()
		if not program.logging or not program.loggingPath then
			error("Set logging and logging path before initializing", 2)
		end
		local h = fs.open( program.loggingPath, "w" )
		local ver = getVersion()
		if h then
			h.write("--@@@==== DynaCode Logging - Instance: "..program.name.." - ( Version: ".. ver.version .. " - Build: " .. ver.build .." ) ====@@@--\n")
			h.close()
			program.loggingReady = true
		end
	end

	local function registryFetch( nm )

		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					return v
				end
			end
		end
		return false
	end

	local function registryRemove( nm )
		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					table.remove( objects.stages, k )
				end
			end
		end
	end

	local buffer = {

		reorder = function( topLevel )
			local temp = copy( objects.stages )

			-- Set the topLevel stage to level 1
			local i = 1
			for key, stage in ipairs( temp ) do
				if stage.getName() == topLevel then
					stage:setBufferLevel( 1 )
					i = 2
					break
				end
			end
			table.sort(temp, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)
			for key, stage in ipairs( temp ) do
				if stage.getName() ~= topLevel then
					stage:setBufferLevel( i )
					i = i + 1
				end
			end
			table.sort(temp, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)
			objects.buffer = temp
		end,
		redrawAll = function( ignoreRules ) 

			for _, stage in ipairs( objects.buffer ) do
				stage.draw()
			end

		end,
		getHighestLevel = function( nX, nY )
			-- return the first occurrence of a stage at the clicked co-ords. Because the table is sorted correctly, ipairs will result in the

			for i = #objects.buffer, 1, -1 do -- loop table in reverse because the last node is drawn last and is therefore on top of others.
				local stage = registryFetch( objects.buffer[i].getName() )
				if stage then
					local stageX, stageY = stage.getX(), stage.getY()
					if stage.getBorderless() then offset = 0 else offset = 1 end
					if nX >= stageX and nX <= stageX + stage.getWidth() and nY >= stageY and nY <= stageY + stage.getHeight() + offset then
						return stage
					end
				end
			end
		end
	}

	clone.bufferReorder = function( v )
		buffer.reorder( v )
	end

	clone.createStage = function( cfg )

		local stageDefaults = { 
			bufferLevel = 1,
			active = false,
			x = 2,
			y = 2,
			width = 20,
			height = 10,
			backgroundColor = "white",
			lastClickX = 2,
			lastClickY = 2,
			closeButton = true,
			closeButtonColor = "red",
			closeButtonTextColor = "white",
			topBarColor = "gray",
			topBarDisabledColor = "lightGray",
			filter = "NORMAL"
		} -- manual settings override these
		local new = {}
		local settings = {} -- overrides manual settings

		setmetatable( stageDefaults, {__index = defaults})
		setmetatable( cfg, {__index = stageDefaults} )
		setmetatable( settings, {__index=cfg} )


		local function registryUpdate( self )
			for k, v in ipairs( objects.stages ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.stages, k )
					end
				end
			end

			table.insert( objects.stages, self )
		end

		local function getColor( cl )
			local filter = filterGet( settings.filter )
			if not filter then
				log("Cannot find filter: "..tostring(settings.filter).." for stage: "..settings.name, w)
			else
				local c = filter.tbl[cl]
				if c then
					return c
				end
			end
			return colors[cl] or cl or colors.white
		end

		local function draw()
			if settings.borderless then
				clone.canvas.drawArea( settings.x, settings.y, settings.width, settings.height, getColor( settings.backgroundColor ) )
			else
				clone.canvas.drawHLine( settings.x, settings.y, settings.width, getColor( settings.topBarColor ) )
				clone.canvas.drawArea( settings.x, settings.y+1, settings.width, settings.height, getColor( settings.backgroundColor ) )
			end
			if settings.closeButton then
				term.setBackgroundColor( getColor( settings.closeButtonColor ) )
				term.setTextColor( getColor( settings.closeButtonTextColor ) )
				term.setCursorPos( settings.x + settings.width, settings.y )
				write("X")
			end
			term.setBackgroundColor( program.backgroundColor )
		end

		local function handleMouseClick( self, event, button, nX, nY )
			if nX == settings.x+settings.width and nY == settings.y and settings.closeButton then
				self.destroy()
				term.clear()
				buffer.reorder()
				buffer.redrawAll()
			else
				settings.lastClickX, settings.lastClickY = nX, nY
			end
		end
		local function handleMouseScroll( self, event, direction, nX, nY )

		end
		local function handleMouseDrag( self, event, button, nX, nY )
			local termX, termY = term.getSize()
			-- if the last click was on the top bar, then allow drag.
			if settings.lastClickX >= settings.x and settings.lastClickX <= settings.x + settings.width and settings.lastClickY == settings.y then
				local oldX, oldY = settings.lastClickX, settings.lastClickY
				if nX < settings.lastClickX and settings.x - 1 > 0 then
					settings.x = settings.x - 1
				elseif nX > settings.lastClickX and settings.x + settings.width < termX then
					settings.x = settings.x + 1
				elseif nY < settings.lastClickY and settings.y - 1 > 0 then
					settings.y = settings.y - 1
				elseif nY > settings.lastClickY and nY + settings.height < termY then
					settings.y = settings.y + 1
				end
				if settings.y ~= oldY or settings.x ~= oldX then
					term.clear()
					buffer.redrawAll()
				end
				settings.lastClickX, settings.lastClickY = nX, nY
			end
		end
		local function handleKeyPress( self, event, key, held )

		end
		local function handleCharPress( self, event, key )

		end

		local function focus()
			-- set all other stages to active = false.
			settings.active = true
		end

		local function blur()
			-- set all other stages to active = false.
			settings.active = false
		end

		-- add this stage to the object storage.

		new.draw = function( self )
			if not registryFetch( settings.name ) then error("Stage must be built before drawing") end
			draw()
		end

		new.setColorFilter = function( filterName )
			settings.filter = filterName
		end

		new.test = function(cl)
			print( getColor( cl ) )
		end

		new.getType = function() return "stage" end

		new.getActive = function() return settings.active end

		new.setBufferLevel = function( self, v )
			settings.bufferLevel = v
		end
		new.getBufferLevel = function( self )
			return settings.bufferLevel
		end

		new.setExample = function( self, v )
			settings.example = v
		end
		new.getExample = function( self )
			return settings.example
		end

		new.getX = function( self )
			return settings.x
		end

		new.setX = function( self, v )
			settings.x = v
		end

		new.getY = function( self ) 
			return settings.y
		end
		new.setY = function( self, v ) 
			settings.y = v
		end
		new.getWidth = function() return settings.width end
		new.getHeight = function() return settings.height end

		new.setBackgroundColor = function( self, v ) 
			settings.backgroundColor = v
		end
		new.getBackgroundColor = function( self ) 
			return settings.backgroundColor
		end

		new.setBorderless = function( self, v ) 
			settings.borderless = v
		end
		new.getBorderless = function( self ) 
			return settings.borderless
		end

		new.setCloseable = function( self, v ) 
			settings.closeable = v
		end
		new.getCloseable = function( self ) 
			return setting.closeable
		end

		new.setMoveable = function( self, v ) 
			settings.moveable = v
		end
		new.getMoveable = function( self ) 
			return settings.moveable
		end

		new.setBorderBackgroundColor = function( self, v ) 
			settings.borderBackgroundColor = v
		end
		new.getBorderBackgroundColor = function( self ) 
			return settings.borderBackgroundColor
		end

		new.setBorderTextColor = function( self, v ) 
			settings.borderTextColor = v
		end
		new.getBorderTextColor = function( self ) 
			return settings.borderTextColor
		end

		new.setBorderCloseBackgroundColor = function( self, v ) 
			settings.borderCloseBackgroundColor = v
		end
		new.getBorderCloseBackgroundColor = function( self ) 
			return settings.borderCloseBackgroundColor
		end

		new.setBorderCloseTextColor = function( self, v ) 
			settings.borderCloseTextColor = v
		end
		new.getBorderCloseTextColor = function( self ) 
			return settings.borderCloseTextColor
		end

		new.setBorderCloseText = function( self, v ) 
			settings.borderCloseText = v
		end
		new.getBorderCloseText = function( self ) 
			return settings.borderCloseText
		end

		new.setTitle = function( self, v ) 
			settings.title = v
		end
		new.getTitle = function( self ) 
			return settings.title
		end

		new.setTitleOverflow = function( self, v ) 
			settings.titleOverflow = v
		end
		new.getTitleOverflow = function( self ) 
			return settings.titleOverflow
		end

		new.setTitleCenter = function( self, v )
			setting.titleCenter = v
		end
		new.getTitleCenter = function( self )
			return settings.titleCenter
		end

		new.setFocus = function( self, v ) 
			focus( v )
		end
		new.getFocus = function( self ) 
			return settings.isActive
		end

		new.getName = function( self )
			return settings.name
		end

		new.getFromRegistry = function( self )
			return registryFetch( self:getName() )
		end

		new.updateToRegistry = function( self )
			registryUpdate( self )
		end

		new.removeFromRegistry = function( self )
			registryRemove( self:getName() )
		end

		new.setScene = function( self, v )
			settings.scene = v
		end

		new.getScene = function( self )
			return settings.scene
		end

		new.runEvent = function( self, e, p1, p2, p3, p4 )
			-- if its not active, and the event was a mouse click, check if in bounds. If it isn't clicked on deactivate it, if it is activate it.
			if e == "mouse_click" then
				if settings.borderless then offset = 0 else offset = 1 end
				if p2 >= settings.x and p2 <= settings.x + settings.width and p3 >= settings.y and p3 <= settings.y + settings.height + offset then
					-- if the window is the highest level.
					local high = buffer.getHighestLevel( p2, p3 )
					if high and high:getName() == settings.name then
						settings.active = true
						buffer.reorder( settings.name ) --set this window to the top
						buffer.redrawAll()
					end
				else
					settings.active = false
				end
			end
			if settings.active then
				if e == "mouse_click" then
					handleMouseClick( self, e, p1, p2, p3 )
				elseif e == "mouse_scroll" then
					handleMouseScroll( self, e, p1, p2, p3 )
				elseif e == "mouse_drag" then
					handleMouseDrag( self, e, p1, p2, p3 )
				elseif e == "key" then
					handleKeyPress( self, e, p1, p2 )
					print( keys[p1] or p1 )
				elseif e == "char" then
					handleCharPress( self, e, p1 )
				elseif e == "terminate" and settings.allowTerminate then
					registryRemove( self, settings.name )
				end
			end
		end

		new.destroy = function( self )
			-- if stage is in registry remove it, also stop loop
			registryRemove( settings.name )
		end

		new.build = function( self )
			-- add stage to registry
			registryUpdate( self )
		end

		return new

	end

	clone.createScene = function( cfg )
		local sceneDefault = {}
		local new = {}
		local settings = {
			nodes = {}
		}

		-- The scene is attached to a stage. The scene _can_ be used on multiple stages.

		-- If the scene is fetched from a stage, and changed it will affect all stages using the scene.

		-- If the scene is changed from a local variable, and changed it will also affect all stages using this scene.

		setmetatable( sceneDefault, {__index=defaults})
		setmetatable( cfg, {__index=sceneDefault})
		setmetatable( settings, {__index = cfg})


		local function registryUpdate( self )
			for k, v in ipairs( objects.scenes ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.scenes, k )
					end
				end
			end

			table.insert( objects.scenes, self )
		end

		new.getType = function() return "scene" end

		new.getName = function() return settings.name end

		new.relaceWithFile = function( self )

		end
		new.appendFromFile = function( self )

		end

		new.addNode = function( self, v )

		end
		new.removeNode = function( self )

		end
		new.clearNodes = function( self )
			settings.nodes = {}
			-- redraw window
		end
		new.getNodes = function( self )
			return settings.nodes
		end

		new.getFromRegistry = function( self )
			return registryFetch( self:getName() )
		end
		new.updateToRegistry = function( self )
			registryUpdate( self )
		end
		new.removeFromRegistry = function( self )
			registryRemove( self:getName() )
		end

		new.setExample = function( self, v )
			settings.ex = v
		end
		new.getExample = function( self )
			return settings.ex
		end

		registryUpdate( new )

		return new

	end

	clone.createButton = function( cfg )
		local buttonDefaults = {}
		local settings = {}
		local new = {}

		setmetatable( buttonDefaults, {__index = defaults})
		setmetatable( cfg, {__index = buttonDefaults})
		setmetatable( settings, {__index = cfg})


		new.setBackgroundColor = function( self, v ) 
			settings.backgroundColor = v
		end
		new.getBackgroundColor = function( self ) 
			return settings.backgroundColor
		end

		new.setText = function( self, v ) 
			settings.text = v
		end
		new.getText = function( self ) 
			return settings.text
		end

		new.setTextColor = function( self, v ) 
			settings.textColor = v
		end
		new.getTextColor = function( self ) 
			return settings.textColor
		end

		new.setCanBeToggled = function( self, v ) 
			settings.canBeToggled = v
		end
		new.getCanBeToggled = function( self ) 
			return settings.canBeToggled
		end

		new.setToggledBackgroundColor = function( self, v ) 
			settings.toggledBackgroundColor = v
		end
		new.getToggledBackgroundColor = function( self ) 
			return settings.toggledBackgroundColor
		end

		new.setToggledText = function( self, v ) 
			settings.toggledText = v
		end
		new.getToggledText = function( self ) 
			return settings.toggledText
		end

		new.setMaxwidth = function( self, v ) 
			settings.maxWidth = v
		end
		new.getMaxwidth = function( self ) 
			return settings.maxWidth
		end

		new.setHeight = function( self, v ) 
			settings.height = v
		end
		new.getHeight = function( self ) 
			return settings.height
		end

		new.setToggledTextColor = function( self, v ) 
			settings.toggledTextColor = v
		end
		new.getToggledTextColor = function( self ) 
			return settings.toggledTextColor
		end

		new.setX = function( self, v ) 
			settings.x = v
		end
		new.getX = function( self ) 
			return settings.x
		end

		new.setY = function( self, v ) 
			settings.y = v
		end
		new.getY = function( self ) 
			return settings.y
		end


		-- A node is not added to its own registry. It is added to the scenes node dictionary.

		-- Any changes made to the node via local variable, scene get or stage-scene fetch will be reflected across all scenes using this button.
		return new


	end
	clone.createParagraph = function() end
	clone.createScroll = function() end
	clone.createList = function() end

	clone.getStageFromRegistry = function( name ) -- returns stage from registry. (stage:updateToRegistry())
		return registryFetch( name )
	end

	clone.startWindows = function( callback )
		-- starts each windows event loop.
		-- When a stage is destroyed, it will be stopped and must be "rebuilt" in order to function again.
		local function exeOnEach( e, p1, p2, p3, p4 )
			for _, stage in ipairs( objects.stages ) do
				stage:runEvent( e, p1, p2, p3, p4 )
			end
		end
		local function loop()
			while true do
				local e, p1, p2, p3, p4 = os.pullEventRaw()
				if e == "program_stop"..program.name then
					break
				else
					exeOnEach( e, p1, p2, p3, p4 )
				end
			end
		end
		if callback and type( callback ) == "function" then
			parallel.waitForAll( loop, callback )
		else
			loop()
		end
	end

	clone.getObjects = function() return objects end

	clone.file = {
		getHandle = function( path, mode )
			if fs.exists( path ) then
				return fs.open( path, mode or "r" )
			else
				return false
			end
		end,
		write = function( path, content )
			local h = fs.open( path, "w" )
			h.write( content )
			h.close()
			return true
		end,
		append = function( path, content )
			local h = clone.file.getHandle( path, "a" )
			if h then
				h.write( content )
				h.close()
				return true
			else
				return false
			end
		end,
		writeLine = function( path, content )
			local h = fs.open( path, "r" )
			h.writeLine( content )
			h.close()
			return true
		end,
		getLine = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readLine()
				h.close()
				return cnt
			else
				return false
			end
		end,
		getAll = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readAll()
				h.close()
				return cnt
			else
				return false
			end
		end
	}

	clone.createFilter = function( name, tbl ) filterAdd( name, tbl ) end

	clone.getFilterObject = function( name )
		return filterGet( name )
	end

	clone.getColorFromFilter = function( filter, cl )
		return getColorFromFilter( filter, cl )
	end

	clone.canvas = {
		drawArea = function( nX, nY, width, height, background )
			if height < 1 or width < 1 then
				error("Height and width must be greater than 1 to draw a box")
			end
			for i = nY, nY + height do
				clone.canvas.drawHLine( nX, i, width, background )
			end
		end,
		drawHLine = function( nX, nY, width, background )
			paintutils.drawLine( nX, nY, nX+width, nY, background )
		end,
		drawVLine = function( nX, nY, height, background )
			paintutils.drawLine( nX, nY, nX, nY+height, background )
		end,
		drawText = function() end,
		drawCText = function() end
	}

	clone.remote = {
		fetch = function( url )
			for i = 1, 3 do
				local response = http.get( url )
				if response then
					return response
				end
			end
			return false
		end,
		fetchLine = function( url )
			local response = clone.remote.fetch( url )
			if not response then return false else return response.readLine() end
		end,
		fetchAll = function( url )
			local response = clone.remote.fetch( url )
			if not response then return false else return response.readAll() end
		end
	}

	return clone

end