--[[

	DynaCode
	Inspired by JavaFX.

	This is the framework developed by Harry Felton for use in all modern HexCode programs.

	Copyright (c) 2015 Harry Felton, HexCode and all other contributors

	Current To-Do (* = doing now):
	- Limited buffer redraw (only redraws what is needed)*
	- Button Nodes
	- Scenes

	Upcoming To-Do:
	- DCML Expansion and conversion to nodes.
	- Text Node (wrapping text)
	- Scroll List, List node
	- Display List (context menu style)

]]


local oTerm = term.current()

local function restore()
	term.redirect( oTerm )
end

local write = oTerm.write
local oError = _G.error
local function error( msg, level )
	-- restore the term
	restore()
	if not level then level = 2 else level = level + 1 end
	oError( msg, level )
end

local apiCfg = {
	keepUpToDate = true, -- Check for updates the first time a program is created using this version of the API. (.createProgram())
	updatePath = "DynaCodeTEST", -- Where is the API installed
	updateUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/DynaCode", -- Path to download. This is set to my repository on GitHub.
	versionUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/version", -- Path to version file. This is set to my repository on GitHub.
	versionPath = "DynaCodeVersion", -- Leave as is if you like, or change to a file (ideally in the same directory as DynaCode)
	output = true, -- print information to the screen during update check
	resetScreenPost = true, -- clear the screen after update check (recommended because the text color will be changed)
	clearDelay = 1
}

local updateChecked = false

local function clear()
	term.setBackgroundColor( colors.black )
	term.clear()
	term.setCursorPos(1, 1)
end

local function uPrint( color, ... )
	term.setTextColor( color or colors.white )
	if apiCfg.output then
		print( ... )
	end
	term.setTextColor( colors.white )
end

function getUpdateOutputSetting()
	return apiCfg.output
end

function setUpdateOutputSetting( v )
	apiCfg.output = v
end

function getUpdatePathSetting()
	return apiCfg.updatePath
end

function setUpdatePathSetting( v )
	apiCfg.updatePath = v
end

function getUpdateVersionSetting()
	return apiCfg.versionPath
end

function setUpdateVersionSetting( v )
	apiCfg.versionPath = v
end

function getUpdateResetPostSetting()
	return apiCfg.resetScreenPost
end

function setUpdateResetPostSetting( v )
	apiCfg.resetScreenPost = v
end

function setUpdateAutoSetting( v )
	apiCfg.keepUpToDate = v
end

function getUpdateAutoSetting()
	return apiCfg.keepUpToDate
end

function setUpdateDelaySetting( v )
	apiCfg.clearDelay = v
end

function getUpdateDelaySetting()
	return apiCfg.clearDelay
end

function getVersionData( silent )
	if not http then
		if silent then error("getVersionData: Cannot check for updates. ComputerCraft HTTP API is disabled.") else return false, "HTTP Disabled" end
	end
	for i = 1, 3 do
		uPrint( false, "Fetching version information. Attempt "..i.." of 3")
		local response = http.get( apiCfg.versionUrl )
		if response then
			local rData = textutils.unserialize( response.readAll() )
			if not rData then
				if not silent then
					error("getVersionData: Remote Version Data Invalid")
				else
					return false, "getVersionData: Remote Version Data Invalid"
				end
			end
			local update = false
			local localData
			local h = fs.open( apiCfg.versionPath, "r" )
			if h then
				localData = textutils.unserialize( h.readAll() )
				if not localData then
					h.close()
					fs.delete( apiCfg.versionPath )
					os.reboot()
				end
				h.close()
				if localData.version ~= rData.version or localData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
			else
				update = true
			end
			if update then uPrint(colors.orange, "DynaCode 3 is out-of-date") else uPrint( colors.lime, "DynaCode 3 is up-to-date") end
			if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
			if update then
				return update, rData, localData or true
			else
				return update, rData, localData --Returns true if update required and also returns the remote and local version data for manual checks.
			end
		end
	end
	uPrint(colors.red, "Could not fetch version file.")
	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
	return false, "Could not fetch version file"
end

function installVersionData( rData, silent )
	if not http then
		if not silent then error("installVersionData: Cannot fetch updates. ComputerCraft HTTP API is disabled.") else return false, "HTTP Disabled" end
	end
	-- @rData is the remoteDataFile.
	-- Open local file and compare
	if not rData or type( rData ) ~= "table" then if not silent then error("installVersionData: Expected table, got ".. type( rData )) else return false, "Invalid Version Data" end end
	local h = fs.open( apiCfg.versionPath, "r" )
	local update = false
	local lData
	if not h then update = true else
		lData = textutils.unserialize( h.readAll() )
		h.close()
		if not lData then
			fs.delete( api.versionPath ) --file corrupted, remove it
			os.reboot()
		end
		if lData.version ~= rData.version or lData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
	end

	if update then
		-- fetch update, install and change version file to new remote one passed in installVersionData()
		for i = 1, 3 do
			uPrint(false, "Fetching update files. Attempt ", i, " of 3")
			local response = http.get( apiCfg.updateUrl )
			if response then
				local h = fs.open( apiCfg.updatePath, "w" )
				h.write( response.readAll() )
				h.close()
				h = fs.open( apiCfg.versionPath, "w" )
				h.write( textutils.serialize( rData ) )
				h.close()
				uPrint(colors.lime, "Install complete, rebooting in one second")
				if not silent then
					sleep(1)
					os.reboot()
				else return true end
			end
		end
		uPrint(colors.red, "Could not fetch update data")
	end

	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
end

local function getVersion()
	local h = fs.open( apiCfg.versionPath, "r" )
	if not h then
		return { version = "Unknown", build = "Unknown" }
	end
	local cnt = h.readAll()
	h.close()
	if cnt then
		return textutils.unserialize( cnt )
	else
		return { version = "Unknown", build = "Unknown" }
	end
end

local function checkAndProceed()
	local go, data = getVersionData()
	if go and data then
		installVersionData( data )
	end
end

local function attemptInstall()
	local old = apiCfg.output
	apiCfg.output = false
	print("Missing Files! Attempting to fetch")

	local function printError( err )
		print("DynaCode is missing files, while trying to fetch them we encountered a problem: "..tostring( err ))
		sleep(5)
		return false
	end

	local go, data, confirm = getVersionData( true )
	if go and data and confirm then
		local success, err = installVersionData( data, true )
		if success then
			print("Finished fetching required files")
			sleep(1)
			os.reboot()
		else
			printError( err )
		end
	elseif not go and not confirm then
		printError( data )
	else
		print("No files are required")
	end
end

local h = fs.open( apiCfg.versionPath, "r" )
if h then
	local r = h.readAll()
	h.close()
	if not r then
		attemptInstall()
	elseif r then
		r = textutils.unserialize( r )
		if not r then
			attemptInstall()
		elseif r then
			_G._DYNACODE = r
		end
	end
else
	attemptInstall()
end

local function copy( tbl )
	if type( tbl ) == "table" then
		-- loop through table, copying keys
		local copy = {}
		for key, value in ipairs(tbl) do
			copy[key] = value
		end
		return copy
	else
		return tbl
	end
end

local function validateRequirements( needed, provided, silent, prefix, suffix )

	if type( needed ) ~= "table" or type( provided ) ~= "table" or ( type( silent ) ~= "nil" and type( silent ) ~= "boolean" ) or ( type( prefix ) ~= "nil" and type( prefix ) ~= "string" ) or ( type( suffix ) ~= "nil" and type( suffix ) ~= "string" ) then
		error("validateRequirements: Expected: table, table, boolean(optional), string(optional), string(optional), got: "..type( needed )..", "..type( provided )..", "..type(silent)..", "..type(prefix)..", "..type(suffix), 3)
	end

	-- Loop @provided, then check @needed for the key-value pair found in @provided. If its in their simply remove it.

	local result = copy( needed )

	local function compile( prefix, suffix )
		local msg = prefix or ""
		for k, v in ipairs(result) do
			msg = msg.."- "..tostring(v)
			if k < #result then msg = msg .. "\n" end
		end
		if suffix then msg = msg .. "\n " .. suffix end
		return msg
	end

	for opt in pairs( provided ) do
		for key, req in ipairs( result ) do
			if req == opt then
				table.remove( result, key )
			end
		end
	end

	-- If the length of result is > 0, then not all requirements have been met.

	if #result > 0 then
		if silent then
			return false, compile( prefix or "", suffix or "")
		else
			error( compile( prefix or "", suffix or "" ), 3)
		end
	else
		return true
	end
end

function createProgram( options )
	validateRequirements({ "name" }, options, false, "Missing requirements to initialize program:\n", "\nPlease define the above settings when creating your program instance")
	if not updateChecked and apiCfg.keepUpToDate then
		-- check for updates now
		checkAndProceed()
		updateChecked = true
	end

	local termX, termY = term.getSize()

	local defaults = { backgroundColor = colors.black, debug = true, debugWait = 0.5, debugPauseOnException = true, catchErrors = true, customErrorCB = false, restartTimer = 10 }

	local objects = { -- program registry
		scenes = {}, -- not drawn, just here to be accessed.
		stages = {}, -- drawn
		dialogs = {}, -- drawn last. Not zbased.
		buffer = {} -- compiled "order" of draw.
	}

	local filters = {
		{
			name = "NORMAL",
			tbl = {
				["white"] = colors.white,
				["orange"] = colors.orange,
				["magenta"] = colors.magenta,
				["lightBlue"] = colors.lightBlue,
				["yellow"] = colors.yellow,
				["lime"] = colors.lime,
				["pink"] = colors.pink,
				["gray"] = colors.gray,
				["lightGray"] = colors.lightGray,
				["cyan"] = colors.cyan,
				["purple"] = colors.purple,
				["blue"] = colors.blue,
				["brown"] = colors.brown,
				["green"] = colors.green,
				["red"] = colors.red,
				["black"] = colors.black
			}
		},
		{
			name = "_UNFOCUSED",
			tbl = {
				["white"] = colors.lightGray,
				["orange"] = colors.lightGray,
				["magenta"] = colors.lightGray,
				["lightBlue"] = colors.lightGray,
				["yellow"] = colors.gray,
				["lime"] = colors.lightGray,
				["pink"] = colors.lightGray,
				["gray"] = colors.gray,
				["lightGray"] = colors.lightGray,
				["cyan"] = colors.lightGray,
				["purple"] = colors.lightGray,
				["blue"] = colors.lightGray,
				["brown"] = colors.lightGray,
				["green"] = colors.lightGray,
				["red"] = colors.lightGray,
				["black"] = colors.gray
			}
		}
	}

	local clone = {}
	local program = {}
	setmetatable( options, {__index=defaults})
	setmetatable( program, {__index = options})
	-- Each function will use the @self argument to adjust its own settings.

	local function log( msg, mode )
		if program.loggingReady and program.logging then
			local prefix = "Info"
			if mode == "w" then prefix = "Warn" elseif mode == "e" then prefix = "ERROR" end
			clone.file.append( program.loggingPath, "["..os.clock().."] ["..prefix.."] "..msg.."\n")
		end
		if program.debug then
			if mode == "w" or mode == "e" then term.setTextColor( colors.red ) end
			term.setBackgroundColor( colors.black )
			print( "DEBUG OUTPUT: "..tostring( msg ) )
			term.setTextColor( colors.white )
			if program.debugWait and ( mode == "i" or not mode ) then sleep( program.debugWait ) end
			if program.debugPauseOnException then
				if mode == "w" then
					print("Warning Caught - Press any key to continue")
					os.pullEventRaw("key")
				elseif mode == "e" then
					print("Exception Caught - Press any key to continue")
					os.pullEventRaw("key")
				end
			end
		end
	end

	local function filterGet( name )
		if not name then error("filterGet: Expected string to fetch filter") end
		for k, v in ipairs( filters ) do
			if v.name == name then return v end
		end
		return false
	end

	local function filterRemove( name )
		if not name then error("filterRemove: Expected string to remove filter") end
		for k, v in ipairs( filters ) do
			if v.name == name then
				table.remove( k, filters )
			end
		end
	end

	local function filterAdd( name, tbl )
		if not name or not tbl then
			error("filterAdd: Expected argument of type string and table")
		end
		table.insert( filters, {
			name = name,
			tbl = tbl or {}
		})
	end

	local function getColorFromFilter( filter, cl )
		if not filter or not cl then
			error("getColorFromFilter: Expected filter string and color string to fetch color from filter.", 3)
		end
		local r = filterGet( filter )
		local c
		if not r then
			log("getColorFromFilter: Filter not found in program instance: "..tostring(filter)..". Returning API color by default", "e")
			r = colors
			c = r[cl]
		else
			c = r.tbl[cl]
		end
		if not c then
			log("getColorFromFilter: Cannot find color ("..tostring(cl)..") in filter, returning WHITE", "w")
			return colors.white
		else
			return c
		end
	end

	function clone.setLoggingPath( v )
		program.loggingPath = v
	end
	function clone.getLoggingPath()
		return program.loggingPath
	end

	function clone.setLoggingEnabled( v )
		program.logging = v
	end
	function clone.getLoggingEnabled()
		return program.logging
	end

	function clone.logToFile( content, mode )
		log( content, mode )
	end

	function clone.initializeLogFile()
		if not program.logging or not program.loggingPath then
			error("Set logging and logging path before initializing", 2)
		end
		local h = fs.open( program.loggingPath, "w" )
		local ver = getVersion()
		if h then
			h.write("--@@@==== DynaCode Logging - Instance: "..program.name.." - ( Version: ".. ver.version .. " - Build: " .. ver.build .." ) ====@@@--\n")
			h.close()
			program.loggingReady = true
		end
	end

	local function registryFetch( nm )

		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					return v
				end
			end
		end
		return false
	end

	local function registryRemove( nm )
		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					table.remove( objects.stages, k )
				end
			end
		end
	end

	local buffer = {

		reorder = function( topLevel )
			local temp = copy( objects.stages )

			-- Set the topLevel stage to level 1
			local i = 1
			for key, stage in ipairs( temp ) do
				if stage.getName() == topLevel then
					stage:setBufferLevel( 1 )
					i = 2
					break
				end
			end
			table.sort(temp, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)
			for key, stage in ipairs( temp ) do
				if stage.getName() ~= topLevel then
					stage:setBufferLevel( i )
					i = i + 1
				end
			end
			table.sort(temp, function( a, b ) return a.getBufferLevel() > b.getBufferLevel() end)
			objects.buffer = temp
			log("Reordered Buffer, On top: "..(function() if type ( topLevel ) == "string" then return topLevel else return "undefined" end end)())
		end,
		redrawAll = function( ignoreRules )
			local oldX, oldY = term.getCursorPos()
			term.setCursorBlink( false )
			for _, stage in ipairs( objects.buffer ) do
				stage.draw()
			end
			term.setCursorPos( oldX, oldY )

		end,
		getHighestLevel = function( nX, nY )
			-- return the first occurrence of a stage at the clicked co-ords. Because the table is sorted correctly, ipairs will result in the

			for i = #objects.buffer, 1, -1 do -- loop table in reverse because the last node is drawn last and is therefore on top of others.
				local stage = registryFetch( objects.buffer[i].getName() )
				if stage then
					local stageX, stageY = stage.getPos()
					if stage.getBorderless() then offset = 0 else offset = 1 end
					if nX >= stageX and nX <= stageX + stage.getWidth() and nY >= stageY and nY <= stageY + stage.getHeight() + offset then
						return stage
					end
				end
			end
		end,
		drawBounds = function( sX, sY, eX, eY )
			-- sX and sY, startX and startY.
			-- eX and eY, endX and endY.
			-- Draw these pixels on the windows.

			-- First, clear the area by drawing a box.
			clone.drawing.drawArea( sX, sY, sX-eX, sY-eY, colors.red )
			local bounds = {}
			-- Now, order the windows to redraw the bounds given.
			for k, v in ipairs( objects.stages ) do
				v:drawBounds( bounds )
			end
		end
	}

	function clone.bufferRedrawAll()
		buffer.redrawAll()
	end

	function clone.setDebug( v )
		program.debug = v
	end

	function clone.setDebugSleep( v ) program.debugWait = v end

	function clone.setDebugPauseOnException( v ) program.debugPauseOnException = v end

	function clone.bufferReorder( v )
		buffer.reorder( v )
	end

	function clone.createStage( cfg )
		--[[ 
			Every time a stage is focused, redirect the term to it. That way any print, writes etc.. can be output to the buffer. Thus, allowing shell programs to be
			run in a window without any adjustments for DynaCode. (because write/print and other term.functions will be redirected to a DynaCode function)
		]]
		local stageDefaults = {
			bufferLevel = 1,
			active = false,
			x = 2,
			y = 2,
			width = 12,
			height = 5,
			backgroundColor = "white",
			lastClickX = 2,
			lastClickY = 2,
			closeButton = true,
			closeButtonColor = "red",
			closeButtonTextColor = "white",
			topBarColor = "gray",
			topBarDisabledColor = "lightGray",
			filter = "NORMAL",
			moveable = true,
			fullscreen = false,
			eventWhitelist = {},
			eventBlacklist = {}
		} -- manual settings will override these
		local window, windowBuffer, new, settings = {}, {}, {}, {}
		setmetatable( stageDefaults, {__index = defaults})
		setmetatable( cfg, {__index = stageDefaults} )
		setmetatable( settings, {__index=cfg} )

		local bufferDefaults = {
			cursorBlink = false, 
			backgroundColor = settings.backgroundColor, 
			textColor = settings.textColor, 
			cX = 1, 
			cY = 1
		}
		setmetatable( windowBuffer, {__index=bufferDefaults})


		local function registryUpdate( self )
			for k, v in ipairs( objects.stages ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.stages, k )
					end
				end
			end

			table.insert( objects.stages, self )
		end

		local function getColor( cl )
			local filter
			if settings.active then
				filter = filterGet( settings.filter )
			else
				filter = filterGet( "_UNFOCUSED" )
			end
			if not filter then
				log("Cannot find filter: "..tostring(settings.filter).." for stage: "..settings.name, w)
			else
				local c = filter.tbl[cl]
				if c then
					return c
				end
			end
			return colors[cl] or cl or colors.white
		end

		local function draw()
			local oX, oY = term.getCursorPos()
			if settings.borderless then
				clone.canvas.drawArea( settings.x, settings.y, settings.width-1, settings.height-1, getColor( settings.backgroundColor ) )
			else
				clone.canvas.drawHLine( settings.x, settings.y, settings.width-1, getColor( settings.topBarColor ) )
				clone.canvas.drawArea( settings.x, settings.y+1, settings.width-1, settings.height-1, getColor( settings.backgroundColor ) )
			end
			term.setBackgroundColor( getColor( settings.topBarColor ) )
			if settings.title then
				if settings.width - 4 >= 1 then
					if #settings.title > settings.width - 4 then	
						local stripped = settings.title:sub(1, settings.width-4)
						term.setCursorPos( settings.x, settings.y )
						write( stripped .. ".." )
					else
						term.setCursorPos( settings.x, settings.y )
						write( settings.title )
					end
				else
					term.setCursorPos( settings.x, settings.y )
					if settings.closeButton then
						write( ("."):rep( settings.width - 1 ) )
					else
						write( ("."):rep( settings.width ) )
					end
				end
			end
			if settings.closeButton then
				term.setBackgroundColor( getColorFromFilter( settings.filter, settings.closeButtonColor ) )
				term.setTextColor( getColorFromFilter( settings.filter, settings.closeButtonTextColor ) )
				term.setCursorPos( settings.x + settings.width-1, settings.y )
				write("X")
			end
			term.setCursorPos( oX, oY )
			term.setBackgroundColor( program.backgroundColor )
		end

		local function close()
			registryRemove( settings.name )
			term.clear()
			buffer.reorder()
			buffer.redrawAll()
		end

		local function handleMouseClick( self, event, button, nX, nY )
			if nX == settings.x+settings.width-1 and nY == settings.y and settings.closeButton then
				close()
			else
				settings.lastClickX, settings.lastClickY = nX, nY
			end
		end
		local function handleMouseScroll( self, event, direction, nX, nY )

		end
		local function handleMouseDrag( self, event, button, nX, nY )
			local termX, termY = term.getSize()
			-- if the last click was on the top bar, then allow drag.
			if settings.lastClickX >= settings.x and settings.lastClickX <= settings.x + settings.width and settings.lastClickY == settings.y and settings.moveable and settings.active then
				local oldX, oldY = settings.lastClickX, settings.lastClickY
				if nX < settings.lastClickX and settings.x - 1 > 0 then
					settings.x = settings.x - 1
				elseif nX > settings.lastClickX and settings.x + settings.width < termX then
					settings.x = settings.x + 1
				elseif nY < settings.lastClickY and settings.y - 1 > 0 then
					settings.y = settings.y - 1
				elseif nY > settings.lastClickY and nY + settings.height < termY then
					settings.y = settings.y + 1
				end
				if settings.y ~= oldY or settings.x ~= oldX then
					term.clear()
					buffer.redrawAll()
				end
				settings.lastClickX, settings.lastClickY = nX, nY
			end
		end
		local function handleKeyPress( self, event, key, held )

		end
		local function handleCharPress( self, event, key )

		end

		local function focus()
			-- set all other stages to active = false.
			settings.active = true
			buffer.reorder( settings.name )
		end

		local function blur()
			-- set all other stages to active = false.
			settings.active = false
		end

		-- Terminal Integration and coroutines
		local runningProgram, pgPath, redirect = false, false, {}
		setmetatable( new, {__index=redirect}) -- allows redirect methods to be used like <stage>.[termMethod](...)
		function new.getRunningProgram()
			return runningProgram -- either false or a coroutine.
		end

		function new.getTerm() return redirect end

		local function internalBlit()

		end

		local function updateCursorBlink()
			oTerm.setCursorBlink( windowBuffer.cursorBlink )
		end

		local function updateCursorPos()
			local offset = ( function() if settings.borderless then return 1 else return 0 end end)()
			oTerm.setCursorPos( settings.x + windowBuffer.cX - 1, settings.y + windowBuffer.cY - offset )
		end

		local function redirectDraw()
			local offset = ( function() if settings.borderless then return 1 else return 0 end end)()
			oTerm.setCursorBlink( false )
			for line = 1, settings.height do
				for char = 1, settings.width do
					local letter = windowBuffer[line][char]
					if letter.text ~= " " then
						--error( letter.textColor )
						oTerm.setBackgroundColor( letter.backgroundColor )
						oTerm.setTextColor( letter.textColor )
						oTerm.setCursorPos( settings.x + char - 1, settings.y + line - offset )
						oTerm.write( letter.text )
					end
				end
			end
			oTerm.setBackgroundColor( program.backgroundColor )
			oTerm.setCursorPos( windowBuffer.cX + settings.x - 1, windowBuffer.cY + settings.y - offset )
			updateCursorBlink()
		end

		local function setupBuffer()
			-- create buffer table
			local lastX, lastY = 1, 1
			for height = 1, settings.height+1 do
				windowBuffer[height] = ( function( height ) if windowBuffer[height] then return windowBuffer[height] else return {} end end )( height )
				lastY = height
				for width = 1, settings.width+1 do
					windowBuffer[height][width] = ( function( height, width ) if windowBuffer[height][width] then return windowBuffer[height][width] else return {text = ' ', textColor = getColor( windowBuffer.textColor), backgroundColor = getColor( windowBuffer.backgroundColor ) } end end )( height, width )
					lastX = width
				end
				-- if any remain, remove them
				for width = lastX, #windowBuffer[height] do
					windowBuffer[height][width] = nil
				end
			end
			-- remove old buffer items.
			for height = lastY, #windowBuffer do
				windowBuffer[height] = nil
				-- if the height has been shrunk, then remove the excess tables
			end
			-- A window buffer has now been created with a table for each Y-Axis containing another table for each X-Axis.
		end
		setupBuffer()
		--[[
			When the main event manager catches an event, it first checks if the event can be passed to the window using the eventFilter (if window is not active then only events inside the
			filter will be passed to the coroutine). If the event can be passed, the term will be redirected to the new stage term object and resumed.

			Any term calls will be redirected here where they can be buffered and drawn respectively.

			After the coroutine yields, other stages will get their coroutines checked and run if required, then term will be redirected to oTerm (original term).
		]]

		function redirect.isColor() return oTerm.isColor() end
		redirect.isColour = redirect.isColor

		function redirect.write( sString )
			oTerm.setCursorPos( windowBuffer.cX + settings.x - 1, windowBuffer.cY + settings.y - ( function() if settings.borderless then return 1 else return 0 end end)() ) -- cX and cY are cursor positions relative to the window, not the terminal. Make up for this my adding their position.
			if windowBuffer.cX < 1 or windowBuffer.cX > settings.width or windowBuffer.cY < 1 or windowBuffer.cY > settings.height then
				--return oTerm.write(sString)
				return ""
			end

			for charIndex = 1, sString:len() do
				windowBuffer[windowBuffer.cY][windowBuffer.cX].text = sString:sub(charIndex, charIndex)
				windowBuffer[windowBuffer.cY][windowBuffer.cX].textColor = getColor( windowBuffer.textColor )
				windowBuffer[windowBuffer.cY][windowBuffer.cX].backgroundColor = getColor( windowBuffer.backgroundColor )
				windowBuffer.cX = windowBuffer.cX + 1

				if windowBuffer.cX > settings.width then
					--windowBuffer.cY = windowBuffer.cY + 1
					break
				end
			end
			oTerm.setBackgroundColor( getColor( windowBuffer.backgroundColor ) )
			oTerm.setTextColor( getColor( windowBuffer.textColor ) )
			local r = oTerm.write(sString)
			oTerm.setBackgroundColor( program.backgroundColor )
			oTerm.setTextColor( colors.white )
			return r
		end
		function redirect.blit( sString, sBackground, sTextColor ) end

		function redirect.clear() end
		function redirect.clearLine() end

		function redirect.getCursorPos() return windowBuffer.cX, windowBuffer.cY end
		function redirect.setCursorPos( nX, nY ) windowBuffer.cX, windowBuffer.cY = tonumber( nX ), tonumber( nY ) updateCursorPos() end

		function redirect.setCursorBlink( bBlink ) windowBuffer.cursorBlink = bBlink updateCursorBlink() end
		function redirect.getCursorBlink() return windowBuffer.cursorBlink end

		function redirect.setTextColor( sColor ) windowBuffer.textColor = sColor end
		redirect.setTextColour = redirect.setTextColor

		function redirect.setBackgroundColor( sColor ) windowBuffer.backgroundColor = sColor end
		redirect.setBackgroundColour = redirect.setBackgroundColor

		function redirect.getBackgroundColor() return windowBuffer.backgroundColor end
		redirect.getBackgroundColour = redirect.getBackgroundColor

		function redirect.getTextColor() return windowBuffer.textColor end
		redirect.getTextColour = redirect.getTextColor

		function redirect.scroll( n )

		end

		function redirect.setVisible( bVisible ) settings.visible = bVisible end
		function redirect.getVisible() return settings.visible end

		function redirect.redraw() redirectDraw() end

		function redirect.restoreCursor() end

		function redirect.getPosition() return settings.x, settings.y end
		function redirect.reposition() end

		function redirect.getSize() return settings.width, settings.height end
		

		local function removeFromEventWhitelist( v )
			for key, event in ipairs( settings.eventWhitelist ) do
				if event == v then
					table.remove( settings.eventWhitelist, key )
				end
			end
		end
		function new.removeFromEventWhitelist( v ) removeFromEventWhitelist( v ) end
		
		local function addToEventWhitelist( v )
			removeFromEventWhitelist( v )
			table.insert( settings.eventWhitelist, v )
		end
		function new.addToEventWhitelist( v ) addToEventWhitelist( v ) end

		local function setEventWhitelist( v )
			settings.eventWhitelist = v
		end
		function new.setEventWhitelist( v ) setEventWhitelist( v ) end

		local function getEventWhitelist()
			return settings.eventWhitelist
		end
		function new.getEventWhitelist() return getEventWhitelist() end

		-- Above event filter methods for whitelist
		
		local function removeFromEventBlacklist( v )
			for key, event in ipairs( settings.eventBlacklist ) do
				if event == v then
					table.remove( settings.eventBlacklist, key )
				end
			end
		end
		function new.removeFromEventBlacklist( v ) removeFromEventBlacklist( v ) end
		
		local function addToEventBlacklist( v )
			removeFromEventBlacklist( v )
			table.insert( settings.eventBlacklist, v )
		end
		function new.addToEventBlacklist( v ) addToEventBlacklist( v ) end

		local function getEventBlacklist()
			return settings.eventBlacklist
		end
		function new.getEventBlacklist() return getEventBlacklist() end


		local function setEventBlacklist( v )
			settings.eventBlacklist = v
		end
		function new.setEventBlacklist( v )
			setEventBlacklist( v )
		end

		local function wrapProgram( path )
			if runningProgram and coroutine.status( runningProgram ) == "suspended" then
				error("wrapProgram: Program already running on stage", 2)
			end
			if not path or type( path ) ~= "string" then
				error("wrapProgram: Expected: path String")
			end
			local func = false
			if getfenv and setfenv and type( getfenv ) == "function" and type( setfenv ) == "function" then
				local result, err = loadfile( path )
				if not result then
					if err then
						error("wrapProgram: "..tostring( err ))
					else
						error("wrapProgram: Error while loading file.")
					end
				elseif result then
					func = result
					--setfenv( func, sandbox )
				end
				if func then
					runningProgram = coroutine.create(function()
						func()
					end)
					pgPath = path
				else
					error("wrapProgram: Could not load file")
				end
			end
		end

		function new.runProgram( path )
			wrapProgram( path )
		end
		local messageCrashed, messageClosed = false, false
		function new.threadCrash( err )
			messageCrashed = coroutine.create(function()
				term.setTextColor( colors.red )
				print("Thread Crashed: "..err)
				term.setTextColor( colors.white )
				print("Press any key to continue")
				while true do
					local e = os.pullEvent("key")
					restore()
					if e == "key" then break end
				end
				close()
			end)
		end

		function new.getAlternate()
			return messageCrashed, 1 or messageClosed, 2
		end

		function new.threadClosed()
			restore()
			print("This program has Finished\nPress any key to continue")
			os.pullEventRaw("key")
			print("KEY! Closing")
			sleep(1)
		end

		function new.setCloseCallback( self, callback )
			if not self or not ( type( self ) == "table" and self.getType and self.getType() == "stage" ) or not callback then
				error("Expected table SELF of type stage and callback function")
			end
			if self.getName() ~= settings.name then
				error("Passed self does not match this stage")
			end
			settings.onCloseCB = callback
		end

		-- add this stage to the object storage.

		function new.draw( self )
			if not registryFetch( settings.name ) then error("Stage must be built before drawing") end
			draw()
		end

		function new.setColorFilter( filterName )
			settings.filter = filterName
		end

		function new.getType() return "stage" end

		function new.getActive() return settings.active end

		function new.setBufferLevel( self, v )
			settings.bufferLevel = v
		end
		function new.getBufferLevel( self )
			return settings.bufferLevel
		end

		function new.getPos( self ) return settings.x, settings.y end 

		function new.setPos( nX, nY ) settings.x, settings.y = nX, nY end

		function new.getWidth() return settings.width end
		function new.getHeight() return settings.height end

		function new.setBorderless( self, v ) 
			settings.borderless = v
		end
		function new.getBorderless( self ) 
			return settings.borderless
		end

		function new.setCloseButton( self, v ) 
			settings.closeButton = v
		end
		function new.getCloseButton( self ) 
			return setting.closeButton
		end

		function new.getFullscreen( self ) 
			return settings.fullscreen 
		end
		function new.setFullscreen( self, v ) 
			settings.fullscreen = v 
		end

		function new.setMoveable( self, v ) 
			settings.moveable = v
		end
		function new.getMoveable( self ) 
			return settings.moveable
		end

		function new.setBorderBackgroundColor( self, v ) 
			settings.borderBackgroundColor = v
		end
		function new.getBorderBackgroundColor( self ) 
			return settings.borderBackgroundColor
		end

		function new.setBorderTextColor( self, v ) 
			settings.borderTextColor = v
		end
		function new.getBorderTextColor( self ) 
			return settings.borderTextColor
		end

		function new.setBorderCloseBackgroundColor( self, v ) 
			settings.borderCloseBackgroundColor = v
		end
		function new.getBorderCloseBackgroundColor( self ) 
			return settings.borderCloseBackgroundColor
		end

		function new.setBorderCloseTextColor( self, v ) 
			settings.borderCloseTextColor = v
		end
		function new.getBorderCloseTextColor( self ) 
			return settings.borderCloseTextColor
		end

		function new.setBorderCloseText( self, v ) 
			settings.borderCloseText = v
		end
		function new.getBorderCloseText( self ) 
			return settings.borderCloseText
		end

		function new.setTitle( self, v ) 
			settings.title = v
		end
		function new.getTitle( self ) 
			return settings.title
		end

		function new.setTitleOverflow( self, v ) 
			settings.titleOverflow = v
		end
		function new.getTitleOverflow( self ) 
			return settings.titleOverflow
		end

		function new.setTitleCenter( self, v )
			setting.titleCenter = v
		end
		function new.getTitleCenter( self )
			return settings.titleCenter
		end

		function new.setFocus( self, v ) 
			if v then focus() else blur() end
		end
		function new.getFocus( self ) 
			return settings.isActive
		end

		function new.getName( self )
			return settings.name
		end

		function new.getFromRegistry( self )
			return registryFetch( self:getName() )
		end

		function new.updateToRegistry( self )
			registryUpdate( self )
		end

		function new.removeFromRegistry( self )
			registryRemove( self:getName() )
		end

		function new.setScene( self, v )
			settings.scene = v
		end

		function new.getScene( self )
			return settings.scene
		end

		function new.runEvent( self, e, p1, p2, p3, p4 )
			-- if its not active, and the event was a mouse click, check if in bounds. If it isn't clicked on deactivate it, if it is activate it.
			local edited
			if e == "mouse_click" then
				local high = buffer.getHighestLevel( p2, p3 )
				if settings.borderless then offset = 0 else offset = 1 end
				if p2 >= settings.x and p2 <= settings.x + settings.width - 1 and p3 >= settings.y and p3 <= settings.y + settings.height + offset - 1 and not settings.active then
					-- if the window is the highest level.
					if high and high:getName() == settings.name then
						--settings.active = true
						--buffer.reorder( settings.name ) --set this window to the top
						focus()
						edited = true
					end
				elseif not high or high.getName() ~= settings.name and settings.active then
					blur()
					--settings.active = false
				end
			end
			if settings.active then
				if e == "mouse_click" then
					handleMouseClick( self, e, p1, p2, p3 )
				elseif e == "mouse_scroll" then
					handleMouseScroll( self, e, p1, p2, p3 )
				elseif e == "mouse_drag" then
					handleMouseDrag( self, e, p1, p2, p3 )
				elseif e == "key" then
					handleKeyPress( self, e, p1, p2 )
				elseif e == "char" then
					handleCharPress( self, e, p1 )
				elseif e == "terminate" and settings.allowTerminate then
					registryRemove( settings.name )
					buffer.reorder()
					term.clear()
					buffer.redrawAll()
				end
			end
			return edited
		end

		function new.destroy( self )
			-- if stage is in registry remove it, also stop loop
			registryRemove( settings.name )
		end

		function new.build( self )
			-- add stage to registry
			registryUpdate( self )
		end
		log("New stage created: "..settings.name)
		return new

	end

	clone.createScene = function( cfg )
		local sceneDefault = {}
		local new = {}
		local settings = {
			nodes = {}
		}

		-- The scene is attached to a stage. The scene _can_ be used on multiple stages.

		-- If the scene is fetched from a stage, and changed it will affect all stages using the scene.

		-- If the scene is changed from a local variable, and changed it will also affect all stages using this scene.

		setmetatable( sceneDefault, {__index=defaults})
		setmetatable( cfg, {__index=sceneDefault})
		setmetatable( settings, {__index = cfg})


		local function registryUpdate( self )
			for k, v in ipairs( objects.scenes ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.scenes, k )
					end
				end
			end

			table.insert( objects.scenes, self )
		end

		function new.getType() return "scene" end

		function new.getName() return settings.name end

		function new.relaceWithFile( self )

		end
		function new.appendFromFile( self )

		end

		function new.addNode( self, v )

		end
		function new.removeNode( self )

		end
		function new.clearNodes( self )
			settings.nodes = {}
			-- redraw window
		end
		function new.getNodes( self )
			return settings.nodes
		end

		function new.getFromRegistry( self )
			return registryFetch( self:getName() )
		end
		function new.updateToRegistry( self )
			registryUpdate( self )
		end
		function new.removeFromRegistry( self )
			registryRemove( self:getName() )
		end

		function new.setExample( self, v )
			settings.ex = v
		end
		function new.getExample( self )
			return settings.ex
		end

		registryUpdate( new )

		return new

	end

	clone.createButton = function( cfg )
		local buttonDefaults = {}
		local settings = {}
		local new = {}

		setmetatable( buttonDefaults, {__index = defaults})
		setmetatable( cfg, {__index = buttonDefaults})
		setmetatable( settings, {__index = cfg})


		function new.setBackgroundColor( self, v ) 
			settings.backgroundColor = v
		end
		function new.getBackgroundColor( self ) 
			return settings.backgroundColor
		end

		function new.setText( self, v ) 
			settings.text = v
		end
		function new.getText( self ) 
			return settings.text
		end

		function new.setTextColor( self, v ) 
			settings.textColor = v
		end
		function new.getTextColor( self ) 
			return settings.textColor
		end

		function new.setCanBeToggled( self, v ) 
			settings.canBeToggled = v
		end
		function new.getCanBeToggled( self ) 
			return settings.canBeToggled
		end

		function new.setToggledBackgroundColor( self, v ) 
			settings.toggledBackgroundColor = v
		end
		function new.getToggledBackgroundColor( self ) 
			return settings.toggledBackgroundColor
		end

		function new.setToggledText( self, v ) 
			settings.toggledText = v
		end
		function new.getToggledText( self ) 
			return settings.toggledText
		end

		function new.setMaxwidth( self, v ) 
			settings.maxWidth = v
		end
		function new.getMaxwidth( self ) 
			return settings.maxWidth
		end

		function new.setHeight( self, v ) 
			settings.height = v
		end
		function new.getHeight( self ) 
			return settings.height
		end

		function new.setToggledTextColor( self, v ) 
			settings.toggledTextColor = v
		end
		function new.getToggledTextColor( self ) 
			return settings.toggledTextColor
		end

		function new.setX( self, v ) 
			settings.x = v
		end
		function new.getX( self ) 
			return settings.x
		end

		function new.setY( self, v ) 
			settings.y = v
		end
		function new.getY( self ) 
			return settings.y
		end


		-- A node is not added to its own registry. It is added to the scenes node dictionary.

		-- Any changes made to the node via local variable, scene get or stage-scene fetch will be reflected across all scenes using this button.
		return new


	end
	clone.createParagraph = function() end
	clone.createScroll = function() end
	clone.createList = function() end

	clone.getStageFromRegistry = function( name ) -- returns stage from registry. (stage:updateToRegistry())
		return registryFetch( name )
	end

	local function begin( callback )
		local activeEvent = {
			"rednet_message",
			"modem_message",
			"alarm",
			"timer",
			"redstone"
		} -- events that are sent when the stage is not active.
		local tFilter = {} --stores filters for coroutines.
		local function filterEvent( event, stage )
			-- if the stage has a coroutine filter, check if its in there
			if tFilter[stage.getName()] == event or not tFilter[stage.getName()] or tFilter[stage.getName()] == "" then
				tFilter[stage.getName()] = nil
				-- check if the event is in the stages blacklist.
				for key, e in ipairs( stage.getEventBlacklist() ) do
					if e == event then return false end
				end
				-- if stage is active, return true.
				if stage.getActive() then return true end
				-- check if the event is in the stages whitelist (stage is not active).
				for key, e in ipairs( stage.getEventWhitelist() ) do
					if e == event then return true end
				end
			else
				log(event .. " ~= " .. tostring(tFilter[stage.getName()]))
			end
		end
		local function exeOnEach( e, p1, p2, p3, p4 )
			local re = false
			for _, stage in ipairs( objects.stages ) do
				if stage:runEvent( e, p1, p2, p3, p4 ) then re = true end
				stage.draw()
				term.redirect( stage.getTerm() )
				-- check if a message coroutine is active
				local messageCo, pgCo = stage.getAlternate(), stage.getRunningProgram()
				if messageCo and type( messageCo ) == "thread" and coroutine.status( messageCo ) == "suspended" then
					-- send event to the message (threadClosed or crashed).
					local ok, param = coroutine.resume( messageCo, e, p1, p2, p3, p4 )
					log( tostring(ok)..", "..tostring( param ))
				elseif pgCo and type( pgCo ) == "thread" and coroutine.status( pgCo ) == "suspended" and filterEvent( e, stage ) then
					-- send event to runningProgram, check its status afterwards to determine if the program finished or crashed.\
					local ok, param = coroutine.resume( pgCo, e, p1, p2, p3, p4 )
					if ok and coroutine.status( pgCo ) == "dead" then
						-- finished, reset the filter
						tFilter[stage.getName()] = nil
						stage.threadClosed()
					elseif not ok then
						-- crashed, reset the filter for this coroutine
						tFilter[stage.getName()] = nil
						stage.threadCrash( param )
					elseif ok and param then
						-- store the filter
						tFilter[stage.getName()] = param
					end
				end
				if stage.getActive() then stage.redraw() end
				term.redirect( oTerm )
			end
			
			if #objects.stages <= 0 then
				log("Cannot continue windows loop, all stages closed.", "w")
				return "stop"
			end
			if re then log("redrawing") buffer.redrawAll() end
		end
		local function loop()
			while true do
				local e, p1, p2, p3, p4 = os.pullEventRaw()
				if e == "program_stop"..program.name then
					break
				else
					if exeOnEach( e, p1, p2, p3, p4 ) == "stop" then break end
				end
			end
		end
		log("Starting Windows", "w")
		buffer.redrawAll()
		if callback and type( callback ) == "function" then
			parallel.waitForAll( loop, callback )
		else
			loop()
		end
	end

	clone.setErrorCallback = function( cb )
		program.customErrorCB = cb
	end

	clone.getErrorCallback = function()
		return program.customErrorCB
	end

	clone.getCatchErrors = function()
		return program.catchErrors
	end

	clone.setCatchErrors = function( v )
		program.catchErrors = v
	end

	clone.startWindows = function( callback )
		local function cPrint( text, y, color )
			if color then term.setTextColor( color ) end
			term.setCursorPos( math.ceil( termX/2-(#text/2) ), y )
			term.clearLine()
			write( text )
		end
		-- starts each windows event loop.
		-- When a stage is destroyed, it will be stopped and must be "rebuilt" in order to function again.
		if program.catchErrors then
			local ok, err = pcall(function() begin( callback ) restore() end)
			if err or not ok then
				log( tostring( err ), "e" )
				restore()
				if program.customErrorCB and type( program.customErrorCB ) == "function" then
					program.customErrorCB( ok, err )
				else
					term.setBackgroundColor( colors.gray )
					term.clear()
					cPrint("DynaCode Version 3 - Exception Caught", 4, colors.orange)
					cPrint("A fatal exception occurred which", 6, colors.lightGray)
					cPrint("has prevented DynaCode from continuing.", 7, colors.lightGray)
					cPrint(tostring( err ), 9, colors.orange)
					cPrint("Please report this error on the forum", 12, colors.lightGray)
					cPrint("following the guidelines on the page.", 13)
					cPrint("Press 'shift' to pause reboot timer", 15, colors.lightGray)
					cPrint("any other key to reboot", 16, colors.lightGray)
					local isTimer, timer, vTimer = true, os.startTimer( 1 ), program.restartTimer or 10
					cPrint("Rebooting in "..vTimer, termY, colors.lightGray)

					local function rTimer()
						vTimer = vTimer - 1
						if vTimer <= 0 then
							os.reboot()
						else
							timer = os.startTimer( 1 )
						end
						cPrint("Rebooting in "..vTimer, termY, colors.lightGray)
					end

					while true do
						local e, p1 = os.pullEventRaw()
						if e == "timer" and p1 == timer and program.restartTimer and isTimer then
							rTimer()
						elseif e == "key" then
							if p1 == keys.leftShift or p1 == keys.rightShift then
								if isTimer then
									isTimer = false
									cPrint("Paused reboot timer", termY, colors.orange)
								elseif not isTimer then
									isTimer = true
									timer = os.startTimer( 1 )
									cPrint("Rebooting in "..vTimer, termY, colors.lightGray)
								end
							else os.reboot() end
						end
					end

				end
			end
		else
			begin()
		end
		restore()
	end

	clone.getObjects = function() return objects end

	clone.file = {
		getHandle = function( path, mode )
			if fs.exists( path ) then
				return fs.open( path, mode or "r" )
			else
				return false
			end
		end,
		write = function( path, content )
			local h = fs.open( path, "w" )
			h.write( content )
			h.close()
			return true
		end,
		append = function( path, content )
			local h = clone.file.getHandle( path, "a" )
			if h then
				h.write( content )
				h.close()
				return true
			else
				return false
			end
		end,
		writeLine = function( path, content )
			local h = fs.open( path, "r" )
			h.writeLine( content )
			h.close()
			return true
		end,
		getLine = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readLine()
				h.close()
				return cnt
			else
				return false
			end
		end,
		getAll = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readAll()
				h.close()
				return cnt
			else
				return false
			end
		end
	}

	clone.createFilter = function( name, tbl ) filterAdd( name, tbl ) end

	clone.getFilterObject = function( name )
		return filterGet( name )
	end

	clone.getColorFromFilter = function( filter, cl )
		return getColorFromFilter( filter, cl )
	end

	clone.canvas = {
		drawArea = function( nX, nY, width, height, background )
			if height < 1 or width < 1 then
				error("Height and width must be greater than 1 to draw a box")
			end
			for i = nY, nY + height do
				clone.canvas.drawHLine( nX, i, width, background )
			end
		end,
		drawHLine = function( nX, nY, width, background )
			paintutils.drawLine( nX, nY, nX+width, nY, background )
		end,
		drawVLine = function( nX, nY, height, background )
			paintutils.drawLine( nX, nY, nX, nY+height, background )
		end,
		drawText = function() end,
		drawCText = function() end
	}

	clone.remote = {
		fetch = function( url )
			for i = 1, 3 do
				local response = http.get( url )
				if response then
					return response
				end
			end
			return false
		end,
		fetchLine = function( url )
			local response = clone.remote.fetch( url )
			if not response then return false else return response.readLine() end
		end,
		fetchAll = function( url )
			local response = clone.remote.fetch( url )
			if not response then return false else return response.readAll() end
		end
	}

	return clone

end