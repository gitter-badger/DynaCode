-- DynaCode V3... WOW, what about V1 and V2? HUSH!

local apiCfg = {
	keepUpToDate = true, -- Check for updates the first time a program is created using this version of the API. (.createProgram())
	updatePath = "DynaCodeTEST", -- Where is the API installed
	updateUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/DynaCode2", -- Path to download. This is set to my repository on GitHub.
	versionUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/version", -- Path to version file. This is set to my repository on GitHub.
	versionPath = "DynaCodeVersion", -- Leave as is if you like, or change to a file (ideally in the same directory as DynaCode)
	output = true, -- print information to the screen during update check
	resetScreenPost = true, -- clear the screen after update check (recommended because the text color will be changed)
	clearDelay = 1
}

local updateChecked = false

local function clear()
	term.setBackgroundColor( colors.black )
	term.clear()
	term.setCursorPos(1, 1)
end

local function uPrint( color, ... )
	term.setTextColor( color or colors.white )
	if apiCfg.output then
		print( ... )
	end
	term.setTextColor( colors.white )
end

function getUpdateOutputSetting()
	return apiCfg.output
end

function setUpdateOutputSetting( v )
	apiCfg.output = v
end

function getUpdatePathSetting()
	return apiCfg.updatePath
end

function setUpdatePathSetting( v )
	apiCfg.updatePath = v
end

function getUpdateVersionSetting()
	return apiCfg.versionPath
end

function setUpdateVersionSetting( v )
	apiCfg.versionPath = v
end

function getUpdateResetPostSetting()
	return apiCfg.resetScreenPost
end

function setUpdateResetPostSetting( v )
	apiCfg.resetScreenPost = v
end

function setUpdateAutoSetting( v )
	apiCfg.keepUpToDate = v
end

function getUpdateAutoSetting()
	return apiCfg.keepUpToDate
end

function setUpdateDelaySetting( v )
	apiCfg.clearDelay = v
end

function getUpdateDelaySetting()
	return apiCfg.clearDelay
end

function getVersionData()
	if not http then
		error("Cannot check for updates. ComputerCraft HTTP API is disabled.")
	end
	for i = 1, 3 do
		uPrint( false, "Fetching version information. Attempt "..i.." of 3")
		local response = http.get( apiCfg.versionUrl )
		if response then
			local rData = assert( textutils.unserialize( response.readAll() ), "Remote Version Data Invalid")
			local update = false
			local localData
			local h = fs.open( apiCfg.versionPath, "r" )
			if h then
				localData = textutils.unserialize( h.readAll() )
				if not localData then
					h.close()
					fs.delete( apiCfg.versionPath )
					os.reboot()
				end
				h.close()
				if localData.version ~= rData.version or localData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
			else
				update = true
			end
			if update then uPrint(colors.orange, "DynaCode 3 is out-of-date") else uPrint( colors.lime, "DynaCode 3 is up-to-date") end
			if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
			return update, rData, localData --Returns true if update required and also returns the remote and local version data for manual checks.
		end
	end
	uPrint(colors.red, "Could not fetch version file.")
	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
	return false, nil
end

function installVersionData( rData )
	if not http then
		error("Cannot fetch updates. ComputerCraft HTTP API is disabled.")
	end
	-- @rData is the remoteDataFile.
	-- Open local file and compare
	if not rData or type( rData ) ~= "table" then error("Expected remoteData table, got ".. type( rData )) end
	local h = fs.open( apiCfg.versionPath, "r" )
	local update = false
	local lData
	if not h then update = true else
		lData = textutils.unserialize( h.readAll() )
		h.close()
		if not lData then
			fs.delete( api.versionPath ) --file corrupted, remove it
			os.reboot()
		end
		if lData.version ~= rData.version or lData.build ~= rData.build or not fs.exists( apiCfg.versionPath ) or not fs.exists( apiCfg.updatePath ) then update = true end
	end

	if update then
		-- fetch update, install and change version file to new remote one passed in installVersionData()
		for i = 1, 3 do
			uPrint(false, "Fetching update files. Attempt ", i, " of 3")
			local response = http.get( apiCfg.updateUrl )
			if response then
				local h = fs.open( apiCfg.updatePath, "w" )
				h.write( response.readAll() )
				h.close()
				h = fs.open( apiCfg.versionPath, "w" )
				h.write( textutils.serialize( rData ) )
				h.close()
				uPrint(colors.lime, "Install complete, rebooting in one second")
				sleep(1)
				os.reboot()
			end
		end
		uPrint(colors.red, "Could not fetch update data")
	end

	if apiCfg.resetScreenPost then sleep(apiCfg.clearDelay) clear() end
end

local function getVersion()
	local h = fs.open( apiCfg.versionPath, "r" )
	if not h then
		return { version = "Unknown", build = "Unknown" }
	end
	local cnt = h.readAll()
	h.close()
	if cnt then
		return textutils.unserialize( cnt )
	else
		return { version = "Unknown", build = "Unknown" }
	end
end

local function checkAndProceed()
	local go, data = getVersionData()
	if go and data then
		installVersionData( data )
	end
end

local function copy( tbl )
	if type( tbl ) == "table" then
		-- loop through table, copying keys
		local copy = {}
		for key, value in ipairs(tbl) do
			copy[key] = value
		end
		return copy
	else
		return tbl
	end
end

local function validateRequirements( needed, provided, silent, prefix, suffix )

	if type( needed ) ~= "table" or type( provided ) ~= "table" or ( type( silent ) ~= "nil" and type( silent ) ~= "boolean" ) or ( type( prefix ) ~= "nil" and type( prefix ) ~= "string" ) or ( type( suffix ) ~= "nil" and type( suffix ) ~= "string" ) then
		error("Bad arguments, expected: table, table, boolean(optional), string(optional), string(optional), got: "..type( needed )..", "..type( provided )..", "..type(silent)..", "..type(prefix)..", "..type(suffix), 3)
	end

	-- Loop @provided, then check @needed for the key-value pair found in @provided. If its in their simply remove it.

	local result = copy( needed )

	local function compile( prefix, suffix )
		local msg = prefix or ""
		for k, v in ipairs(result) do
			msg = msg.."- "..tostring(v)
			if k < #result then msg = msg .. "\n" end
		end
		if suffix then msg = msg .. "\n " .. suffix end
		return msg
	end

	for opt in pairs( provided ) do
		for key, req in ipairs( result ) do
			if req == opt then
				table.remove( result, key )
			end
		end
	end

	-- If the length of result is > 0, then not all requirements have been met.

	if #result > 0 then
		if silent then
			return false, compile( prefix or "", suffix or "")
		else
			error( compile( prefix or "", suffix or "" ), 3)
		end
	else
		return true
	end
end

function createProgram( options )
	validateRequirements({ "name" }, options, false, "Missing requirements to initialize program:\n", "\nPlease define the above settings when creating your program instance")
	if not updateChecked then
		-- check for updates now
		checkAndProceed()
		updateChecked = true
	end

	local defaults = {}

	local objects = { -- program registry
		scenes = {},
		stages = {}
	}

	local clone = {}
	local program = {}
	setmetatable( options, {__index=defaults})
	setmetatable( program, {__index = options})
	-- Each function will use the @self argument to adjust its own settings.

	local function log( msg, mode )
		if program.loggingReady then
			local prefix = "Info"
			if mode == "w" then prefix = "Warn" elseif mode == "e" then prefix = "ERROR" end
			clone.file.append( program.loggingPath, "["..prefix.."] "..msg.."\n")
		end
	end

	clone.setLoggingPath = function( v )
		program.loggingPath = v
	end
	clone.getLoggingPath = function()
		return program.loggingPath
	end

	clone.setLoggingEnabled = function( v )
		program.logging = v
	end
	clone.getLoggingEnabled = function()
		return program.logging
	end

	clone.logToFile = function( content, mode )
		log( content, mode )
	end

	clone.initializeLogFile = function()
		if not program.logging or not program.loggingPath then
			error("Set logging and logging path before initializing", 2)
		end
		local h = fs.open( program.loggingPath, "w" )
		local ver = getVersion()
		if h then
			h.write("--@@@==== DynaCode Logging - Instance: "..program.name.." - ( Version: ".. ver.version .. " - Build: " .. ver.build .." ) ====@@@--\n")
			h.close()
			program.loggingReady = true
		end
	end

	local function registryFetch( nm )

		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					return v
				end
			end
		end
		return false
	end

	local function registryRemove( nm )
		for k, v in ipairs( objects.stages ) do
			if v and type( v ) == "table" and v.getName then
				if v:getName() == nm then
					return v
				end
			end
		end
	end

	local function createBuffer()
		local buffer = {}

		return buffer
	end

	clone.createStage = function( cfg )

		local stageDefaults = {}
		local new = {}
		local settings = {}

		setmetatable( stageDefaults, {__index = defaults})
		setmetatable( cfg, {__index = stageDefaults} )
		setmetatable( settings, {__index=cfg} )


		local function registryUpdate( self )
			for k, v in ipairs( objects.stages ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.stages, k )
					end
				end
			end

			table.insert( objects.stages, self )
		end

		local function draw()

		end

		local function handleMouseClick( event, button, nX, nY )

		end
		local function handleMouseScroll( event, direction, nX, nY )

		end
		local function handleMouseDrag( event, button, nX, nY )

		end
		local function handleKeyPress( event, key, held )

		end
		local function handleCharPress( event, key )

		end

		local function focus()

		end

		local function blur()

		end

		local function loop()
			while true do

			end
		end

		local function startStage()
			-- run the loop and a stop catcher in parallel so that the loop will stop even if busy.
			parallel.waitForAny( loop, function()
				while true do
					local e = os.pullEventRaw()
					if e == "pause_stage_"..setting.name then
						break
					elseif e == "terminate_stage_"..settings.name then
						-- break & remove the stage from the buffer.
					end
				end
			end)
		end

		local function stopStage()

		end

		-- add this stage to the object storage.

		new.getX = function( self )
			return settings.x
		end

		new.setX = function( self, v )
			settings.x = v
		end

		new.getY = function( self ) 
			return settings.y
		end
		new.setY = function( self, v ) 
			settings.y = v
		end

		new.setBackgroundColor = function( self, v ) 
			settings.backgroundColor = v
		end
		new.getBackgroundColor = function( self ) 
			return settings.backgroundColor
		end

		new.setBorderless = function( self, v ) 
			settings.borderless = v
		end
		new.getBorderless = function( self ) 
			return settings.borderless
		end

		new.setCloseable = function( self, v ) 
			settings.closeable = v
		end
		new.getCloseable = function( self ) 
			return setting.closeable
		end

		new.setMoveable = function( self, v ) 
			settings.moveable = v
		end
		new.getMoveable = function( self ) 
			return settings.moveable
		end

		new.setBorderBackgroundColor = function( self, v ) 
			settings.borderBackgroundColor = v
		end
		new.getBorderBackgroundColor = function( self ) 
			return settings.borderBackgroundColor
		end

		new.setBorderTextColor = function( self, v ) 
			settings.borderTextColor = v
		end
		new.getBorderTextColor = function( self ) 
			return settings.borderTextColor
		end

		new.setBorderCloseBackgroundColor = function( self, v ) 
			settings.borderCloseBackgroundColor = v
		end
		new.getBorderCloseBackgroundColor = function( self ) 
			return settings.borderCloseBackgroundColor
		end

		new.setBorderCloseTextColor = function( self, v ) 
			settings.borderCloseTextColor = v
		end
		new.getBorderCloseTextColor = function( self ) 
			return settings.borderCloseTextColor
		end

		new.setBorderCloseText = function( self, v ) 
			settings.borderCloseText = v
		end
		new.getBorderCloseText = function( self ) 
			return settings.borderCloseText
		end

		new.setTitle = function( self, v ) 
			settings.title = v
		end
		new.getTitle = function( self ) 
			return settings.title
		end

		new.setTitleOverflow = function( self, v ) 
			settings.titleOverflow = v
		end
		new.getTitleOverflow = function( self ) 
			return settings.titleOverflow
		end

		new.setTitleCenter = function( self, v )
			setting.titleCenter = v
		end
		new.getTitleCenter = function( self )
			return settings.titleCenter
		end

		new.setFocus = function( self, v ) 
			focus( v )
		end
		new.getFocus = function( self ) 
			return settings.isActive
		end

		new.getName = function( self )
			return settings.name
		end

		new.getFromRegistry = function( self )
			return registryFetch( self:getName() )
		end

		new.updateToRegistry = function( self )
			registryUpdate( self )
		end

		new.removeFromRegistry = function( self )
			registryRemove( self:getName() )
		end

		new.setScene = function( self, v )
			settings.scene = v
		end

		new.getScene = function( self )
			return settings.scene
		end


		registryUpdate( new ) --sets to registry.
		return new

	end

	clone.createScene = function( cfg )
		local sceneDefault = {}
		local new = {}
		local settings = {
			nodes = {}
		}

		-- The scene is attached to a stage. The scene _can_ be used on multiple stages.

		-- If the scene is fetched from a stage, and changed it will affect all stages using the scene.

		-- If the scene is changed from a local variable, and changed it will also affect all stages using this scene.

		setmetatable( sceneDefault, {__index=defaults})
		setmetatable( cfg, {__index=sceneDefault})
		setmetatable( settings, {__index = cfg})


		local function registryUpdate( self )
			for k, v in ipairs( objects.stages ) do
				if v and type(v) == "table" then
					if v:getName() == settings.name then
						table.remove( objects.stages, k )
					end
				end
			end

			table.insert( objects.stages, self )
		end


		new.relaceWithFile = function( self )

		end
		new.appendFromFile = function( self )

		end

		new.addNode = function( self, v )

		end
		new.removeNode = function( self )

		end
		new.clearNodes = function( self )
			settings.nodes = {}
			-- redraw window
		end
		new.getNodes = function( self )
			return settings.nodes
		end

		new.getFromRegistry = function( self )
			return registryFetch( self:getName() )
		end
		new.updateToRegistry = function( self )
			registryUpdate( self )
		end
		new.removeFromRegistry = function( self )
			registryRemove( self:getName() )
		end

		new.setExample = function( self, v )
			settings.ex = v
		end
		new.getExample = function( self )
			return settings.ex
		end

		registryUpdate( new )

		return new

	end

	clone.createButton = function( cfg )
		local buttonDefaults = {}
		local settings = {}
		local new = {}

		setmetatable( buttonDefaults, {__index = defaults})
		setmetatable( cfg, {__index = buttonDefaults})
		setmetatable( settings, {__index = cfg})


		new.setBackgroundColor = function( self, v ) 
			settings.backgroundColor = v
		end
		new.getBackgroundColor = function( self ) 
			return settings.backgroundColor
		end

		new.setText = function( self, v ) 
			settings.text = v
		end
		new.getText = function( self ) 
			return settings.text
		end

		new.setTextColor = function( self, v ) 
			settings.textColor = v
		end
		new.getTextColor = function( self ) 
			return settings.textColor
		end

		new.setCanBeToggled = function( self, v ) 
			settings.canBeToggled = v
		end
		new.getCanBeToggled = function( self ) 
			return settings.canBeToggled
		end

		new.setToggledBackgroundColor = function( self, v ) 
			settings.toggledBackgroundColor = v
		end
		new.getToggledBackgroundColor = function( self ) 
			return settings.toggledBackgroundColor
		end

		new.setToggledText = function( self, v ) 
			settings.toggledText = v
		end
		new.getToggledText = function( self ) 
			return settings.toggledText
		end

		new.setMaxwidth = function( self, v ) 
			settings.maxWidth = v
		end
		new.getMaxwidth = function( self ) 
			return settings.maxWidth
		end

		new.setHeight = function( self, v ) 
			settings.height = v
		end
		new.getHeight = function( self ) 
			return settings.height
		end

		new.setToggledTextColor = function( self, v ) 
			settings.toggledTextColor = v
		end
		new.getToggledTextColor = function( self ) 
			return settings.toggledTextColor
		end

		new.setX = function( self, v ) 
			settings.x = v
		end
		new.getX = function( self ) 
			return settings.x
		end

		new.setY = function( self, v ) 
			settings.y = v
		end
		new.getY = function( self ) 
			return settings.y
		end


		-- A node is not added to its own registry. It is added to the scenes node dictionary.

		-- Any changes made to the node via local variable, scene get or stage-scene fetch will be reflected across all scenes using this button.
		return new


	end
	clone.createParagraph = function() end
	clone.createScroll = function() end
	clone.createList = function() end

	clone.getStageFromRegistry = function( name ) -- returns stage from registry. (stage:updateToRegistry())
		return registryFetch( name )
	end

	clone.startAllStages = function( ... )
		-- start each passed stage in parallel. Only break if all stages are complete.
		parallel.waitForAll( ... )
	end

	clone.file = {
		getHandle = function( path, mode )
			if fs.exists( path ) then
				return fs.open( path, mode or "r" )
			else
				return false
			end
		end,
		write = function( path, content )
			local h = fs.open( path, "w")
			h.write( content )
			h.close()
			return true
		end,
		append = function( path, content )
			local h = clone.file.getHandle( path, "a" )
			if h then
				h.write( content )
				h.close()
				return true
			else
				return false
			end
		end,
		writeLine = function( path, content )
			local h = fs.open( path, "r" )
			h.writeLine( content )
			h.close()
			return true
		end,
		getLine = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readLine()
				h.close()
				return cnt
			else
				return false
			end
		end,
		getAll = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readAll()
				h.close()
				return cnt
			else
				return false
			end
		end
	}

	clone.canvas = {
		drawArea = function() end,
		drawHLine = function() end,
		drawVLine = function() end,
		drawText = function() end,
		drawCText = function() end
	}

	clone.color = {
		getFilter = function() end,
		setFilter = function() end,
		getColor = function() end
	}

	return clone

end