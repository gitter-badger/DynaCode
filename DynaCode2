--[[

	DynaCode V2
	A complete rebuild of the old framework, which was never actually released (-_-). I got bored and a little annoyed at the old
	version, the idea was to make GUIs simple, I felt that they were still too complex, even with DynaCode.
	This is why I created... DynaCode V2
	
	DynaCode is a graphical framework for ComputerCraft, using scenes, stages and controller functions. 
	Inspired by JavaFX.

	DynaCode is used by all HexCode programs.
	
	Released under MIT license, see License file here: https://github.com/hbomb79/DynaCode/blob/master/LICENSE

	Copyright Harry Felton(HexCode) and all other contributors 2015

]]

if not term.isColor() or not term.isColor then
	error("DynaCode V2 Requires advanced (gold) computer running ComputerCraft 1.5+") --may be out of date PC (pre-color support) or a standard PC (no color support)
end

local update = {
	keepUpToDate = true, -- Check for updates when this API is loaded. If update check fails the API will simply continue.
	updatePath = "DynaCode2", -- Where is the API installed
	updateUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/DynaCode2", -- Path to download. This is set to my repository on GitHub.
	versionUrl = "https://raw.githubusercontent.com/hbomb79/DynaCode/master/version", -- Path to version file. This is set to my repository on GitHub.
	versionPath = "DynaCodeVersion", -- Leave as is if you like, or change to a file (ideally in the same directory as DynaCode)
	output = true, -- print information to the screen during update check
	resetScreenPost = true -- clear the screen after update check (recommended because the text color will be changed)
}

--[[

NOTE: Do not edit past this point **unless** you understand what you are doing.
If you experience crashes after changing ANY (AT ALL!) code, DO NOT REPORT. 

Re-download DynaCode or revert
your changes, then try to reproduce the error WITHOUT editing source code. Then and only then will
your report be addressed.

If you encounter a crash then follow the steps:

1. Screen shot the error
2. Enable logging in DynaCode IMMEDIATELLY after cloning ( .clone() ) refer to: https://github.com/hbomb79/DynaCode/wiki/Clone-Methods-&-Objects/ for how to.
3. Attempt to reproduce the error with logging enabled.
4. Write down the steps you used to reproduce.
5. Create a comment in the DynaCode forum page (CC Forums) and include the screen shot, your steps to reproduce, the contents of the log file and your code.

I will get back to you as soon as I can and help you fix the problem.

If we cannot track down the problem, then I will request you send me your DynaCode copy, which will then be hash checked against the online version.
If your version has any changes (excluding update table, comments or unrelated code) and reverting your changes fixed the problem, then your code will
be sent back and future reports will not be processed.

If your version has any changes that, once reverted did not change the outcome, then the changes will be omitted and your request will be processed at
no penalty.

]]

local function uPrint( ... )
	if update.output then
		print( ... )
	end
end

function setUpdatePath( v )
	update.updatePath = v
end

function getUpdatePath()
	return update.updatePath
end

function setVersionPath( v )
	update.versionPath = v
end

function getVersionPath()
	return update.versionPath
end

function setOutput( v )
	update.output = v
end

function getOutput()
	return update.output
end

function setResetScreen( v )
	update.resetScreenPost = v
end

function getResetScreen()
	return update.resetScreenPost
end



local function updateCheck()
	uPrint("DynaCode V2 - Update Check Begin")
	for i = 1, 3 do
		uPrint("Version fetch attempt ", i, " of ", 3)
		local response = http.get( update.versionUrl )
		if response then
			uPrint("Version information fetch complete")
			local version, sVersion = response.readLine(), false
			local h = fs.open( update.versionPath, "r" )
			if h then
				sVersion = h.readLine()
				uPrint("Local version file read complete")
				h.close()
			else
				term.setTextColor( colors.orange )
				uPrint("No local version file found. Forcing update")
				term.setTextColor( colors.white )
			end
			if not sVersion or not h or sVersion ~= version or not fs.exists( update.updatePath ) then
				term.setTextColor( colors.orange )
				uPrint("New update available, fetching")
				term.setTextColor( colors.white )
				for nI = 1, 3 do
					uPrint("Fetching update. Attempt ", nI, " of ", 3)
					local updateResponse = http.get( update.updateUrl )
					if updateResponse then
						uPrint("Update downloaded, installing")
						local content = updateResponse.readAll()
						local h = fs.open( update.updatePath, "w" )
						h.write( content )
						h.close()
						local h = fs.open( update.versionPath, "w" )
						h.write( version )
						h.close()
						term.setTextColor( colors.lime )
						uPrint("Installed. Rebooting in 1 second")
						sleep(1) 
						os.reboot()
					end
				end
				term.setTextColor( colors.red )
				uPrint("Failed to fetch update!")
				return false
			elseif sVersion == version then
				term.setTextColor( colors.lime )
				uPrint("Up-To-Date!")
				return true
			end
		end
	end
	term.setTextColor( colors.red )
	uPrint("Failed to download version data!")
	return false
end

function checkForUpdates()
	return updateCheck()
end

if update.keepUpToDate then
	updateCheck()
	sleep(0.5)
	if update.resetScreenPost then
		term.clear()
		term.setCursorPos(1, 1)
		term.setTextColor( colors.white )
	end
end



--[[
	--==========--
   Private Defaults
	--==========--
]]

local CCMLCFG = {
	"backgroundColor",
	"textColor",
	"disabledBackgroundColor",
	"disabledTextColor",
	"unfocusedBackgroundColor",
	"unfocusedTextColor"
}

local CCMLObjects = {
	["Window"] = {},
	["Button"] = {
		["x"] = { format = "Number", default=1 },
		["y"] = { format = "Number", default=1},
		["width"] = { format = "Number", default=10},
		["height"] = { format = "Number", default=2},
		["text"] = { format = "String", default="undefined"},
		["toggle"] = { format = "Boolean", default=false},
		["toggleText"] = { format = "String", default="undefined"},
		["toggleTextColor"] = { format = "Color", default=colors.white},
		["toggleBackgroundColor"] = { format = "Color", default=colors.black},
		["toggleState"] = { format = "Boolean", default=false}
	},
	["Text"] = {
		["x"] = { default=1, format = "Number"},
		["y"] = { default=1, format = "Number"},
		["text"] = { default="undefined", format = "String"},
		["width"] = { default=10, format = "Number"},
		["cutoff"] = { default="...", format = "String"}
	},
	["Paragraph"] = {
		["x"] = { default=1, format="Number"},
		["y"] = { default=1, format="Number"},
		["text"] = { default="undefined", format="String"},
		["width"] = { default=10, format="Number"},
		["height"] = { default=2, format="Number"},
		["cutoff"] = { default="...", format="String"}
	},
	["Image"] = {},
	["TextField"] = {},
	["PasswordField"] = {},
	["ReplaceField"] = {},
	["ScrollList"] = {},
	["List"] = {}
}

local defaultSettings = {
	hide = function( self )

	end,
	show = function( self )

	end,
	toggleShow = function( self )

	end,
	enable = function( self )

	end,
	disable = function( self )

	end,
	toggleEnable = function( self )

	end
}
local nodeMethods = {
	remove = function( self )

	end
}
local sceneMethods = {
	addNode = function( self, node )

	end,
	removeNode = function( self, name )

	end,
	removeAllNodes = function( self )

	end,
	addAllNodes = function( self, nodes )

	end,
	loopNodes = function( self, callback )

	end,
	getNode = function( name )

	end
}

--[[
	--==========--
    Private Methods
	--==========--
]]

local function parseargs(s)
	local arg = {}
	string.gsub(s, "([%-%w]+)=([\"'])(.-)%2", function (w, _, a)
		arg[w] = a
	end)
	return arg
end

local function collect(s)
	local stack = {}
	local top = {}
	table.insert(stack, top)
	local ni,c,label,xarg, empty
	local i, j, str = 1, 1, false
	while true do
		ni,j,c,label,xarg, empty = string.find(s, "<(%/?)([%w:]+)(.-)(%/?)>", i)
		if not ni then break end
		local text = string.sub(s, i, ni-1)
		if not string.find(text, "^%s*$") then
			str = text
			--table.insert(top, { content = text })
		end
		if empty == "/" then  -- empty element tag
			local tbl = {
				label=label, 
				xarg=parseargs(xarg), 
				empty=1
			}
			if str then
				tbl["content"] = str
			end
			table.insert(top, tbl)
			str = false
		elseif c == "" then   -- start tag
			top = {label=label, xarg=parseargs(xarg)}
			if str then
				top["content"] = str
			end
			table.insert(stack, top)   -- new level
			str = false
		else  -- end tag
			local toclose = table.remove(stack)  -- remove top
			top = stack[#stack]
			if #stack < 1 then
				return false, ("No opening tag for: "..label)
			end
			if toclose.label ~= label then
				return false, ("Cannot close "..toclose.label.." with "..label)
			end
			if str then
				toclose["content"] = str
			end
			table.insert(top, toclose)
			str = false
		end
		i = j+1
	end
	local text = string.sub(s, i)
	if not string.find(text, "^%s*$") then
		table.insert(stack[#stack], text)
	end
	if #stack > 1 then
		return false, ("No closing tag for: "..stack[#stack].label)
	end
	return stack[1]
end

local function checkRequirements( given, required, silent )
	if not given or type(given) ~= "table" then
		error("Options of type table expected to create node, got "..type(given).." instead. Cannot pass node.")
	end
	local r = required
	local function compile( prefix )
		local msg = prefix or ""
		for k, v in ipairs(r) do
			msg = msg..tostring(v)
			if k < #r then msg = msg .. "," end
		end
		return msg
	end
	for opt in pairs( given ) do
		for key, value in ipairs( r ) do
			if value == opt then
				table.remove( r, key )
			end
		end
	end
	if #r <= 0 then return true 
	elseif not silent then
		error( compile("Missing requirements to create node: \n") )
	else
		return false, compile("")
	end
end

local function copy( tbl )
	if type( tbl ) == "table" then
		-- loop through table, copying keys
		local copy = {}
		for key, value in ipairs(tbl) do
			copy[key] = value
		end
		return copy
	else
		return tbl
	end
end


function clone( options )
	-- Create a new copy of DynaCode, this is to be used practically
	local ok, err = checkRequirements( options, {
		"instanceName"
	}, true)
	if not ok and err then
		error("Cannot create clone, missing: "..tostring( err ))
	end
	local stages, scenes, instance, clone, defaults, stageBuffer = {}, {}, {}, {}, {}, {}
	instance.loggingReady = false
	setmetatable( instance, {__index=clone})
	setmetatable( clone, {__index=options})
	setmetatable( options, {__index=defaults})


	local function log( mode, msg )
		if instance.loggingReady then
			local prefix = "Info"
			if mode == "w" then prefix = "Warn" elseif mode == "e" then prefix = "ERROR" end
			clone.file.append( instance.loggingPath, "["..prefix.."] "..msg.."\n")
		end
	end



	local function getScene( sc )

		--[[
			Every time a scene is created it will be added to an instance based dictionary.

			If a stage that owns a scene is removed, that scene will be removed as well.

		]]

		local v

		if type( sc ) == "string" then
			v = {}
			v.sceneName = sc
		elseif type( sc ) == "table" then
			v = sc
		else
			error("Argument of String or Table expected, got: "..tostring( type(sc) ) )
		end

		for key, scene in ipairs( scenes ) do
			-- check this scene
			if scene.sceneName == v.sceneName then
				-- this is the scene.
				return scene
			end
		end
		return false
	end

	local function removeScene( v )

		for key, scene in ipairs( scenes ) do
			if scene.sceneName == v.sceneName then
				table.remove( scenes, key )
			end
		end

	end

	local function addScene( scene )

		removeScene( scene )
		table.insert( scenes, scene )

	end

	local function getStage( stageName )

		for k, v in ipairs( stages ) do
			if v.getName() == stageName then
				return v
			end
		end
		return false
	end

	local function removeStage( v )
		for key, stage in ipairs( stages ) do
			if stage.getName() == v then
				table.remove( stages, key )
			end
		end
	end

	local function addStage( stage )
		removeStage( stage.getName() )
		table.insert( stages, stage )
	end

	local buffer = {

		reorder = function( toplevel )
			-- The buffer is a table populated by stages. DynaCode works out which window is on top by iterating the table using the value as a base.
			-- First, loop the buffer, and create a list of levels. We will use this list to loop through the buffer later and preserve the levels of previous stages.
			local structure = copy( stages )

			-- Set the top level stage to a level of 1
			local i = 1
			for key, item in ipairs( structure ) do
				if item.getName() == toplevel then
					item:setLevel(1) -- set to locally
					local tempStage = getStage( toplevel )
					if not tempStage then error("Stage not in dictionary: "..item.getName()) end
					tempStage:setLevel(1) -- because structure is a copy, we need to save changes we make to the instance stages.
					i = 2
				end
			end
			table.sort(structure, function( a, b ) return a.getLevel() > b.getLevel() end)
			for key, item in ipairs( structure ) do
				if item.getName() ~= toplevel then
					item:setLevel( i )
					local tempStage = getStage( item.getName() )
					if not tempStage then error("Stage not in dictionary: "..item.getName()) end
					tempStage:setLevel( i )
					i = i + 1
				end
			end
			table.sort(structure, function( a, b ) return a.getLevel() > b.getLevel() end)
			stageBuffer = structure

		end,
		redrawAll = function( ignoreRules ) 

			for _, stage in ipairs( stageBuffer ) do
				stage.draw()
			end

		end,
		getHighestLevel = function( nX, nY )
			-- return the first occurrence of a stage at the clicked co-ords. Because the table is sorted correctly, ipairs will result in the

			for i = #stageBuffer, 1, -1 do -- loop table in reverse because the last node is drawn last and is therefore on top of others.
				local stage = getStage( stageBuffer[i].getName() )
				if stage then
					local stageX, stageY = stage.getX(), stage.getY()
					if nX >= stageX and nX <= stageX + stage.getWidth() - 1 and nY >= stageY and nY <= stageY + stage.getHeight() - 1 then
						return stage
					end
				end
			end
		end
	}

	clone.bufferReorder = function( preference )
		buffer.reorder( preference )
	end


	--[[
		--==========--
	  	Stage & Scenes
		--==========--
	]]

	clone.stage = function( options )
		-- Window
		checkRequirements(options, {"stageName"})
		local defaults = {
			windowed = false,
			allowTerminate = false,
			level = 1,
			x = 2,
			y = 2,
			width = 10,
			height = 5,
			borderless = false,
			backgroundColor = colors.lightGray,
			allowClose = true
		}
		local alerts = {}

		-- A stage represents a window, nodes (elements) can be added to this window and are subject to its terms.
		--[[
			@return table
		]]
		local settings = { active = true, timers = {} } --settings are now private and must be accessed via methods.

		--[[
			A stages loop is run in a Coroutine, meaning each stage runs independently from each other and shares only events.
		]]

		local function update( sSetting, _value, fMethod, isSecond ) end

		local function draw()
			-- Clear the area using the backgroundColor. Then loop each node and call its draw function (node.draw)
			if not settings.borderless then
				clone.canvas.drawHorizontalLine( settings.x, settings.y, settings.width-1, colors.white )
				term.setBackgroundColor( colors.white )
				term.setCursorPos( settings.x, settings.y )
				term.setTextColor( colors.black )
				write( settings.stageName )
				if settings.active then
					write(" [active]")
				else
					write(" [inactive]")
				end
				if settings.allowClose then
					term.setBackgroundColor( colors.red )
					term.setCursorPos( settings.x+settings.width-1, settings.y )
					write( "X" )
				end
				clone.canvas.drawArea( settings.x, settings.y+1, settings.width, settings.height, settings.backgroundColor )
			else
				clone.canvas.drawArea( settings.x, settings.y, settings.width, settings.height, colors.red )
			end
		end
		local function executeFunctionFromScene( sName )
			if not settings.scene then error("No scene set to this stage. Use stage.setScene()") end
			local sScene = getScene( settings.scene )
			if not sScene then error("Scene is not active") end
			if not sScene.executeFunctionFromController( sName ) then error("Could not find function '"..sName.."' in controller") end
		end

		local function handleClick( event, nButton, nX, nY )
			-- First, check if the click co-ords were on a node.
			-- Then check if the click co-ords were on the top of the window.
			local highest = buffer.getHighestLevel( nX, nY )
			if not highest or highest.getName() ~= settings.stageName then
				-- this window is not the target.
				settings.active = false
				buffer.redrawAll()
				return
			end
			term.setTextColor( colors.white )
			term.setBackgroundColor( colors.black )
			local st = getStage( settings.stageName )
			if not st then error("dead stage") end
			st:setLastClick( nX, nY )
			if nX >= settings.x and nX <= settings.x+settings.width-1 and nY == settings.y and not settings.borderless then
				--error("Top bar clicked")
				if nX == settings.x+settings.width-1 and nY == settings.y and settings.allowClose then
					os.queueEvent( "break_stage_"..tostring(settings.stageName) )
				end
			else
				-- is on clicked element?
				-- To check, loop scene nodes.
				local clicked, nodes = false, false
				if settings.scene then
					nodes = settings.scene.getNodes()
				end
				if nodes and type( nodes ) == "table" and #nodes > 0 then
					for _, node in ipairs( settings.scene.getNodes() ) do
						if nX >= node.getX() and nX <= node.getX() and nY >= node.getY() and nY <= node.getY() then
							clicked = true
							error("Node "..node.getName().." clicked")
						end
					end
				end
			end
			--buffer.redrawAll()
		end

		local function handleScroll( event, nDirection, nX, nY ) end

		local function handleDrag( event, button, nX, nY )
			local stage = getStage( settings.stageName )
			if not stage then
				error("This stage is dead")
			elseif stage then
				-- if the last click (drag start) was on the top bar, or the very top of the screen (borderless), allow drag
				local lastX, lastY = stage.getLastClick()
				if not stage.getBorderless() then
					if lastY ~= stage.getY() then
						return
					end
				end
				local cX, cY, redraw = stage.getX(), stage.getY(), false
				local termX, termY = term.getSize()
				if nX > lastX then
					local newX = cX + 1
					if newX + stage.getWidth() - 1 > termX then
						newX = cX
					else
						redraw = true
					end
					stage:setX( newX )
				elseif nX < lastX then
					local newX = cX - 1
					if newX < 1 then
						newX = 1
					else
						redraw = true
					end
					stage:setX( newX )
				end
				if nY > lastY then
					local newY = cY + 1
					if newY + stage.getHeight() > termY then
						newY = cY
					else
						redraw = true
					end
					stage:setY( newY )
				elseif nY < lastY then
					local newY = cY - 1
					if newY < 1 then
						newY = 1
					else
						redraw = true
					end
					stage:setY( newY )
				end
				stage:setLastClick( nX, nY )
				if redraw then
					term.setBackgroundColor( colors.black )
					term.clear()
					buffer.reorder( stage.getName() )
					buffer.redrawAll()
				end
			end
		end

		local function handleKey( event, kKey, bHeld ) end

		local function handleChar( event, char ) end

		local function loop()
			-- Each stage has an event loop. Any events fired will only affect the current stage (last clicked)
			-- this loop must ONLY be running if the stage is ACTIVE. When unfocused this loop must be interrupted using event "break_stage_inactive"
			-- To break one loop use "break_stage_<STAGE.stageName>"

			while true do
				local e, p1, p2, p3, p4, p5, p6 = os.pullEventRaw()
				local currentActive = settings.active
				if e == "mouse_click" then
					local high = buffer.getHighestLevel( p2, p3 )
					if high and type( high ) == "table" then
						if high.getName() == settings.stageName then
							settings.active = true
							buffer.reorder( settings.stageName )
							buffer.redrawAll()
						end
					end
				end
				if e == "break_stage_"..settings.stageName then
					log("i", "Broken stage "..settings.stageName)
					removeStage( settings.stageName )
					buffer.reorder()
					term.setBackgroundColor( colors.black )
					term.clear()
					buffer.redrawAll()
					break
				elseif e == "break_stage_inactive" then
					-- is this stage inactive? if so, break the loop
					if not settings.active then break end
				elseif currentActive then
					-- On an action event, search the scenes nodes, if one was clicked, execute its action argument OR search the scenes
					-- controller for it.

					-- These events will only be responded to/acted upon if the stage is active (only one active at a time)
					if e == "timer" then
						if settings.timers[p1] then
							local tmr = settings.timers[p1]
							if tmr.parent == settings.name then
								tmr:oncomplete()
								if tmr.rp then
									new.createTimer( tmr.name, tmr.duration, tmr.oncomplete, tmr.rp )
								end
							end
						end
					elseif e == "mouse_drag" then handleDrag( e, p1, p2, p3 )
					elseif e == "mouse_scroll" then handleScroll( e, p1, p2, p3 )
					elseif e == "key" then handleKey( e, p1, p2 )
					elseif e == "char" then handleChar( e, p1 )
					elseif e == "mouse_click" then handleClick( e, p1, p2, p3 )
					elseif e == "terminate" and settings.allowTerminate then
						term.setTextColor( colors.red )
						print("Terminated stage "..settings.stageName)
						term.setTextColor( colors.white )
						log("i", "Stage "..settings.stageName.." has been terminated")
						removeStage( settings.stageName )
						buffer.reorder()
						break
					end
				end
			end
		end
		setmetatable( settings, {__index=options} )
		setmetatable( options, {__index=defaults} )

		new = {}
		new.setLastClick = function( self, nX, nY )
			settings.lastX, settings.lastY = nX, nY
			addStage( self )
		end
		new.getLastClick = function()
			return settings.lastX, settings.lastY
		end
		new.setBorderless = function( self, bV )
			settings.borderless = bV
			addStage( self )
		end
		new.getBorderless = function() return settings.borderless end
		new.setCanClose = function( self, bClose )
			settings.allowClose = bClose
			addStage( self )
		end
		new.getCanClose = function() return settings.allowClose end
		new.setLevel = function( self, nLevel, secondary )
			settings.level = nLevel
			addStage( self )
			--update( "level", nLevel, "setLevel", secondary)
			-- every time a setter is used, get the copy from the stages table, and apply the setting their too.
		end
		new.getLevel = function()
			return settings.level
		end
		new.getX = function()
			return settings.x
		end
		new.setX = function( self, v, secondary )
			settings.x = v
			addStage( self )
			buffer.reorder( self.getName() )
		end
		new.getY = function()
			return settings.y
		end
		new.setY = function( self, v, secondary )
			settings.y = v
			addStage( self )
		end
		new.getWidth = function()
			return settings.width
		end
		new.setWidth = function( self, v, secondary )
			settings.width = v
			addStage( self )
		end
		new.getHeight = function()
			return settings.height
		end
		new.setHeight = function( self, v, secondary )
			settings.height = v
			addStage( self )
		end
		new.setBackgroundColor = function( bg, r ) settings.backgroundColor = bg if not r then draw() end end
		new.getBackgroundColor = function() return settings.backgroundColor end
		new.setTextColor = function( tc, r ) settings.textColor = tc if not r then draw() end end
		new.getTextColor = function() return settings.textColor end
		new.setScene = function( self, scene, secondary )
			if type( scene ) ~= "table" then error("expected scene of type table, got "..tostring( type( scene ) ) ) end
			-- First, check if this scene is already in use by another window.

			local isScenePresent = getScene( scene )
			if isScenePresent and type(isScenePresent) == "table" and isScenePresent.parentStage then
				local usingStage = getStage( isScenePresent.parentStage.stageName )
				if usingStage then
					-- another stage is using this scene. remove the scenes parent stage
					usingStage.removeScene()
				end
			end

			scene.parentStage = settings.stageName
			settings.scene = scene
			addStage( self )
			addScene( scene )


		end
		new.removeScene = function()
			-- unset the active scene.
			local currentScene = getScene( settings.scene )
			currentScene.parentStage = false
			removeScene( currentScene )

		end
		new.getScene = function() return settings.scene end
		new.getEnable = function() return settings.enabled end
		new.setEnable = function( e, r ) settings.enabled = e if not r then draw() end end
		new.setVisible = function() end
		new.getVisible = function() end
		new.draw = function() draw() end
		new.createTimer = function( name, duration, method, rep )
			settings.timers = settings.timers or {}

			settings.timers[ os.startTimer( duration ) ] = {
				duration = duration,
				oncomplete = method,
				rp = rep,
				name = name,
				status = {
					running = false,
					startedWhen = false
				}
			}
		end
		new.stopTimer = function( name )
			for k, v in pairs( settings.timers ) do
				if v.name == name then
					os.cancelTimer( k )
					v.rp = false
				end
			end
		end
		new.removeAllTimers = function()
			for k, v in pairs( settings.timers ) do
				os.cancelTimer( k )
			end
		end
		new.getTimers = function()
			return settings.timers
		end
		new.getName = function() return settings.stageName end
		new.register = function( self )
			if not self then
				error("Bad call: myStageVariable:register(). Note: A semicolon is required!")
			end
			addStage( self )
			return self -- if :register() is attached onto a variable declaration, then returning self will allow the declaration to work (not set to nil)
		end
		new.start = function( method )
			if method then
				parallel.waitForAll( function()
					loop()
					removeStage( settings.stageName )
					buffer.reorder()
				end, method )
			else
				loop()
			end
			
		end
		new.stop = function( method ) 
			os.queueEvent( "break_stage_"..tostring(settings.stageName) )
			if method then method() end
		end

		new.exe = function( sName )
			executeFunctionFromScene( sName )
		end

		return new
	end

	clone.scene = function( options )
		checkRequirements( options, {"sceneName"})
		local new  = {}
		local settings = { nodes = {} }
		local defaults = {}
		local controller = {}
		setmetatable( settings, {__index=options} )
		setmetatable( options, {__index=defaults} )
		--If path provided then load the DCML file

		local function doesNodeExit( nodeName )
			for k, v in ipairs( settings.nodes ) do
				if v.name == nodeName then return true end
			end
			return false
		end

		local function checkControllerForEntry( sName )
			if type( sName ) ~= "string" then error("Expected entry of type string, got "..tostring( type(sName)) ) end

			for key, tDetails in ipairs( controller ) do
				if tDetails.functionName == sName then
					return true
				end
			end
		end

		local function getEntryFromController( sName )
			for key, value in ipairs( controller ) do
				if value.functionName == sName then
					return value
				end
			end
			return false
		end

		local function removeEntryFromController( sName )

			for k, v in ipairs( controller ) do
				if v.functionName == sName then
					table.remove( controller, k )
				end
			end

		end

		local function addEntryToController( sFunction, fFunction )
			removeEntryFromController( sFunction )
			table.insert( controller, {
				functionName = sFunction,
				functionMethod = fFunction
			})
		end


		new.addNode = function( node ) 
			if not doesNodeExit( node.name ) then
				-- does not already exist
				table.insert( settings.nodes, node )
				node.parentScene = options.name
			end
		end
		new.addAllNodes = function( ... )
			for key, node in ipairs( ... ) do
				new.addNode( node )
			end
		end
		new.getNodes = function() 
			return settings.nodes
		end
		new.removeNode = function( nodeName ) 
			for k, v in ipairs( settings.nodes ) do
				if v.name == nodeName then
					v.parentScene = nil
					table.remove( settings.nodes, k ) 
				end
			end
		end
		new.removeAllNodes = function() 
			for key, node in ipairs( settings.nodes ) do
				node.parent = nil
				table.remove( settings.nodes, key )
			end
		end

		new.loadFromFile = function( path )
			local file = clone.file.getAll( path )
			if not file then error("Failed to load DCML file: "..tostring( path )) end
			local content, err = collect( file )
			if not content then error("Failed to parse DCML file: "..tostring( path ).." "..tostring(err)) end
			-- We have the XML. If an element has an action event, then convert that to a function.
			settings.loadedContent = {
				dcml = content
			}
			log("i", "Successfully loaded DCML file from path "..tostring( path ))
		end
		new.reset = function() 
			-- iffy
		end

		-- Controller functions

		--[[
			The controller is used to handle action events in DCML. When an onclick, onchange, ontype, onscroll is caught on the object, the function assigned is looked for here

			Because not ALL functions may be in the Global Space (_G), checking said space is unpractical, so instead the developer can choose which functions can be accessed by the
			file.

			To add a function to the scenes controller, simply use .addToController( function Func ). Pass in the name of the function (how it will be reference in DCML) and the functions itself.
			If the function is changed after being registered, DCML will call the original, therefore call <scene>.updateControllerItem( String functionName, function newFunction )

			To add multiple functions to the controller use .addAllToController( function Func1, function Func2, ... etc )

			In DCML simply reference the function using its name as a string.

		]]

		new.addToController = function( sFunctionName, sFunction )
			removeEntryFromController( sFunctionName )
			addEntryToController( sFunctionName, sFunction )
		end

		new.addAllToController = function( tFunctions )
			if type( tFunctions ) ~= "table" then
				error("Expected type table, got "..type( tFunctions )..". Cannot add functions to controller.")
			end
			-- tFunctions structure:
			--[[
			{
				{
					name = "name",
					method = function() print("I am a method") end
				},
				{
					name = "anotherName"
					method = someMethodInMyMainProgram - NO PARENTHESES
				}
			}
			]]
			for key, node in ipairs( tFunctions ) do
				if not node.name or not node.method then
					error("In order to add multiple to controller the format must be: { name = 'referenceName', method = function }")
				end
				addEntryToController( node.name, node.method )
			end
		end

		new.getAllFromController = function()
			return controller
		end

		new.updateControllerItem = function( functionName, newFunction )
			removeEntryFromController( functionName )
			addEntryToController( functionName, newFunction )
		end

		new.getFromController = function( sName ) 
			return getEntryFromController( sName )
		end

		new.removeFromController = function( sName )
			removeEntryFromController( sName )
		end

		new.executeFunctionFromController = function( sName )
			local func = getEntryFromController( sName )
			if not func then return false elseif func then
				func.functionMethod()
				return true
			end
		end

		new.removeAllFromController = function()
			for k, v in ipairs( controller ) do
				table.remove( controller, k )
			end
		end
		return new
	end

	--[[
		--==========--
    Miscellaneous Utilities
		--==========--
	]]

	clone.canvas = {
		drawArea = function( nX, nY, width, height, background )
			if height < 1 or width < 1 then
				error( "Cannot draw area with 0< width or height.")
			end
			for x = 0, width-1 do
				clone.canvas.drawVerticalLine( nX+x, nY, height-1, background )
			end
		end,
		drawVerticalLine = function( nX, nY, height, background ) 
			paintutils.drawLine( nX, nY, nX, nY+height, background )
		end,
		drawHorizontalLine = function( nX, nY, width, background ) 
			paintutils.drawLine( nX, nY, nX+width, nY, background )
		end
	}

	clone.file = {
		getHandle = function( path, mode )
			if fs.exists( path ) then
				return fs.open( path, mode or "r" )
			else
				return false
			end
		end,
		write = function( path, content )
			local h = fs.open( path, "w")
			h.write( content )
			h.close()
			return true
		end,
		append = function( path, content )
			local h = clone.file.getHandle( path, "a" )
			if h then
				h.write( content )
				h.close()
				return true
			else
				return false
			end
		end,
		writeLine = function( path, content )
			local h = fs.open( path, "r" )
			h.writeLine( content )
			h.close()
			return true
		end,
		getLine = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readLine()
				h.close()
				return cnt
			else
				return false
			end
		end,
		getAll = function( path )
			local h = clone.file.getHandle( path, "r" )
			if h then
				local cnt = h.readAll()
				h.close()
				return cnt
			else
				return false
			end
		end
	}
	clone.wireless = {
		-- RedNet
	}

	clone.remote = {
		-- HTTP
	}

	clone.redstone = {
		
	}

	clone.monitor = {
		
	}

	clone.peripheral = {
		
	}

	clone.group = {
		
	}


	--[[
		--==========--
	  Node Declarations
		--==========--
	]]

	clone.button = function( options )
		local settings = {}
		local defaults = {}
		setmetatable( settings, {__index=options} )
		setmetatable( options, {__index=defaults} )
		local function draw()

		end
		local new = {}
		new.draw = function() draw() end
		new.getTextColor = function() return settings.textColor end
		new.setTextColor = function() end
		new.getBackgroundColor = function() return settings.backgroundColor end
		new.setBackgroundColor = function() end
		new.getToggle = function() return settings.toggle end
		new.setToggle = function() end
		new.getToggleState = function() return settings.toggleState end
		new.setToggleState = function() end
		new.getEnabled = function() return settings.enabled end
		new.setEnabled = function() end
		new.getDisabledBackgroundColor = function() return settings.disabledBackgroundColor end
		new.setDisabledBackgroundColor = function() end
		new.getDisabledTextColor = function() return settings.disabledTextColor end
		new.setDisabledTextColor = function() end
		return new
	end

	clone.textInput = function()
		
	end

	clone.scrollList = function()
		
	end

	clone.list = function()
		
	end

	clone.paragraph = function( options )
		local new = {}
		local settings = {}
		local defaults = {}
		setmetatable( settings, {__index=options})
		setmetatable( options, {__index=defaults})

		new.draw = function()
			-- Each object has its own custom draw function.
		end
		new.getBackgroundColor = function()
			return settings.backgroundColor
		end
		new.setBackgroundColor = function( v )
			settings.backgroundColor = v
		end
		new.getTextColor = function()
			return settings.textColor
		end
		new.setTextColor = function( v )
			settings.textColor = v
		end
		new.getText = function()
			return settings.text
		end
		new.setText = function( v )
			settings.text = v
		end

	end

	--[[
		--==========--
	   Logging Methods
		--==========--
	]]

	clone.setLogging = function( v )
		instance.logging = v
	end

	clone.getLogging = function( v )
		return instance.logging
	end

	clone.getLog = function()
		-- Open the log file and return its contents.
		return clone.file.getAll( instance.loggingPath )
	end

	clone.setLoggingPath = function( v )
		instance.loggingPath = v
	end

	clone.getLoggingPath = function()
		return instance.loggingPath
	end

	clone.logToFile = function( mode, message )
		log( mode, message )
	end

	clone.initializeLogging = function()
		if not instance.logging or not instance.loggingPath then
			error("Set logging and logging path before initializing")
		end
		local h = fs.open( instance.loggingPath, "w" )
		if h then
			h.write("--@@==== DynaCode Logging - Instance: "..instance.instanceName.." ====@@--\n")
			h.close()
			instance.loggingReady = true
		else
			error("Failed to create file handle for path: "..tostring( instance.loggingPath ))
		end
	end

	return clone
end